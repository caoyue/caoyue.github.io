<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="Supervisor 的四个 Restart Strategy 中，关于 one for one 和 simple one for one , 虽然很多地方都说 simple one for one 是 one for one 的简化版，但两者之间还是有一些不同。
1. 先来看一个简单的 one for one 和 simple one for one 的例子   one for one
init(_Args) -> {ok, {{one_for_one, 1, 60}, [{call, {call, start_link, []}, permanent, brutal_kill, worker, [call]}]}}.  simple one for one  init(_Args) -> {ok, {{simple_one_for_one, 0, 1}, [{call, {call, start_link, []}, permanent, brutal_kill, worker, [call]}]}}."><meta name=author content="caoyue"><title>且听疯吟 / Erlang/OTP Supervisor : one-for-one and simple-one-for-one</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>Erlang/OTP Supervisor : one-for-one and simple-one-for-one</div><div class=content><p>Supervisor 的四个 Restart Strategy 中，关于 one for one 和 simple one for one , 虽然很多地方都说 simple one for one 是 one for one 的简化版，但两者之间还是有一些不同。</p><h4 id=1-先来看一个简单的-one-for-one-和-simple-one-for-one-的例子>1. 先来看一个简单的 one for one 和 simple one for one 的例子</h4><ul><li><p>one for one</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>init</span><span class=p>(_</span><span class=nv>Args</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>ok</span><span class=p>,</span> <span class=p>{{</span><span class=n>one_for_one</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>60</span><span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>[{</span><span class=n>call</span><span class=p>,</span> <span class=p>{</span><span class=n>call</span><span class=p>,</span> <span class=n>start_link</span><span class=p>,</span> <span class=p>[]},</span>
</span></span><span class=line><span class=cl>            <span class=n>permanent</span><span class=p>,</span> <span class=n>brutal_kill</span><span class=p>,</span> <span class=n>worker</span><span class=p>,</span> <span class=p>[</span><span class=n>call</span><span class=p>]}]}}.</span>
</span></span></code></pre></div><ul><li>simple one for one</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>init</span><span class=p>(_</span><span class=nv>Args</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=n>ok</span><span class=p>,</span> <span class=p>{{</span><span class=n>simple_one_for_one</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>[{</span><span class=n>call</span><span class=p>,</span> <span class=p>{</span><span class=n>call</span><span class=p>,</span> <span class=n>start_link</span><span class=p>,</span> <span class=p>[]},</span>
</span></span><span class=line><span class=cl>            <span class=n>permanent</span><span class=p>,</span> <span class=n>brutal_kill</span><span class=p>,</span> <span class=n>worker</span><span class=p>,</span> <span class=p>[</span><span class=n>call</span><span class=p>]}]}}.</span>
</span></span></code></pre></div><p>初始化方法非常相似</p></li></ul><h4 id=2-启动-supervisor>2. 启动 Supervisor</h4><ul><li>one for one<br>启动时，会同时启动一个子进程</li><li>simple one for one<br>启动时，supervisor 并不会启动任何子进程，所有的子进程都是通过 <code>supervisor:start_child(Sup, List)</code> 来动态添加的</li></ul><h4 id=3-允许的-child-type>3. 允许的 Child Type</h4><ul><li>one for one<br>允许不同的 child type，所以每次添加子进程都需要传递完整的 child spec</li><li>simple one for one<br>只能有一个 child type，不同的 child instance 可以共享同一个 child spec</li></ul><h4 id=4-添加子进程>4. 添加子进程</h4><ul><li><p>one for one<br>添加子进程的时候传递的是子进程规格</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nn>supervisor</span><span class=p>:</span><span class=nf>start_child</span><span class=p>(</span><span class=nv>Sup</span><span class=p>,</span> <span class=nv>ChildSpec</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p>simple one for one<br>添加子进程的时候传递的是任意的值列表，它将会被添加到子进程规格中的参数列表中，即实际上是通过 <code>apply(call, start_link, [] ++ List)</code> 来启动的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nn>supervisor</span><span class=p>:</span><span class=nf>start_child</span><span class=p>(</span><span class=nv>Sup</span><span class=p>,</span> <span class=nv>List</span><span class=p>)</span>
</span></span></code></pre></div></li></ul><p>相同的是，如果 supervisor 挂了，并且被 restart，之前动态添加的子进程将会全部丢失</p><h4 id=5-supervisor-停止>5. Supervisor 停止</h4><ul><li>one for one<br>按照启动 Spec 相反的顺序停止所有子进程，然后停止自身</li><li>simple one for one<br>由于 supervisor 启动的是同一子进程的多个 instance，因此在停止的时候不存在顺序，<br>在定义 Shutdown Strategy 的时候应该注意其 terminate 表现的区别。</li></ul></div><div class=tags><ul class=info><li>2015-01-20</li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",''),document.querySelector("section.article.discussion").innerHTML='',document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2022 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch(e){}</script></div></footer></div></body></html>