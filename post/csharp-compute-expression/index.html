<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#a6d6d6"/><meta name="msapplication-TileColor" content="#a6d6d6"/><meta name="msapplication-TileImage" content="/icon/favicon.ico"/><meta name="referrer" content="no-referrer"/><title>且听疯吟 / C# 中缀表达式计算</title><link rel="alternate" type="application/rss+xml" title="atom 1.0" href="/atom.xml"/><link rel="apple-touch-icon" sizes="192x192" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="48x48" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="192x192" href="/icon/favicon.ico"/><link rel="stylesheet" href="/css/normalize.css"/><link rel="stylesheet" href="/css/style.css"/><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><div class="header"><a href="/" title="this is a link">且听疯吟</a><span>如此生活三十年</span></div><div class="left"><ul class="list"><li><a href="/" title="Home">Home</a></li><li><a href="/archives" title="archive">Archive</a></li><li><a href="/tags" title="Tags">Tags</a></li></ul></div><div class="right"><div class="entry" id="content"><div class="title">C# 中缀表达式计算</div><div class="content"><p>给出一个字符串的计算表达式如 <code>1+2*(3-4)/5</code> ，不使用其他库如何计算其结果？<br>在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。</p>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>中缀表达式 (Infix Expression)，即形如 <code>a+b-c*d</code> 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。</p>
<h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 <code>a+b</code> 记作 <code>a b +</code>。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。</p>
<h3 id="表达式转换"><a href="#表达式转换" class="headerlink" title="表达式转换"></a>表达式转换</h3><p>既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法</a>。实际上语法树的后序遍历也是后缀表示法。</p>
<p>简单分析下从中缀表达式到后缀表达式的过程：</p>
<ol>
<li>定义两个栈 Operand（操作数栈）和 Operator（运算符栈）；</li>
<li>从左到右遍历字符串，按如下规则：<ul>
<li>如果该字符为左括号，直接压入 Operator 栈中；</li>
<li>如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈；</li>
<li>如果该字符是操作符：<ul>
<li>首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量；</li>
<li>查看 Operator 栈中是否存在运算符：<ul>
<li>如不存在，将该操作符压入 Operator 栈中；</li>
<li>如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级：<ul>
<li>该操作符优先级较高，将该操作符压入 Operand 栈中；</li>
<li>该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果该字符不是操作符也不是括号，则将其存入临时变量；</li>
</ul>
</li>
<li>循环完成，将临时变量（即最后一个数字）压入 Operand 栈中；</li>
<li>将 Operator 栈依次弹出并压入到 Operand 栈中；</li>
<li>将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。</li>
</ol>
<h3 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h3><ol>
<li>将后缀表达式转换成堆栈 Suffix；</li>
<li>定义一个新的栈 Result;</li>
<li>依次弹出 Suffix 栈顶元素：<ul>
<li>如果该元素不是运算符，将其压入 Result 栈中；</li>
<li>如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中；</li>
</ul>
</li>
<li>Result 栈顶元素即计算结果</li>
</ol>
<p>这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。</p>
<p>Demo:<br><code>gist ea924d24131d7c48dc9c</code></p>
</div><div><ul class="info"><li>posted on 2014-04-28<li><a href="/tags/csharp/">#csharp</a></li><li><a href="/tags/programming/">#programming</a></li></li></ul></div></div><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = "https://blog.caoyue.me/post/csharp-compute-expression/";
    this.page.identifier = "post/csharp-compute-expression/";
};

(function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://caoyue.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script></div><div class="footer"><div></div>©2021<a href="https://blog.caoyue.me"> 且听疯吟</a>. designed by<a href="https://caoyue.me" target="_blank"> caoyue</a>. powered by<a href="https://hexo.io/" target="_blank"> hexo</a></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
</div></body></html>