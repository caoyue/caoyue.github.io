<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="给出一个字符串的计算表达式如 1+2*(3-4)/5 ，不使用其他库如何计算其结果？
在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。
中缀表达式 中缀表达式 (Infix Expression)，即形如 a+b-c*d 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。
后缀表达式 后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 a+b 记作 a b +。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。
表达式转换 既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 调度场算法。实际上语法树的后序遍历也是后缀表示法。
简单分析下从中缀表达式到后缀表达式的过程：
定义两个栈 Operand（操作数栈）和 Operator（运算符栈）； 从左到右遍历字符串，按如下规则： 如果该字符为左括号，直接压入 Operator 栈中； 如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈； 如果该字符是操作符： 首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量； 查看 Operator 栈中是否存在运算符： 如不存在，将该操作符压入 Operator 栈中； 如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级： 该操作符优先级较高，将该操作符压入 Operand 栈中； 该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中； 如果该字符不是操作符也不是括号，则将其存入临时变量； 循环完成，将临时变量（即最后一个数字）压入 Operand 栈中； 将 Operator 栈依次弹出并压入到 Operand 栈中； 将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。 后缀表达式计算 将后缀表达式转换成堆栈 Suffix； 定义一个新的栈 Result; 依次弹出 Suffix 栈顶元素： 如果该元素不是运算符，将其压入 Result 栈中； 如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中； Result 栈顶元素即计算结果 这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。"><meta name=author content="caoyue"><title>且听疯吟 / C# 中缀表达式计算</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>C# 中缀表达式计算</div><div class=content><p>给出一个字符串的计算表达式如 <code>1+2*(3-4)/5</code> ，不使用其他库如何计算其结果？<br>在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。</p><h3 id=中缀表达式>中缀表达式</h3><p>中缀表达式 (Infix Expression)，即形如 <code>a+b-c*d</code> 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。</p><h3 id=后缀表达式>后缀表达式</h3><p>后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 <code>a+b</code> 记作 <code>a b +</code>。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。</p><h3 id=表达式转换>表达式转换</h3><p>既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 <a href=http://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95>调度场算法</a>。实际上语法树的后序遍历也是后缀表示法。</p><p>简单分析下从中缀表达式到后缀表达式的过程：</p><ol><li>定义两个栈 Operand（操作数栈）和 Operator（运算符栈）；</li><li>从左到右遍历字符串，按如下规则：<ul><li>如果该字符为左括号，直接压入 Operator 栈中；</li><li>如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈；</li><li>如果该字符是操作符：<ul><li>首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量；</li><li>查看 Operator 栈中是否存在运算符：<ul><li>如不存在，将该操作符压入 Operator 栈中；</li><li>如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级：<ul><li>该操作符优先级较高，将该操作符压入 Operand 栈中；</li><li>该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中；</li></ul></li></ul></li></ul></li><li>如果该字符不是操作符也不是括号，则将其存入临时变量；</li></ul></li><li>循环完成，将临时变量（即最后一个数字）压入 Operand 栈中；</li><li>将 Operator 栈依次弹出并压入到 Operand 栈中；</li><li>将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。</li></ol><h3 id=后缀表达式计算>后缀表达式计算</h3><ol><li>将后缀表达式转换成堆栈 Suffix；</li><li>定义一个新的栈 Result;</li><li>依次弹出 Suffix 栈顶元素：<ul><li>如果该元素不是运算符，将其压入 Result 栈中；</li><li>如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中；</li></ul></li><li>Result 栈顶元素即计算结果</li></ol><p>这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。</p><p>Demo:<br><code>gist ea924d24131d7c48dc9c</code></p></div><div class=tags><ul class=info><li>2014-04-28</li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>