<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="1. tuple and record 现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?
-record(test, { a::binary(), b::binary() }). KeyValuePairs = [{a, <<&#34;a&#34;>>},{b, <<&#34;b&#34;>>}]. 很基础的问题，我们这样做：
Result = #test{ a = get_value(a, KeyValuePairs), b = get_value(a, KeyValuePairs) }. 如果 record 有一百个项呢？
重复的写 a = get_value(a, KeyValuePairs) 这样的代码一百次大概会让人怀疑「猿」生吧 :(
虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道
Erlang 的 record 实际上是用 tuple 来表示的，即 #test{a = <<&#34;a&#34;>>, b = <<&#34;b&#34;>>} 实际上是 {test, <<&#34;a&#34;>>, <<&#34;b&#34;>>} 所有在运行时对 record 的操作实际上都是对 tuple 的操作 Result#test.a 实际上是 tuple 的 index 可以使用 record_info(fields, record) 获取 Record 的 fields 信息 所以我们可以这样"><meta name=author content="caoyue"><title>且听疯吟 / About Erlang: Records</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>About Erlang: Records</div><div class=content><h4 id=1-tuple-and-record>1. tuple and record</h4><p>现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>-</span><span class=ni>record</span><span class=p>(</span><span class=nl>test</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nn>a</span><span class=p>::</span><span class=nf>binary</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=nn>b</span><span class=p>::</span><span class=nf>binary</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>KeyValuePairs</span> <span class=o>=</span> <span class=p>[{</span><span class=n>a</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;a&#34;</span><span class=o>&gt;&gt;</span><span class=p>},{</span><span class=n>b</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;b&#34;</span><span class=o>&gt;&gt;</span><span class=p>}].</span>
</span></span></code></pre></div><p>很基础的问题，我们这样做：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>Result</span> <span class=o>=</span> <span class=nl>#test</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}.</span>
</span></span></code></pre></div><p>如果 record 有一百个项呢？<br>重复的写 <code>a = get_value(a, KeyValuePairs)</code> 这样的代码一百次大概会让人怀疑「猿」生吧 :(</p><p>虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道</p><ul><li><strong>Erlang 的 record 实际上是用 tuple 来表示的</strong>，即 <code>#test{a = &lt;&lt;"a">>, b = &lt;&lt;"b">>}</code> 实际上是 <code>{test, &lt;&lt;"a">>, &lt;&lt;"b">>}</code></li><li><strong>所有在运行时对 record 的操作实际上都是对 tuple 的操作</strong></li><li><code>Result#test.a</code> 实际上是 tuple 的 index</li><li>可以使用 <code>record_info(fields, record)</code> 获取 Record 的 fields 信息</li></ul><p>所以我们可以这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>Result</span> <span class=o>=</span> <span class=nb>list_to_tuple</span><span class=p>([</span><span class=n>test</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>get_value</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=n>test</span><span class=p>)]]).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>Result</span><span class=nl>#test.a</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=c>%% &lt;&lt;&#34;a&#34;&gt;&gt;
</span></span></span></code></pre></div><h4 id=2-record_info>2. record_info</h4><p>很容易想到，我们要是把处理函数抽象出来，不是多了一个 <code>kvpairs_to_record</code> 的接口了么？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>-</span><span class=ni>spec</span> <span class=n>kvpairs_to_record</span><span class=p>(</span><span class=n>kvpairs</span><span class=p>(),</span> <span class=n>atom</span><span class=p>())</span> <span class=o>-&gt;</span> <span class=n>rec</span><span class=p>().</span>
</span></span><span class=line><span class=cl><span class=nf>kvpairs_to_record</span><span class=p>(</span><span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=nv>Record</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>	<span class=nb>list_to_tuple</span><span class=p>([</span><span class=nv>Record</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=n>get_value</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=nv>Record</span><span class=p>)]]).</span>
</span></span></code></pre></div><p>很遗憾，行不通。编译的时候会报出 <code>illegal record info</code> 错误。</p><p>WTF?</p><ul><li><code>record_info</code> 并不是一个通常意义上的 BIF，它不能接受变量</li><li>其原因在于 record structure 只存在于编译期，<strong>在运行时是不可见的</strong>，编译完成后，record 就已经被表示成为 tuple 了，自然没有办法在运行时再获取 record info 了</li></ul><p>所以你只能这么「曲线救国」了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>kvpairs_to_record</span><span class=p>(</span><span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=nv>Record</span><span class=p>,</span> <span class=nv>RecordInfo</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>	<span class=nb>list_to_tuple</span><span class=p>([</span><span class=nv>Record</span> <span class=p>|</span> <span class=p>[</span><span class=n>get_value</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=nv>RecordInfo</span><span class=p>]]).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>Result</span> <span class=o>=</span> <span class=n>kvpairs_to_record</span><span class=p>(</span><span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=n>test</span><span class=p>,</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=n>test</span><span class=p>)).</span>
</span></span></code></pre></div><h4 id=3-macro-and-record>3. macro and record</h4><p>所以就这样放弃了？<br>当然不，为了「代码洁癖」我们可以「不择手段」。<br>考虑到 define macro 也是编译期的，我们可以这样 trick</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>-</span><span class=ni>module</span><span class=p>(</span><span class=n>test</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=p>-</span><span class=ni>export</span><span class=p>([</span><span class=n>do</span><span class=o>/</span><span class=mi>0</span><span class=p>]).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span><span class=ni>define</span><span class=p>(</span><span class=no>fuxk</span><span class=p>(</span><span class=nv>Record</span><span class=p>,</span> <span class=nv>Val</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nb>list_to_tuple</span><span class=p>([</span><span class=nv>Record</span> <span class=p>|</span> <span class=p>[</span><span class=nb>get</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=nv>Record</span><span class=p>)]])</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=p>).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span><span class=ni>record</span><span class=p>(</span><span class=nl>test</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=p>::</span> <span class=n>binary</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=p>::</span> <span class=n>binary</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>do</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>KV</span> <span class=o>=</span> <span class=p>[{</span><span class=n>a</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;a&#34;</span><span class=o>&gt;&gt;</span><span class=p>},{</span><span class=n>b</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;b&#34;</span><span class=o>&gt;&gt;</span><span class=p>}],</span>
</span></span><span class=line><span class=cl>    <span class=nv>Result</span> <span class=o>=</span> <span class=o>?</span><span class=n>fuxk</span><span class=p>(</span><span class=n>test</span><span class=p>,</span> <span class=nv>KV</span><span class=p>)(),</span>
</span></span><span class=line><span class=cl>    <span class=nv>Result</span><span class=nl>#test.a</span><span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=c>% &lt;&lt;&#34;a&#34;&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nb>get</span><span class=p>(</span><span class=nv>Key</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nn>proplists</span><span class=p>:</span><span class=nf>get_value</span><span class=p>(</span><span class=nv>Key</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=n>undefined</span><span class=p>).</span>
</span></span></code></pre></div><p>Goodness gracious - it works!</p><h4 id=4-beam-and-record>4. beam and record</h4><p>当然像上面那样写实际上也没有好多少，依然还是不完美。<br>如果一定需要在运行时得到 record info 呢？<br>比如我们热升级代码，需要更新 record 定义怎么办？</p><p>幸好，record structure 会被写入到 beam 中，我们只需要 load beam 然后解析它，还是可以达到运行时获取 record info 的效果的。<br>具体实现可以参考 <a href=https://github.com/esl/parse_trans>https://github.com/esl/parse_trans</a></p><p>当然，除非知道自己在做什么，否则<strong>不推荐</strong>这么做。</p><h4 id=5-最后>5. 最后</h4><p>实际上我很好奇为什么 Erlang 不提供运行时访问 record structure 呢？信息已经存在于 beam 中了，实现一下不难吧。<br>最后，如果不需要考虑兼容，<strong>推荐使用 <code>map</code> 来替代 <code>record</code></strong>，<code>map</code> 在运行时数据结构可见并且可以增删成员。</p></div><div class=tags><ul class=info><li>2015-05-27</li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>