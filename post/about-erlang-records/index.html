<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#a6d6d6"/><meta name="msapplication-TileColor" content="#a6d6d6"/><meta name="msapplication-TileImage" content="/icon/favicon.ico"/><meta name="referrer" content="no-referrer"/><title>且听疯吟 / About Erlang: Records</title><link rel="alternate" type="application/rss+xml" title="atom 1.0" href="/atom.xml"/><link rel="apple-touch-icon" sizes="192x192" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="48x48" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="192x192" href="/icon/favicon.ico"/><link rel="stylesheet" href="/css/normalize.css"/><link rel="stylesheet" href="/css/style.css"/><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><div class="header"><a href="/" title="this is a link">且听疯吟</a><span>如此生活三十年</span></div><div class="left"><ul class="list"><li><a href="/" title="Home">Home</a></li><li><a href="/archives" title="archive">Archive</a></li><li><a href="/tags" title="Tags">Tags</a></li></ul></div><div class="right"><div class="entry" id="content"><div class="title">About Erlang: Records</div><div class="content"><h4 id="1-tuple-and-record"><a href="#1-tuple-and-record" class="headerlink" title="1. tuple and record"></a>1. tuple and record</h4><p>现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(test, &#123;</span></span><br><span class="line"><span class="params">    a::binary(),</span></span><br><span class="line"><span class="params">    b::binary()</span></span><br><span class="line"><span class="params">&#125;)</span>.</span><br><span class="line"></span><br><span class="line">KeyValuePairs = [&#123;a, &lt;&lt;<span class="string">&quot;a&quot;</span>&gt;&gt;&#125;,&#123;b, &lt;&lt;<span class="string">&quot;b&quot;</span>&gt;&gt;&#125;].</span><br></pre></td></tr></table></figure>

<p>很基础的问题，我们这样做：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Result = #test&#123;</span><br><span class="line">    a = get_value(a, KeyValuePairs),</span><br><span class="line">    b = get_value(a, KeyValuePairs)</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure>

<p>如果 record 有一百个项呢？<br>重复的写 <code>a = get_value(a, KeyValuePairs)</code> 这样的代码一百次大概会让人怀疑「猿」生吧 :(</p>
<p>虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道</p>
<ul>
<li><strong>Erlang 的 record 实际上是用 tuple 来表示的</strong>，即 <code>#test&#123;a = &lt;&lt;&quot;a&quot;&gt;&gt;, b = &lt;&lt;&quot;b&quot;&gt;&gt;&#125;</code> 实际上是 <code>&#123;test, &lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;&#125;</code></li>
<li><strong>所有在运行时对 record 的操作实际上都是对 tuple 的操作</strong></li>
<li><code>Result#test.a</code> 实际上是 tuple 的 index</li>
<li>可以使用 <code>record_info(fields, record)</code> 获取 Record 的 fields 信息</li>
</ul>
<p>所以我们可以这样</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Result = list_to_tuple([test |</span><br><span class="line">    [get_value(X, KeyValuePairs) || X &lt;- record_info(fields, test)]]).</span><br><span class="line"></span><br><span class="line">Result#test.a.</span><br><span class="line"><span class="comment">%% &lt;&lt;&quot;a&quot;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-record-info"><a href="#2-record-info" class="headerlink" title="2. record_info"></a>2. record_info</h4><p>很容易想到，我们要是把处理函数抽象出来，不是多了一个 <code>kvpairs_to_record</code> 的接口了么？</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span> kvpairs_to_record<span class="params">(kvpairs(), atom())</span> -&gt; rec<span class="params">()</span>.</span><br><span class="line"><span class="function"><span class="title">kvpairs_to_record</span><span class="params">(KeyValuePairs, Record)</span> -&gt;</span></span><br><span class="line">	list_to_tuple([Record |</span><br><span class="line">        [get_value(X, KeyValuePairs) || X &lt;- record_info(fields, Record)]]).</span><br></pre></td></tr></table></figure>

<p>很遗憾，行不通。编译的时候会报出 <code>illegal record info</code> 错误。</p>
<p>WTF?</p>
<ul>
<li><code>record_info</code> 并不是一个通常意义上的 BIF，它不能接受变量</li>
<li>其原因在于 record structure 只存在于编译期，<strong>在运行时是不可见的</strong>，编译完成后，record 就已经被表示成为 tuple 了，自然没有办法在运行时再获取 record info 了</li>
</ul>
<p>所以你只能这么「曲线救国」了</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">kvpairs_to_record</span><span class="params">(KeyValuePairs, Record, RecordInfo)</span> -&gt;</span></span><br><span class="line">	list_to_tuple([Record | [get_value(X, KeyValuePairs) || X &lt;- RecordInfo]]).</span><br><span class="line"></span><br><span class="line">Result = kvpairs_to_record(KeyValuePairs, test, record_info(fields, test)).</span><br></pre></td></tr></table></figure>

<h4 id="3-macro-and-record"><a href="#3-macro-and-record" class="headerlink" title="3. macro and record"></a>3. macro and record</h4><p>所以就这样放弃了？<br>当然不，为了「代码洁癖」我们可以「不择手段」。<br>考虑到 define macro 也是编译期的，我们可以这样 trick</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(test)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([do/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-define</span><span class="params">(fuxk(Record, Val),</span></span><br><span class="line"><span class="params">    <span class="keyword">fun</span>() -&gt;</span></span><br><span class="line"><span class="params">        list_to_tuple([Record | [get(X, Val)</span></span><br><span class="line"><span class="params">            || X &lt;- record_info(fields, Record)]])</span></span><br><span class="line"><span class="params">    <span class="keyword">end</span></span></span><br><span class="line"><span class="params">)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-record</span><span class="params">(test, &#123;</span></span><br><span class="line"><span class="params">    a :: binary(),</span></span><br><span class="line"><span class="params">    b :: binary()</span></span><br><span class="line"><span class="params">&#125;)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">do</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    KV = [&#123;a, &lt;&lt;<span class="string">&quot;a&quot;</span>&gt;&gt;&#125;,&#123;b, &lt;&lt;<span class="string">&quot;b&quot;</span>&gt;&gt;&#125;],</span><br><span class="line">    Result = ?fuxk(test, KV)(),</span><br><span class="line">    Result#test.a.</span><br><span class="line">    <span class="comment">% &lt;&lt;&quot;a&quot;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(Key, KeyValuePairs)</span> -&gt;</span></span><br><span class="line">    proplists:get_value(Key, KeyValuePairs, undefined).</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Goodness gracious - it works!</p>
<h4 id="4-beam-and-record"><a href="#4-beam-and-record" class="headerlink" title="4. beam and record"></a>4. beam and record</h4><p>当然像上面那样写实际上也没有好多少，依然还是不完美。<br>如果一定需要在运行时得到 record info 呢？<br>比如我们热升级代码，需要更新 record 定义怎么办？</p>
<p>幸好，record structure 会被写入到 beam 中，我们只需要 load beam 然后解析它，还是可以达到运行时获取 record info 的效果的。<br>具体实现可以参考 <a target="_blank" rel="noopener" href="https://github.com/esl/parse_trans">https://github.com/esl/parse_trans</a></p>
<p>当然，除非知道自己在做什么，否则<strong>不推荐</strong>这么做。</p>
<h4 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h4><p>实际上我很好奇为什么 Erlang 不提供运行时访问 record structure 呢？信息已经存在于 beam 中了，实现一下不难吧。<br>最后，如果不需要考虑兼容，**推荐使用 <code>map</code> 来替代 <code>record</code>**，<code>map</code> 在运行时数据结构可见并且可以增删成员。</p>
</div><div><ul class="info"><li>posted on 2015-05-27<li><a href="/tags/programming/">#programming</a></li><li><a href="/tags/erlang/">#erlang</a></li></li></ul></div></div><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = "https://blog.caoyue.me/post/about-erlang-records/";
    this.page.identifier = "post/about-erlang-records/";
};

(function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://caoyue.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script></div><div class="footer"><div></div>©2021<a href="https://blog.caoyue.me"> 且听疯吟</a>. designed by<a href="https://caoyue.me" target="_blank"> caoyue</a>. powered by<a href="https://hexo.io/" target="_blank"> hexo</a></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
</div></body></html>