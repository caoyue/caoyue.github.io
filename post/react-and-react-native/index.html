<!doctype html><html lang=zh-Hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="最近了解了下 react 和 react native，感觉看到了一条成为「Full-stack Developer」的捷径啊（雾
React 消息同步
不管是 Web 还是 Native 应用，一个很麻烦的问题就是保持某个 Message 在不同 View 之间的状态同步。
比如，收到一条消息，需要在未读标签显示状态和数字，然后未读列表中插入一条消息记录。
阅读消息后，需要从未读中去掉这条记录，同时在已读中新增一条记录，还不能忘了将未读数字减去。
我们是怎么处理这种情况？
要在接收消息的 handler 中判断各个 View 当前的状态，然后根据对应的状态写不同的处理代码，阅读消息同理。当然高端点的可能自己搞个 Manager 之类的东西去对这些逻辑进行管理。
但是，并没有什么用。一旦业务复杂，处理和 Debug 起来就很麻烦了。看上去未读是 1，点进去发现是空，这种场景想必见得也不少了。
还记得很久之前我们怎么写页面的吗？（多久？大概到 ASP 吧=-= 那时候我们没有这么多烦恼。因为我们是这么干的。不管什么操作，ok，刷新页面，可以保证所有状态都是正确的，so easy!
React + Flux 所做的正和我们很久之前的做法有点像。数据更新了？重新渲染一遍 View 不就好了。
但是将整个 DOM 重新渲染一遍是开销很大的，当然不可能真的这么做。
所以就有了 Virtual DOM。
其实我们对 View 所做的操作大部分都是修改内容，比如修改某个块里面的文字啦，对某个 list 增删改啦。这些都不需要完全重绘。
React 做到了「智能」去更新 DOM，只改变需要改变的地方。（嗯，就是不相信你能写出高效正确的操作 DOM 的代码，所以我们都帮你写好啦~（雾
组件化
通常我们的页面上的控件都是带有不同的状态的，比如选框是否选中等等。而不同情况下状态可能会根据一些参数去变化，这让一般情况下的组件复用变得很麻烦。
而 React 可以做到类似于函数的给定输入参数，输出固定的状态，可以很方便的实现 Web Components，也不会出现组件状态上的冲突。
而组件化的开发带来的效率提升是非常高的。
其他
另外经常看到人说 HTML 嵌在 JS 里面感觉很奇怪是不是模板耦合在代码里面之类的，我倒是觉得这种写法挺简洁优雅的。如果把 JSX 里面的 XML 看作是一个 XML 表示的 Object，这样理解可能会好点吧。当然你也可以使用纯 JS 的方式去写。"><meta name=author content="caoyue"><title>且听疯吟 / react and react native</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>react and react native</div><div class=content><p>最近了解了下 react 和 react native，感觉看到了一条成为「Full-stack Developer」的捷径啊（雾</p><h3 id=react>React</h3><ul><li><p>消息同步<br>不管是 Web 还是 Native 应用，一个很麻烦的问题就是保持某个 Message 在不同 View 之间的状态同步。<br>比如，收到一条消息，需要在未读标签显示状态和数字，然后未读列表中插入一条消息记录。<br>阅读消息后，需要从未读中去掉这条记录，同时在已读中新增一条记录，还不能忘了将未读数字减去。<br>我们是怎么处理这种情况？<br>要在接收消息的 handler 中判断各个 View 当前的状态，然后根据对应的状态写不同的处理代码，阅读消息同理。当然高端点的可能自己搞个 Manager 之类的东西去对这些逻辑进行管理。<br>但是，并没有什么用。一旦业务复杂，处理和 Debug 起来就很麻烦了。看上去未读是 1，点进去发现是空，这种场景想必见得也不少了。</p><pre><code>还记得很久之前我们怎么写页面的吗？（多久？大概到 ASP 吧=-=
</code></pre><p>那时候我们没有这么多烦恼。因为我们是这么干的。不管什么操作，ok，刷新页面，可以保证所有状态都是正确的，so easy!<br>React + Flux 所做的正和我们很久之前的做法有点像。数据更新了？重新渲染一遍 View 不就好了。<br>但是将整个 DOM 重新渲染一遍是开销很大的，当然不可能真的这么做。<br>所以就有了 Virtual DOM。<br>其实我们对 View 所做的操作大部分都是修改内容，比如修改某个块里面的文字啦，对某个 list 增删改啦。这些都不需要完全重绘。<br>React 做到了「智能」去更新 DOM，只改变需要改变的地方。（嗯，就是不相信你能写出高效正确的操作 DOM 的代码，所以我们都帮你写好啦~（雾</p></li><li><p>组件化<br>通常我们的页面上的控件都是带有不同的状态的，比如选框是否选中等等。而不同情况下状态可能会根据一些参数去变化，这让一般情况下的组件复用变得很麻烦。<br>而 React 可以做到类似于函数的给定输入参数，输出固定的状态，可以很方便的实现 Web Components，也不会出现组件状态上的冲突。<br>而组件化的开发带来的效率提升是非常高的。</p></li><li><p>其他<br>另外经常看到人说 HTML 嵌在 JS 里面感觉很奇怪是不是模板耦合在代码里面之类的，我倒是觉得这种写法挺简洁优雅的。如果把 JSX 里面的 XML 看作是一个 XML 表示的 Object，这样理解可能会好点吧。当然你也可以使用纯 JS 的方式去写。</p></li></ul><p>好的东西往往是看上去简单实现复杂。<br>Java 本身虽然不怎么样，但是它可以让不同水平的人写出能够达到标准的代码，依然坚挺不是没有理由的。<br>所以我多少也有些认同 react 可以让不同水平的前端工程师写出符合效用的代码这个说法了。<br>算是一点并没有深入研究过前端的人的一点想法吧。</p><h3 id=react-native>React Native</h3><p>最近公司同时在做某个应用的 iOS 和 Android 版本，虽然没有参与开发，但是从两边的进程来看，大部分时间其实是把同一份逻辑翻译成 Objective-C 和 Java，但是这也是没办法的事情。<br>毕竟现有的 Hybrid App 方案表现都不太理想， Native 的优势暂时无法替代。如果可以借鉴 React 的优势和开发效率，同时带来 Native 的体验，excited！<br>所以 React Native 就顺理成章了。<br>难得的是 React 没有提「Write once, run anywhere」（JAVA：=-=）<br>而是 「<strong>Learn once, write anywhere</strong>」。</p><p>目前感觉除了基于 React 本身的那些优势外，React Native 在开发 App 方面也是很爽的</p><ul><li>效果<br>WebView 总是让我们感觉没有 Native 那么顺畅自然，大概是因为触摸反馈之类的原因吧。React Native 在这方面则没有这个问题，可以非常容易的用到 Native 的触摸和动画效果</li><li>flex 布局<br>熟悉 Web 那一套的话用起来还是很方便的。但是 React Native 的 flex 只是 Web 的 Lite 版，虽然尽力去做 Native 兼容，但是表现能力不如 Web 也不如 Native 是必然的，幸好移动端布局通常没有 Web 那么复杂。</li><li>组件化<br>React Native 提供了基本组件，通过自己组合，可以做出很多意想不到的效果。加上通过 npm 可以引入其他开源的组件，组合出一个 App 更加容易了。</li><li>效率<br>从安装 Xcode 到 写出一个新闻列表功能只花了两个小时，虽然之前完全没有接触过 iOS 开发。大公司项目这种提供详细文档和 starterkit 的作风真是太赞。</li><li>调试方便<br>即时刷新，用调试 Web 的方式调 App 真的很爽</li><li>集成到现有 App<br>可以将某个 React Native 实现的部分集成到现有 App 中，对已有的业务不产生影响</li></ul><p>缺点也有：</p><ul><li>平台<br>除了一些容易抽象的组件比如 ListView，View，Text 之外，目前很多组件是限于平台的。这点也是可以理解的，毕竟不同平台的 API 千差万别，很难做到通用。所以想要一次开发之后小小修改就可以通吃的可以醒醒了 =-=<br>这也导致实际上还是无法绕开去，必须要了解 Native 开发的一些组件和细节。比如在 iOS 中，首先你需要放一个 Tabbar，然后每个 Tabbar Item 里面放一个 Navigator，这和 Native 开发其实是差不多的模式。单纯从做 Web 过来的人，还是需要去学习这些东西才能开始。<br>但是比起完整使用 Native 开发，这个学习时间要短得多。</li><li>表现能力<br>虽然 React Native 的表现能力不如 Native ，但是它并不是为了取代 Native 开发存在的。在需要的领域做得足够好，这就够了。</li><li>第三方库<br>包括 React 和 React-Native 都有这个问题。事实上由于 Virtual DOM 和 React 革命性的架构方式，以往的第三方库很难做到直接可用了。而 React 的可用第三方库还不够多，当然社区还是挺活跃的，相信这个问题会好转。</li><li>成熟度<br>随着项目变大和引入的 package 变多，你会发现越来越多的莫名奇妙的出错和 bug，这个时候你需要耐心，放狗去搜。最容易找到解决方案的地方还是 Github 上的 issue list。有很多人会碰到同样的问题，也很可能会有人在下面给出解决的方法或是方向。当然，你也可以 subscribe 这个 issue，等待官方哪天大发慈悲解决掉它。</li><li>更新速度<br>更新太快有好处也有坏处。当你发现新版本解决了一个问题，迫不及待的想要更新的时候，可能发现：你的 App 挂了；第三方组件挂了；你必须升级一堆 package，并解决可能与之相关的问题。当然啦，大部分情况下还是没有那么蛋疼的。</li></ul><hr><p>虽然接触的时间不长，也有碰到一些小坑，但是目前看来，对我这种不会 Native 开发的人来说，React Native 是个非常不错的选择。<br>也许有时间会写写碰到过的坑和一些学习的建议之类的 :-)</p></div><div class=tags><ul class=info><li>2015-10-27</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li><a href=https://blog.caoyue.me/tags/react>#react</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>