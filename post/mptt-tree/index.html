<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#a6d6d6"/><meta name="msapplication-TileColor" content="#a6d6d6"/><meta name="msapplication-TileImage" content="/icon/favicon.ico"/><meta name="referrer" content="no-referrer"/><title>且听疯吟 / 预排序遍历算法树</title><link rel="alternate" type="application/rss+xml" title="atom 1.0" href="/atom.xml"/><link rel="apple-touch-icon" sizes="192x192" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="48x48" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="192x192" href="/icon/favicon.ico"/><link rel="stylesheet" href="/css/normalize.css"/><link rel="stylesheet" href="/css/style.css"/><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><div class="header"><a href="/" title="this is a link">且听疯吟</a><span>如此生活三十年</span></div><div class="left"><ul class="list"><li><a href="/" title="Home">Home</a></li><li><a href="/archives" title="archive">Archive</a></li><li><a href="/tags" title="Tags">Tags</a></li></ul></div><div class="right"><div class="entry" id="content"><div class="title">预排序遍历算法树</div><div class="content"><p><img src="http://ww2.sinaimg.cn/large/3e69b0ccgw1et1gl2lw6wj20o20d30ti.jpg" alt="mptt"></p>
<h4 id="1-预排序遍历树算法"><a href="#1-预排序遍历树算法" class="headerlink" title="1. 预排序遍历树算法"></a>1. 预排序遍历树算法</h4><ul>
<li>mptt (Modified Preorder Tree Traversal)[^1]</li>
<li>优点<br>查询效率高，只需要一次查询即可获得层级结构中某个节点的所有子节点，无需递归查询</li>
<li>缺点<br>插入、删除、移动节点效率较低</li>
<li>适用<br>在传统关系数据库中实现层级树结构<ul>
<li>读压力 &gt; 写压力， mptt 算法可以提高效率</li>
<li>写压力 &gt; 读压力，使用传统的邻接表 (adjacency list model)</li>
</ul>
</li>
</ul>
<h4 id="2-增删查改"><a href="#2-增删查改" class="headerlink" title="2. 增删查改"></a>2. 增删查改</h4><ul>
<li><p>Create</p>
<ul>
<li>假设增加的节点为 <code>c</code>, 该节点前一节点为 <code>p</code></li>
<li>节点 <code>c</code> 左值为 <code>p</code> 的右值 <code>+1</code>，右值为 <code>p</code> 右值 <code>+2</code></li>
<li>所有左值大于节点 <code>c</code> 的左值的节点，其左值均 <code>+2</code></li>
<li>所有右值大于节点 <code>c</code> 的右值的节点，其右值均 <code>+2</code></li>
<li>写入节点 <code>c</code> 到数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@cRight</span> :<span class="operator">=</span> rgt <span class="keyword">FROM</span> mptt	<span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">UPDATE mptt <span class="keyword">SET</span> rgt <span class="operator">=</span> rgt <span class="operator">+</span> <span class="number">2</span> <span class="keyword">WHERE</span> rgt <span class="operator">&gt;</span> <span class="variable">@cRight</span> ;</span><br><span class="line">UPDATE mptt <span class="keyword">SET</span> lft <span class="operator">=</span> lft <span class="operator">+</span> <span class="number">2</span> <span class="keyword">WHERE</span> lft <span class="operator">&gt;</span> <span class="variable">@cRight</span> ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mptt(name, lft, rgt) <span class="keyword">VALUES</span>(<span class="string">&#x27;c&#x27;</span>, <span class="variable">@cRight</span><span class="operator">+</span> <span class="number">1</span>, <span class="variable">@cRight</span><span class="operator">+</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Read</p>
<ul>
<li><p>查询节点 <code>c</code> 的子节点：</p>
<ul>
<li><p>查询所有左值大于 <code>c</code> 的左值且右值小于 <code>c</code> 的右值的节点</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mptt <span class="keyword">WHERE</span> lft <span class="keyword">BETWEEN</span> <span class="variable">@cLeft</span> <span class="keyword">and</span> <span class="variable">@cRight</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>查询节点 <code>c</code> 的父节点：</p>
<ul>
<li><p>查询所有左值小于 <code>c</code> 的左值且右值大于 <code>c</code> 的右值(或左值)的节点</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mptt <span class="keyword">WHERE</span> lft <span class="operator">&lt;</span> <span class="variable">@cLeft</span> <span class="keyword">and</span> rgt <span class="operator">&gt;</span> <span class="variable">@cLeft</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>节点 <code>c</code> 的子节点个数：</p>
<ul>
<li><code>(c.right - c.left - 1) / 2</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Update<br>移动节点即：</p>
<ul>
<li>删除节点</li>
<li>在指定位置新增节点</li>
</ul>
</li>
<li><p>Delete</p>
<ul>
<li>删除节点 <code>c</code></li>
<li>所有右值大于 <code>c</code> 右值的节点，右值 <code>-2</code></li>
<li>所有左值大于 <code>c</code> 左值的节点，左值 <code>-2</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mptty <span class="keyword">WHERE</span> lft <span class="keyword">BETWEEN</span> <span class="variable">@cLeft</span> <span class="keyword">AND</span> <span class="variable">@cRight</span>;</span><br><span class="line">UPDATE mptt <span class="keyword">SET</span> rgt <span class="operator">=</span> rgt <span class="operator">-</span> <span class="number">2</span> <span class="keyword">WHERE</span> rgt <span class="operator">&gt;</span> <span class="variable">@cRight</span>;</span><br><span class="line">UPDATE mptt <span class="keyword">SET</span> lft <span class="operator">=</span> lft <span class="operator">-</span> <span class="number">2</span> <span class="keyword">WHERE</span> lft <span class="operator">&gt;</span> <span class="variable">@cLeft</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-重建树结构"><a href="#3-重建树结构" class="headerlink" title="3. 重建树结构"></a>3. 重建树结构</h4><p>很容易推断，对排序好的 mptt tree，仅需要一次遍历，即可根据所有节点的左右值记录重建树结构<br>以 python 为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Node class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Node, self).__init__()</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.depth = <span class="number">1</span></span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line"> <span class="comment"># arg: Node List</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">rebuild</span>(<span class="params">l</span>):</span></span><br><span class="line">		<span class="comment"># 节点按左值排序，即遍历顺序</span></span><br><span class="line">        l.sort(key=<span class="keyword">lambda</span> x: x.left)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 使用列表暂存每层子树的父节点</span></span><br><span class="line">        <span class="comment"># 如 pi[0] 表示第 2 层的节点的父节点在 l 中的 index</span></span><br><span class="line">        pi = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">            <span class="keyword">if</span> c.left != <span class="number">1</span>:</span><br><span class="line">                p = l[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 使用 c 表示此节点，p 表示 c 的前一节点</span></span><br><span class="line">                <span class="comment"># 如果连续的两个节点 c 和 p 的左值增加幅度为 1，则说明其深度增加了 1</span></span><br><span class="line">                <span class="comment"># 且 p 为 c 及 c 的兄弟节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> c.left == p.left + <span class="number">1</span>:</span><br><span class="line">                    c.depth = p.depth + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> c.depth - <span class="number">1</span> &gt; <span class="built_in">len</span>(pi):</span><br><span class="line">                        pi.append(i - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pi[c.depth - <span class="number">2</span>] = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 c 的左值大于 p 的父节点的右值，则说明 p 与 c 并非兄弟节点</span></span><br><span class="line">                <span class="comment"># 并可以计算出两节点的深度差为 c 的左值与 p 的右值之差减 1</span></span><br><span class="line">                <span class="keyword">elif</span> c.left &gt; l[pi[p.depth - <span class="number">2</span>]].right:</span><br><span class="line">                    c.depth = p.depth - (c.left - p.right - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 不满足以上两个条件，说明 c 是 p 的兄弟节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c.depth = p.depth</span><br><span class="line"></span><br><span class="line">			    <span class="comment"># 将 c 作为 pi 中记录的父节点的子节点</span></span><br><span class="line">                l[pi[c.depth - <span class="number">2</span>]].children.append(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><p>完整代码及生成 Json 和基于 D3.js[^2] 的树状图：<br><a target="_blank" rel="noopener" href="https://gist.github.com/caoyue/704e472215af29b08a27">https://gist.github.com/caoyue/704e472215af29b08a27</a></p>
<p>[^1]: [1] <a target="_blank" rel="noopener" href="http://www.sitepoint.com/hierarchical-data-database-2">http://www.sitepoint.com/hierarchical-data-database-2</a><br>[^2]: [2] <a target="_blank" rel="noopener" href="http://d3js.org/">http://d3js.org</a></p>
</div><div><ul class="info"><li>posted on 2015-05-11<li><a href="/tags/programming/">#programming</a></li></li></ul></div></div><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = "https://blog.caoyue.me/post/mptt-tree/";
    this.page.identifier = "post/mptt-tree/";
};

(function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://caoyue.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script></div><div class="footer"><div></div>©2021<a href="https://blog.caoyue.me"> 且听疯吟</a>. designed by<a href="https://caoyue.me" target="_blank"> caoyue</a>. powered by<a href="https://hexo.io/" target="_blank"> hexo</a></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
</div></body></html>