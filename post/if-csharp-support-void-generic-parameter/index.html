<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#a6d6d6"/><meta name="msapplication-TileColor" content="#a6d6d6"/><meta name="msapplication-TileImage" content="/icon/favicon.ico"/><meta name="referrer" content="no-referrer"/><title>且听疯吟 / 如果 C# 支持 void 作为泛型参数</title><link rel="alternate" type="application/rss+xml" title="atom 1.0" href="/atom.xml"/><link rel="apple-touch-icon" sizes="192x192" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="48x48" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="192x192" href="/icon/favicon.ico"/><link rel="stylesheet" href="/css/normalize.css"/><link rel="stylesheet" href="/css/style.css"/><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><div class="header"><a href="/" title="this is a link">且听疯吟</a><span>如此生活三十年</span></div><div class="left"><ul class="list"><li><a href="/" title="Home">Home</a></li><li><a href="/archives" title="archive">Archive</a></li><li><a href="/tags" title="Tags">Tags</a></li></ul></div><div class="right"><div class="entry" id="content"><div class="title">如果 C# 支持 void 作为泛型参数</div><div class="content"><h4 id="有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的"><a href="#有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的" class="headerlink" title="有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的"></a>有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的</h4><p>比如，最近碰到一个问题，简化形式是这样的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">Range</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        <span class="comment">// DoSomething1...</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Range(n).ForEach(x =&gt; DoSomething2(x));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="看出问题了么？"><a href="#看出问题了么？" class="headerlink" title="看出问题了么？"></a>看出问题了么？</h4><ul>
<li><p><code>IEnumerable</code> 接口是没有 <code>ForEach</code> 方法的，<code>ForEach</code> 是 <code>List&lt;T&gt;</code> 的方法，所以只能写成</p>
<pre><code><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumerable.Range(<span class="number">0</span>, n).ToList().ForEach(x =&gt; DoSomething(x));</span><br></pre></td></tr></table></figure>
</code></pre>
<p>但是显然这样就失去了延迟执行的意义了</p>
</li>
<li><p>我们也可以尝试使用 <code>IEnumerable</code> 的 <code>Select</code> 方法，变成这样：</p>
<pre><code><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumerable.Range(<span class="number">0</span>, n).Select(x =&gt; DoSomething2(x));</span><br></pre></td></tr></table></figure>
</code></pre>
<p>当然这样也行不通，因为我们的 <code>DoSomething2</code> 方法是 <code>void</code> 类型的</p>
</li>
<li><p>最后只能粗暴的给 <code>DoSomething2</code> 包装一个返回值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumerable.Range(<span class="number">0</span>, n).Select(x =&gt; &#123; DoSomething2(x); <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="如果-IEnumerable-支持-ForEach-方法就好了？"><a href="#如果-IEnumerable-支持-ForEach-方法就好了？" class="headerlink" title="如果 IEnumerable 支持 ForEach 方法就好了？"></a>如果 <code>IEnumerable</code> 支持 <code>ForEach</code> 方法就好了？</h4><ul>
<li>事实上 C# 设计者对此作了解释：<a target="_blank" rel="noopener" href="http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx">“foreach” vs “ForEach”</a></li>
<li>总之来说，<code>List&lt;T&gt;.ForEach</code> 是 <code>List&lt;T&gt;</code> 本身的方法， Linq 不会提供有副作用的方法，它违反了 Linq <code>side-effect-free</code> 的设计理念</li>
<li>Mmm，听起来好像很有道理 :(</li>
</ul>
<p>当然，这个例子本身不具有太大的意义，但是——</p>
<h4 id="不妨开个脑洞"><a href="#不妨开个脑洞" class="headerlink" title="不妨开个脑洞"></a>不妨开个脑洞</h4><p>如果可以用 <code>void</code> 作为泛型参数呢？</p>
<ul>
<li><p>这样的代码不再有问题了</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumerable.Range(<span class="number">0</span>, n).Select&lt;<span class="built_in">int</span>, <span class="keyword">void</span>&gt;(x =&gt; DoSomething2(x));</span><br></pre></td></tr></table></figure>
</li>
<li><p>也并没有违反 Linq 的设计理念（当然，取决于你怎么看了 :(</p>
</li>
<li><p>更大的好处在于：<br>如果把 <code>void</code> 看作泛型的一种，可以在不增加复杂度的前提下简化一些问题<br>比如<strong>不需要为 <code>MyClass</code> 和 <code>MyClass&lt;T&gt;</code> 写两次相同的代码了</strong><br>因为 <code>MyClass</code> 就相当于 <code>MyClass&lt;void&gt;</code>，我们可以统一所有处理逻辑，不再需要大堆的重载了。</p>
</li>
</ul>
<hr>
<p>搜索的时候发现有很多大牛讨论过这个问题了，受益匪浅<br>比如 <a target="_blank" rel="noopener" href="http://blog.zhaojie.me/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html">C#的设计缺陷（2）：不能以 void 作为泛型参数</a></p>
</div><div><ul class="info"><li>posted on 2015-06-26<li><a href="/tags/csharp/">#csharp</a></li><li><a href="/tags/programming/">#programming</a></li></li></ul></div></div><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = "https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/";
    this.page.identifier = "post/if-csharp-support-void-generic-parameter/";
};

(function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://caoyue.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script></div><div class="footer"><div></div>©2021<a href="https://blog.caoyue.me"> 且听疯吟</a>. designed by<a href="https://caoyue.me" target="_blank"> caoyue</a>. powered by<a href="https://hexo.io/" target="_blank"> hexo</a></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
</div></body></html>