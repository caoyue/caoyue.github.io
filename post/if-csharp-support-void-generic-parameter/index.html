<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的 比如，最近碰到一个问题，简化形式是这样的：
IEnumerable<int> Range(int n) { var i = 0; while (i <= n) { // DoSomething1... yield return i; i++; } } Range(n).ForEach(x => DoSomething2(x)); void DoSomething2(x) { } 看出问题了么？ IEnumerable 接口是没有 ForEach 方法的，ForEach 是 List<T> 的方法，所以只能写成
```csharp Enumerable.Range(0, n).ToList().ForEach(x => DoSomething(x)); ``` 但是显然这样就失去了延迟执行的意义了
我们也可以尝试使用 IEnumerable 的 Select 方法，变成这样：
```csharp Enumerable.Range(0, n).Select(x => DoSomething2(x)); ``` 当然这样也行不通，因为我们的 DoSomething2 方法是 void 类型的
最后只能粗暴的给 DoSomething2 包装一个返回值
Enumerable.Range(0, n).Select(x => { DoSomething2(x); return true; }); 如果 IEnumerable 支持 ForEach 方法就好了？ 事实上 C# 设计者对此作了解释：“foreach” vs “ForEach” 总之来说，List<T>."><meta name=author content="caoyue"><title>且听疯吟 / 如果 C# 支持 void 作为泛型参数</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>如果 C# 支持 void 作为泛型参数</div><div class=content><h4 id=有些问题可能看起来无所谓但是开开脑洞还是挺有意思的>有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的</h4><p>比如，最近碰到一个问题，简化形式是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>Range</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=p>&lt;=</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// DoSomething1...</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Range</span><span class=p>(</span><span class=n>n</span><span class=p>).</span><span class=n>ForEach</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>void</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=看出问题了么>看出问题了么？</h4><ul><li><p><code>IEnumerable</code> 接口是没有 <code>ForEach</code> 方法的，<code>ForEach</code> 是 <code>List&lt;T></code> 的方法，所以只能写成</p><pre><code>```csharp
Enumerable.Range(0, n).ToList().ForEach(x =&gt; DoSomething(x));
```
</code></pre><p>但是显然这样就失去了延迟执行的意义了</p></li><li><p>我们也可以尝试使用 <code>IEnumerable</code> 的 <code>Select</code> 方法，变成这样：</p><pre><code>```csharp
Enumerable.Range(0, n).Select(x =&gt; DoSomething2(x));
```
</code></pre><p>当然这样也行不通，因为我们的 <code>DoSomething2</code> 方法是 <code>void</code> 类型的</p></li><li><p>最后只能粗暴的给 <code>DoSomething2</code> 包装一个返回值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Enumerable</span><span class=p>.</span><span class=n>Range</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>n</span><span class=p>).</span><span class=n>Select</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=k>return</span> <span class=k>true</span><span class=p>;</span> <span class=p>});</span>
</span></span></code></pre></div></li></ul><h4 id=如果-ienumerable-支持-foreach-方法就好了>如果 <code>IEnumerable</code> 支持 <code>ForEach</code> 方法就好了？</h4><ul><li>事实上 C# 设计者对此作了解释：<a href=http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx>“foreach” vs “ForEach”</a></li><li>总之来说，<code>List&lt;T>.ForEach</code> 是 <code>List&lt;T></code> 本身的方法， Linq 不会提供有副作用的方法，它违反了 Linq <code>side-effect-free</code> 的设计理念</li><li>Mmm，听起来好像很有道理 :(</li></ul><p>当然，这个例子本身不具有太大的意义，但是——</p><h4 id=不妨开个脑洞>不妨开个脑洞</h4><p>如果可以用 <code>void</code> 作为泛型参数呢？</p><ul><li><p>这样的代码不再有问题了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Enumerable</span><span class=p>.</span><span class=n>Range</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>n</span><span class=p>).</span><span class=n>Select</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=k>void</span><span class=p>&gt;(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
</span></span></code></pre></div></li><li><p>也并没有违反 Linq 的设计理念（当然，取决于你怎么看了 :(</p></li><li><p>更大的好处在于：<br>如果把 <code>void</code> 看作泛型的一种，可以在不增加复杂度的前提下简化一些问题<br>比如<strong>不需要为 <code>MyClass</code> 和 <code>MyClass&lt;T></code> 写两次相同的代码了</strong><br>因为 <code>MyClass</code> 就相当于 <code>MyClass&lt;void></code>，我们可以统一所有处理逻辑，不再需要大堆的重载了。</p></li></ul><hr><p>搜索的时候发现有很多大牛讨论过这个问题了，受益匪浅<br>比如 <a href=http://blog.zhaojie.me/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html>C#的设计缺陷（2）：不能以 void 作为泛型参数</a></p></div><div class=tags><ul class=info><li>2015-06-26</li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>