<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="断断续续学习和使用 Erlang 几个月了，感觉跟之前看待这门语言有了点变化，还是挺有意思的。
作为初学者可能理解不太准确，但有些东西还是可以记录一下。
关于函数式编程   刚开始从其他语言转移到函数式语言的时候还害怕所谓的思维转换，实际上担心有点多余
  入门并不难，能理解把循环写成尾递归的过程就基本没什么问题了
  更少的心智负担，不再需要考虑是传值还是传引用，以及糟糕的副作用
  在某些问题上更接近思维过程，不需要关心怎么做，只需要关心做什么
比如 erlang 的 quicksort 可以这么写（注意这并不是高效的写法）：
qsort([]) -> []; qsort([Pivot | T]) -> qsort([X || X <- T, X < Pivot]) ++ [H] ++ qsort([X || X <- T, X >= Pivot]).   关于 Erlang  语法简单  没有大量的复杂的概念，不像某些《Thinking in XXXX》，看完巨厚一本书你发现自己还是啥也不懂 没有大量的奇技淫巧 大概看了一个多月，就基本可以把 ejabberd 代码从头到尾过一遍了 多看多用，我自己入门看的 《Erlang Programing》   pattern match  用过才知道有多好用 据说效率极其惊人 据说 C# 也要加入了   并发  process  需要并发执行一个任务的时候，最容易想到的就是新开一个 process 去处理 Erlang 的 process 是轻量的，开启和关闭消耗也小，不需要操心各种并发问题   避免锁  实际上开始写命令式代码的时候，我倒是不怎么担心死锁，担心的反而是应该在哪里加锁…… Erlang 的并发模型没有试图去解决锁的问题，而是从根源避免了它，那就是根本不允许全局变量共享（当然你需要共享，可以使用 ETS 或者外部数据库） 对我而言，这种做法减轻了不少心智负担     鼓励崩溃和热更新  写代码的时候 Server 不用不停重启刷新的感觉太好   效率  入门快"><meta name=author content="caoyue"><title>且听疯吟 / 关于 Erlang 的一些想法</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>关于 Erlang 的一些想法</div><div class=content><p>断断续续学习和使用 Erlang 几个月了，感觉跟之前看待这门语言有了点变化，还是挺有意思的。<br>作为初学者可能理解不太准确，但有些东西还是可以记录一下。</p><h4 id=关于函数式编程>关于函数式编程</h4><ul><li><p>刚开始从其他语言转移到函数式语言的时候还害怕所谓的思维转换，实际上担心有点多余</p></li><li><p>入门并不难，能理解把循环写成尾递归的过程就基本没什么问题了</p></li><li><p>更少的心智负担，不再需要考虑是传值还是传引用，以及糟糕的副作用</p></li><li><p>在某些问题上更接近思维过程，不需要关心<strong>怎么做</strong>，只需要关心<strong>做什么</strong></p><p>比如 erlang 的 quicksort 可以这么写（注意这并不是高效的写法）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>qsort</span><span class=p>([])</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=nf>qsort</span><span class=p>([</span><span class=nv>Pivot</span> <span class=p>|</span> <span class=nv>T</span><span class=p>])</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>qsort</span><span class=p>([</span><span class=nv>X</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=nv>T</span><span class=p>,</span> <span class=nv>X</span> <span class=o>&lt;</span> <span class=nv>Pivot</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span> <span class=p>[</span><span class=nv>H</span><span class=p>]</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=n>qsort</span><span class=p>([</span><span class=nv>X</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=nv>T</span><span class=p>,</span> <span class=nv>X</span> <span class=o>&gt;=</span> <span class=nv>Pivot</span><span class=p>]).</span>
</span></span></code></pre></div></li></ul><h4 id=关于-erlang>关于 Erlang</h4><ul><li>语法简单<ul><li>没有大量的复杂的概念，不像某些《Thinking in XXXX》，看完巨厚一本书你发现自己还是啥也不懂</li><li>没有大量的奇技淫巧</li><li>大概看了一个多月，就基本可以把 ejabberd 代码从头到尾过一遍了</li><li>多看多用，我自己入门看的 《Erlang Programing》</li></ul></li><li>pattern match<ul><li>用过才知道有多好用</li><li>据说效率极其惊人</li><li>据说 C# 也要加入了</li></ul></li><li>并发<ul><li>process<br><ul><li>需要并发执行一个任务的时候，最容易想到的就是新开一个 process 去处理</li><li>Erlang 的 process 是轻量的，开启和关闭消耗也小，不需要操心各种并发问题</li></ul></li><li>避免锁<ul><li>实际上开始写命令式代码的时候，我倒是不怎么担心死锁，担心的反而是应该在哪里加锁……</li><li>Erlang 的并发模型没有试图去解决锁的问题，而是从根源避免了它，那就是根本不允许全局变量共享（当然你需要共享，可以使用 ETS 或者外部数据库）</li><li>对我而言，这种做法减轻了不少心智负担</li></ul></li></ul></li><li>鼓励崩溃和热更新<ul><li>写代码的时候 Server 不用不停重启刷新的感觉太好</li></ul></li><li>效率<ul><li>入门快<br><br>比如我这种不合格的程序猿看了一点《Erlang Programing》就开始写 ejabberd 的模块了</li><li>很容易用<br><br>比如我这样不合格的程序猿也可以很顺利的手写稳定的服务器了</li></ul></li><li>部分不怎么好的地方<ul><li>字符串的处理<br><ul><li>没有单独的字符串类型，而是用 List，从编码效率到处理效率，都不怎么好看</li><li>正则表达式的转义让人蛋疼无比</li></ul></li><li>unicode 字符<br><br>可能一不小心就容易坑了，当然这点在慢慢改进了</li><li>record<br><br>可能 OTP17 后的 map 会方便点</li><li>工具链<br><br>从 IDE 到 debug profile 到 compile，体验都比较……怎么说呢，原始吧。<br>目前用 Intellij IDEA + Erlang Plugin，还凑合。</li><li>出了问题搜索不到<br><br>嗯，这个时候就会嫌弃 Google 不够智能不能帮你写代码了</li></ul></li></ul></div><div class=tags><ul class=info><li>2015-03-16</li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",''),document.querySelector("section.article.discussion").innerHTML='',document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2022 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch(e){}</script></div></footer></div></body></html>