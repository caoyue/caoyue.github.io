<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="最近又从头看 XMPP 的 RFC1，有时候也考虑如果是自己来设计，会如何做。
之前的印象是 XMPP 的繁琐和低效，现在看来，作为通用的协议，XMPP 确实有做得不错的地方，从头看下来还是有不少收获的。
现在项目告一段落，回头整理下 XMPP 服务端安全方面的一些简单想法，大概想到哪写到哪吧，安全方面懂得不多，欢迎指正。
考虑到安全，我们的初始目标大概包括这些：
与服务端通信安全（不被窃听/篡改） 鉴别用户身份 保护用户数据 TLS TLS2 用于在两个通信应用程序之间提供保密性和数据完整性，是必须开启的。
SASL SASL3 是一种验证用户身份的框架。XMPP 本身没有办法分辨用户身份，必须借助于 SASL 协议。
SASL 协议确定了客户端和服务端沟通的应答机制及传输的编码方法，剩下的就需要自己实现了。
要识别用户身份，你需要在 SASL 的框架下定义和服务端交换的具体身份信息（比如用户名、密码），以及实现身份信息的存储和验证方式，而不需要考虑其他细节。
具体到 XMPP 下 SASL 的验证流程（如果建立了 TLS 连接，此时是在 TLS 连接上的）：
一般不必支持所有的 SASL mechanisms ，选择安全性更可靠的，比如 SCRAM-SHA-1 (尽量不要使用 plain)：
详细登录流程可以参考 ejabberd: Login
SCRAM-SHA-1 SCRAM4（Salted Challenge Response Authentication Mechanism） 是近年才开始使用的更安全的一种加密验证机制，可以很好的在 Server 和 Client 之间做双向的验证，已经有很多的服务开始使用这种方式验证了，比如 MongoDB。XMPP 也在协议中提供了这种方式的说明。
不讨论详细的加密算法细节，客户端验证登录时，大概流程如下：
client 发送想要登录的 username 到 server (即 auth) server 为该 username 生成/查找出 salt（s)，和 iteration count（i）、server nonce (r) 一并发回给 client （challenge，base64 编码） client 使用给定的 salt 和 iteration count 加密持有的 password，发回给 server （如果服务端对该 client 使用的 salt 和 iteration count 是固定的话，可以存储下生成的 client key，从而避免在 client 明文存储密码，会更安全） server 验证结果，如果成功则返回 success，并附上计算值 client 校验 success 中返回的值，通过则证明 server 拥有 client 的验证 end_to_end 如果有非常严格的安全需求，可以考虑 OpenPGP ，XMPP 协议也提供了有限的支持"><meta name=author content="caoyue"><title>且听疯吟 / XMPP 安全相关</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>XMPP 安全相关</div><div class=content><p>最近又从头看 XMPP 的 RFC<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，有时候也考虑如果是自己来设计，会如何做。<br>之前的印象是 XMPP 的繁琐和低效，现在看来，作为通用的协议，XMPP 确实有做得不错的地方，从头看下来还是有不少收获的。</p><p>现在项目告一段落，回头整理下 XMPP 服务端安全方面的一些简单想法，大概想到哪写到哪吧，安全方面懂得不多，欢迎指正。<br>考虑到安全，我们的初始目标大概包括这些：</p><ul><li>与服务端通信安全（不被窃听/篡改）</li><li>鉴别用户身份</li><li>保护用户数据</li></ul><h4 id=tls>TLS</h4><p>TLS<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 用于在两个通信应用程序之间提供保密性和数据完整性，是必须开启的。</p><h4 id=sasl>SASL</h4><p>SASL<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> 是一种验证用户身份的框架。XMPP 本身没有办法分辨用户身份，必须借助于 SASL 协议。<br>SASL 协议确定了客户端和服务端沟通的应答机制及传输的编码方法，剩下的就需要自己实现了。<br>要识别用户身份，你需要在 SASL 的框架下定义和服务端交换的具体身份信息（比如用户名、密码），以及实现身份信息的存储和验证方式，而不需要考虑其他细节。<br>具体到 XMPP 下 SASL 的验证流程（如果建立了 TLS 连接，此时是在 TLS 连接上的）：<br>一般不必支持所有的 SASL mechanisms ，选择安全性更可靠的，比如 <code>SCRAM-SHA-1</code> (尽量不要使用 plain)：</p><p>详细登录流程可以参考 <a href=http://blog.caoyue.me/post/ejabberd-login>ejabberd: Login</a></p><h4 id=scram-sha-1>SCRAM-SHA-1</h4><p><code>SCRAM</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>（Salted Challenge Response Authentication Mechanism） 是近年才开始使用的更安全的一种加密验证机制，可以很好的在 Server 和 Client 之间做双向的验证，已经有很多的服务开始使用这种方式验证了，比如 MongoDB。XMPP 也在协议中提供了这种方式的说明。<br>不讨论详细的加密算法细节，客户端验证登录时，大概流程如下：</p><ol><li>client 发送想要登录的 username 到 server (即 auth)</li><li>server 为该 username 生成/查找出 salt（s)，和 iteration count（i）、server nonce (r) 一并发回给 client （challenge，base64 编码）</li><li>client 使用给定的 salt 和 iteration count 加密持有的 password，发回给 server （如果服务端对该 client 使用的 salt 和 iteration count 是固定的话，可以存储下生成的 client key，从而避免在 client 明文存储密码，会更安全）</li><li>server 验证结果，如果成功则返回 success，并附上计算值</li><li>client 校验 success 中返回的值，通过则证明 server 拥有 client 的验证</li></ol><h4 id=end_to_end>end_to_end</h4><p>如果有非常严格的安全需求，可以考虑 OpenPGP ，XMPP 协议也提供了有限的支持<br>不过我个人觉得这种方法也不是那么完美：</p><ul><li>需要额外的交换 key 的渠道，而这些渠道不一定可信</li><li>杜绝不了伪造身份，你没法确定 id 对应的绑定的就一定是 key 的拥有者</li><li>信息冗长，加密的信息可能字节数会扩大到 10 倍甚至以上</li></ul><h4 id=文件服务>文件服务</h4><p>文件传输基本是现在 IM 客户端的基础功能了。<br>一般我们不会选择通过文本方式直接在消息中发送文件/图片，而是选择先上传到 HTTP 文件服务器，然后发送链接的形式。但是 HTTP 是无状态的，我们也不能每次在用户对资源操作的时候要求用户输入用户名密码。</p><p>首先考虑上传：</p><ul><li>上传通道泄露可能会带来滥用</li><li>AWS 可以使用 key 和 secret 校验上传请求</li><li>将 secret key 存放在客户端可能被逆向</li><li>XMPP 服务端可以看作可信的已鉴权服务</li></ul><p>所以可以考虑这样操作：</p><ul><li>已鉴权的客户端从 XMPP 服务端申请上传</li><li>文件服务器生成一个上传用的 token，生成方式可能是<br><code>token = hash(user + id + nonce + expire_stamp + secret)</code></li><li>XMPP 服务端从文件服务器获取生成的 token 并返回给客户端（假设 XMPP 服务端与文件服务器之间的通信是可信的，比如处于同一个内网。当然也可以 XMPP 服务端使用同样的 secret 和算法来计算 token 而不请求文件服务器）</li><li>客户端向文件服务器提交上传请求，并带上 <code>token, user, id, expire_stamp, nonce</code></li><li>文件服务器校验是否过期以及<br><code>hash(user + id + nonce + expire_stamp + secret) == token</code></li><li>校验通过，上传文件到 AWS S3 或其他存储服务，返回文件 id 给客户端</li></ul><p>然后是下载：<br>出于安全考虑，我们通常不会允许固定的 url 访问，而是通过增加验证和过期的方式来做一些限制。<br>一方面防止文件抓取，同时降低私密文件意外公开的风险，甚至可以通过更换 secret key，让公开的链接失效，强制客户端重新向服务端请求鉴权。<br>和上传文件类似：</p><ul><li>客户端提交请求的文件 id 给 XMPP 服务端-</li><li>XMPP 服务端用类似的方式生成一个 token 返回给客户端</li><li>客户端使用链接 + token 的形式访问文件资源</li><li>文件服务器校验 token, 以及是否过期等等，通过则返回资源</li></ul><p>当然现实情况可能用不到复杂的机制，也可以根据情况适当放松要求。<br>btw, 至少我抓包验证不止一个重量级的 App 使用的就是类似于 <code>http://xxxxx/uuid</code> 的永久文件地址= =。</p><h4 id=业务逻辑>业务逻辑</h4><p>即使在完善的安全机制下，也<strong>不要完全信任用户的输入</strong>！<br>不像网页上按按 F12 就可以拿到很多信息，可能移动设备给人一种难以 hack 的错觉，但是决定有没有人来搞的是值不值得，还有运气 :)</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>[1] <a href=http://xmpp.org/xmpp-protocols/internet-drafts/>http://xmpp.org/xmpp-protocols/internet-drafts/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>[2] <a href=https://en.wikipedia.org/wiki/Transport_Layer_Security>https://en.wikipedia.org/wiki/Transport_Layer_Security</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>[3] <a href=https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer>https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>[4] <a href=https://en.wikipedia.org/wiki/Salted_Challenge_Response_Authentication_Mechanism>https://en.wikipedia.org/wiki/Salted_Challenge_Response_Authentication_Mechanism</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=tags><ul class=info><li>2015-07-07</li><li><a href=https://blog.caoyue.me/tags/xmpp>#xmpp</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>