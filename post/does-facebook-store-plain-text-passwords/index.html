<!doctype html><html lang=zh-Hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="越来越多的网站开始更加关注安全问题了，比如，Facebook 会在你把密码从 abc123 改为 Abc123 的时候的时候提示你
Your new password is too similar to your current password. Please try another password.
很贴心是不是？但是，他们是怎么做到的？难道 Facebook 保存了用户的明文密码么？
编辑距离 计算两个字符串的相似性，或者说「编辑距离」很容易，我们有很多现成的算法和代码。
但是，显然 Facebook 不会傻到存储明文密码，存储的肯定是 hash(&#34;abc123&#34;)。
而字符串中的差别和 hash 结果并不是一一对应的。两个相近的字符串，其 hash 结果可能差别很大。
simhash 可能你听说过 simhash 算法。Google 就是使用这种算法来做网页查重的。
传统的 hash 算法如 md5，一般尽可能要求结果分布均匀，因此，原始字符串的微小变动也会导致 hash 结果出现很大差异。
而 simhash 是一种局部敏感的 hash 算法，选定位数，提取特征，然后对每一段特征值计算 hash，然后将每一段值处理到 simhash 结果，得到最后的 simhash 值。比较海明距离就可以大概知道两个文档的相似度了。
具体的算法懂得不多就不瞎说了……大概可以推测，对于长文档这种方法是有效的，但是对于短文本，如 password 来说，效果可能不会太好。
Facebook 的做法 事实上这个问题好奇的人也很多，Stack Exchange 上有一个回答 http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords，下面有一个自称接触过密码验证这部分代码的人肯定了这个猜测。
我觉得这种做法看起来还是挺合理的。
Facebook 用了一种看起来很「土」的方法，操作方法类似这样：
用户注册，密码 abc123，Facebook 保存了 `hash(&ldquo;abc123&rdquo;) 用户修改密码，提交新密码 Abc123 Facebook 拿到新密码，根据这个密码，生成一堆类似于 ABC123，abc123 这样相近的密码，使用同样的 hash 方法，去和 1 中的 hash 比对，一旦发现有相同的，那么可以判定新密码与旧密码是相似的。 很好的反向思维，不是去计算相似性，而是通过生成一堆相似密码来「暴力」尝试。"><meta name=author content="caoyue"><title>且听疯吟 / Does Facebook store plain-text passwords?</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>Does Facebook store plain-text passwords?</div><div class=content><p>越来越多的网站开始更加关注安全问题了，比如，Facebook 会在你把密码从 <code>abc123</code> 改为 <code>Abc123</code> 的时候的时候提示你</p><blockquote><p>Your new password is too similar to your current password. Please try another password.</p></blockquote><p>很贴心是不是？但是，他们是怎么做到的？难道 Facebook 保存了用户的明文密码么？</p><h4 id=编辑距离>编辑距离</h4><p>计算两个字符串的相似性，或者说「编辑距离」很容易，我们有很多现成的算法和代码。<br>但是，显然 Facebook 不会傻到存储明文密码，存储的肯定是 <code>hash("abc123")</code>。<br>而字符串中的差别和 hash 结果并不是一一对应的。两个相近的字符串，其 hash 结果可能差别很大。</p><h4 id=simhash>simhash</h4><p>可能你听说过 simhash 算法。Google 就是使用这种算法来做网页查重的。<br>传统的 hash 算法如 md5，一般尽可能要求结果分布均匀，因此，原始字符串的微小变动也会导致 hash 结果出现很大差异。<br>而 simhash 是一种局部敏感的 hash 算法，选定位数，提取特征，然后对每一段特征值计算 hash，然后将每一段值处理到 simhash 结果，得到最后的 simhash 值。比较海明距离就可以大概知道两个文档的相似度了。<br>具体的算法懂得不多就不瞎说了……大概可以推测，对于长文档这种方法是有效的，但是对于短文本，如 password 来说，效果可能不会太好。</p><h4 id=facebook-的做法>Facebook 的做法</h4><p>事实上这个问题好奇的人也很多，Stack Exchange 上有一个回答 <a href=http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords>http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords</a>，下面有一个自称接触过密码验证这部分代码的人肯定了这个猜测。<br>我觉得这种做法看起来还是挺合理的。</p><p>Facebook 用了一种看起来很「土」的方法，操作方法类似这样：</p><ol><li>用户注册，密码 <code>abc123</code>，Facebook 保存了 `hash(&ldquo;abc123&rdquo;)</li><li>用户修改密码，提交新密码 <code>Abc123</code></li><li>Facebook 拿到新密码，根据这个密码，生成一堆类似于 <code>ABC123</code>，<code>abc123</code> 这样相近的密码，使用同样的 hash 方法，去和 1 中的 hash 比对，一旦发现有相同的，那么可以判定新密码与旧密码是相似的。</li></ol><p>很好的反向思维，不是去计算相似性，而是通过生成一堆相似密码来「暴力」尝试。</p><h4 id=其他想法>其他想法</h4><p>事实上最初想到这个问题的时候，我考虑过这样的做法：</p><ol><li>用户修改密码操作时，提示输入原密码</li><li>server 临时记录用户的原密码</li><li>用户输入新密码，server 比对新旧密码</li><li>完成修改或过期后，销毁临时记录</li></ol><p>不过即使是临时记录依然可能存在风险，如果需要较高的安全性的话这种方法是不可取的。</p></div><div class=tags><ul class=info><li>2015-09-02</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>