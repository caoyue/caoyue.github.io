<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="4. 异常   抛出异常
 显式的 exit(Why)  终止当前 Process 如果当前 Process 未捕获这个异常，则系统会向所有 link 该 Process 的 Process 广播 {'EXIT', Pid, Why} 消息   显式的 throw(Why)  抛出供其调用者捕获的异常 最好是添加注释说明抛出的异常 如何处理由调用者选择，包括忽略   系统错误 erlang:error(Why)    try..catch 捕获异常
  try/catch 本身会消耗一点性能
  推荐的 try/catch 风格
%% 首先对 FuncOrExpressionSequence 求值 %% 如果没有产生异常则顺序进行 Patterm 匹配, 匹配成功后执行后面的表达式 %% 如果有异常抛出, 则顺序匹配 ExPattern(ExceptionType 是 throw、exit、error 中的一个, 默认为 throw) %% after 块中的代码用于清理工作,绝对会执行 %% after 可以省略 try FuncOrExpressionSequence of Pattern1 [when Guard1] ->Expressions1; Pattern2 [when Guard2] ->Expressions2; ."><meta name=author content="caoyue"><title>且听疯吟 / Erlang Programming 笔记 2</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry id=cotent><div class=title>Erlang Programming 笔记 2</div><div class=content><h3 id=4-异常>4. 异常</h3><ul><li><p>抛出异常</p><ul><li>显式的 <code>exit(Why)</code><ul><li>终止当前 Process</li><li>如果当前 Process 未捕获这个异常，则系统会向所有 link 该 Process 的 Process 广播 <code>{'EXIT', Pid, Why}</code> 消息</li></ul></li><li>显式的 <code>throw(Why)</code><ul><li>抛出供其调用者捕获的异常</li><li>最好是添加注释说明抛出的异常</li><li>如何处理由调用者选择，包括忽略</li></ul></li><li>系统错误 <code>erlang:error(Why)</code></li></ul></li><li><p><code>try..catch</code> 捕获异常</p><ul><li><p>try/catch 本身会消耗一点性能</p></li><li><p><a href=http://stackoverflow.com/questions/666111/how-do-i-elegantly-check-many-conditions-in-erlang/669075#669075>推荐的 try/catch 风格</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=c>%% 首先对 FuncOrExpressionSequence 求值
</span></span></span><span class=line><span class=cl><span class=c>%% 如果没有产生异常则顺序进行 Patterm 匹配, 匹配成功后执行后面的表达式
</span></span></span><span class=line><span class=cl><span class=c>%% 如果有异常抛出, 则顺序匹配 ExPattern(ExceptionType 是 throw、exit、error 中的一个, 默认为 throw)
</span></span></span><span class=line><span class=cl><span class=c>%% after 块中的代码用于清理工作,绝对会执行
</span></span></span><span class=line><span class=cl><span class=c>%% after 可以省略
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>try</span> <span class=nv>FuncOrExpressionSequence</span> <span class=k>of</span>
</span></span><span class=line><span class=cl>    <span class=nv>Pattern1</span> <span class=p>[</span><span class=k>when</span> <span class=nv>Guard1</span><span class=p>]</span> <span class=o>-&gt;</span><span class=nv>Expressions1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nv>Pattern2</span> <span class=p>[</span><span class=k>when</span> <span class=nv>Guard2</span><span class=p>]</span> <span class=o>-&gt;</span><span class=nv>Expressions2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>catch</span>
</span></span><span class=line><span class=cl>    <span class=nv>ExceptionType</span><span class=p>:</span> <span class=nv>ExPattern1</span> <span class=p>[</span><span class=k>when</span> <span class=nv>ExGuard1</span><span class=p>]</span> <span class=o>-&gt;</span><span class=nv>ExExpressions1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nv>ExceptionType</span><span class=p>:</span> <span class=nv>ExPattern2</span> <span class=p>[</span><span class=k>when</span> <span class=nv>ExGuard2</span><span class=p>]</span> <span class=o>-&gt;</span><span class=nv>ExExpressions2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>after</span>
</span></span><span class=line><span class=cl>    <span class=nv>AfterExpressions</span>
</span></span><span class=line><span class=cl><span class=k>end</span><span class=p>.</span>
</span></span></code></pre></div></li></ul></li><li><p>栈跟踪</p><ul><li><p>在触发异常的时候可以调用 <code>erlang:get_stacktrace/0</code> 来查看最近的栈跟踪信息，可以获得异常函数的调用路径（尾递归调用除外）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=k>try</span> <span class=n>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>catch</span>
</span></span><span class=line><span class=cl>	<span class=nn>error</span><span class=p>:</span> <span class=nv>X</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nv>X</span><span class=p>,</span> <span class=nn>erlang</span><span class=p>:</span><span class=nf>get_stacktrace</span><span class=p>()}</span>
</span></span><span class=line><span class=cl><span class=k>end</span><span class=p>.</span>
</span></span></code></pre></div></li></ul></li></ul><h3 id=5-顺序型编程进阶>5. 顺序型编程进阶</h3><ul><li><p>BIF (built-in function)</p><ul><li><p>binary</p><ul><li><p>相对于 List 活着 tuple , binary 更节省内存，输入输出更为高效</p></li><li><p><code>binary_to_term/term_to_binary</code> 可将任何的 binary 和 Erlang 值（List、atom、tuple 甚至 binary 等）转换成为 binary，但是这个 binary 是以所谓的 「外部数据格式」 存储的，类似于其他语言的序列化与反序列化）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>A</span> <span class=o>=</span> <span class=o>&lt;&lt;</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=o>&gt;&gt;</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=nv>B</span> <span class=o>=</span> <span class=nb>term_to_binary</span><span class=p>(</span><span class=nv>A</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=c>%% &lt;&lt;131,109,0,0,0,3,1,2,3&gt;&gt;
</span></span></span></code></pre></div></li><li><p>binary 中的数字，每一个都在 0~255 之间（因为每一个数字表示一个 byte，其值在 0000 0000 ~ 1111 1111 [0 ~ 2<sup>9</sup> -1] 之间）</p></li><li><p>GB2312 的汉字转成 UTF-8 时，绝大多数是 3 个字节</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>A</span> <span class=o>=</span> <span class=o>&lt;&lt;</span><span class=s>&#34;且听疯吟&#34;</span><span class=o>/</span><span class=n>utf8</span><span class=o>&gt;&gt;</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=c>%% &lt;&lt;228,184,148,229,144,172,231,150,175,229,144,159&gt;&gt;
</span></span></span></code></pre></div></li></ul></li><li><p>bit 语法</p><ul><li><p>封包与解包</p><ul><li><p>以 RGB 色彩为例：<br>创建一个 16 bit (2 byte)的内存块，存放一个 RGB 三元组，并为 Red 分配 5 bit，为 Green 分配 6 bit，为 Blue 分配 5 bit</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>Red</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=nv>Green</span> <span class=o>=</span> <span class=mi>60</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=nv>Blue</span> <span class=o>=</span> <span class=mi>29</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=nv>RGB</span> <span class=o>=</span> <span class=o>&lt;&lt;</span><span class=nv>Red</span><span class=p>:</span><span class=mi>5</span><span class=p>,</span> <span class=nv>Green</span><span class=p>:</span><span class=mi>6</span><span class=p>,</span> <span class=nv>Blue</span><span class=p>:</span><span class=mi>5</span><span class=o>&gt;&gt;</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=c>%% &lt;&lt;23, 157&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=o>&lt;&lt;</span><span class=nv>R1</span><span class=p>:</span><span class=mi>5</span><span class=p>,</span> <span class=nv>G1</span><span class=p>:</span><span class=mi>6</span><span class=p>,</span> <span class=nv>B1</span><span class=p>:</span><span class=mi>5</span><span class=o>&gt;&gt;</span> <span class=o>=</span> <span class=nv>RGB</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=nv>R1</span><span class=p>,</span> <span class=nv>G1</span><span class=p>,</span> <span class=nv>B1</span><span class=p>}.</span>
</span></span><span class=line><span class=cl><span class=c>%% {2, 60, 29}
</span></span></span></code></pre></div></li><li><p>注意取值范围。比如我们为 Blue 分配了 5 bit，但是为 Blue 赋值 61，转换成二进制为 111101，超过了 5 bit，则会发生截断，取低五位，即实际值为 29</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nb>integer_to_list</span><span class=p>(</span><span class=mi>61</span><span class=p>,</span><span class=mi>2</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=c>%% &#34;111101&#34;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>integer_to_list</span><span class=p>(</span><span class=mi>29</span><span class=p>,</span><span class=mi>2</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=c>%% &#34;11101&#34;
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=o>&lt;&lt;</span><span class=mi>2</span><span class=p>:</span><span class=mi>5</span><span class=p>,</span><span class=mi>60</span><span class=p>:</span><span class=mi>6</span><span class=p>,</span><span class=mi>61</span><span class=p>:</span><span class=mi>5</span><span class=o>&gt;&gt;</span> <span class=o>==</span> <span class=o>&lt;&lt;</span><span class=mi>2</span><span class=p>:</span><span class=mi>5</span><span class=p>,</span><span class=mi>60</span><span class=p>:</span><span class=mi>6</span><span class=p>,</span><span class=mi>29</span><span class=p>:</span><span class=mi>5</span><span class=o>&gt;&gt;</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=c>%% true
</span></span></span></code></pre></div></li></ul></li></ul><ul><li>bit 语法表达式<ul><li>形如 <code>&lt;&lt;E1, E2, E3, ... , En>></code></li><li>每一个元素都是二进制数据中的一个区块</li><li>元素的值表示有下面几种方式<ul><li><code>Value</code></li><li><code>Value:Size</code></li><li><code>Value/TypeSpecifierList</code></li><li><code>Value:Size/TypeSpecifierList</code></li></ul></li><li>其中 <code>TypeSpecifierList</code> 是形如 <code>End-Sign-Type-Unit</code> 组成的字符串，其中不同的 Type 选项如下，每一个都可以忽略且没有顺序要求：<ul><li><code>End = big / native / little</code><br>决定字节序，默认 big</li><li><code>Sign = signerd / unsigned</code><br>仅用于模式匹配，默认 unsigned</li><li><code>Type = integer/ float / binary</code><br>默认 integer</li><li><code>Unit = 1 / 2 / 3 / ... / 255</code><ul><li>整个区块长度为 Size * Unit，其值必须大于或等于 0 且是 8 的倍数</li><li>其值依赖于 Type，如果 Type 是 integer 或者 float，则值为 1 ，是 binary 则值为 8</li></ul></li></ul></li></ul></li><li>binary 模式匹配</li></ul></li><li><p>apply</p><ul><li><code>apply(Module, Func, [Arg1, Arg2, ... , Argn])</code></li><li>对于参数个数已知的函数，<code>M:Func([Arg1, Arg2, ... , Argn])</code> 的调用优于 apply</li><li>使用 apply 调用的函数编译器无法优化，同时许多分析工具也无法分析其细节</li><li>如无必要尽量少用 apply</li></ul></li><li><p>属性</p><ul><li>module</li><li>import</li><li>export</li><li>compile<ul><li>编译器选项，常用的 <code>-compile(export_all).</code></li></ul></li><li>vsn<br>无语法意义，用于文档分析</li><li>用户定义属性 <code>-SomeTag(Value)</code><ul><li>该值会被编译进模块</li><li>该值可以在运行时使用 <code>attrs:module_info()</code> 提取</li><li><code>beam_lib</code> 提供了一系列不加载模块代码就能分析的函数</li></ul></li></ul></li><li><p>块表达式<br>把多个表达式组织为单个表达式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=k>begin</span>
</span></span><span class=line><span class=cl>	<span class=nv>Expression1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nv>Expression2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=nv>ExpressionN</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div></li><li><p>布尔</p><ul><li>Erlang 中不存在布尔类型，通常使用原子 <code>true/false</code> 代替作为布尔符号使用</li><li>布尔表达式：<code>and / not / or / xor</code></li></ul></li><li><p>字符集</p><ul><li>Erlang 默认编码为 <code>ISO-8859-1 (Latin-1)</code></li><li>Erlang 内部没有字符串数据类型，而是用一串整数列表表示</li><li>因此要注意 Unicode 字符的处理</li><li>使用 unicode 模块中如 <code>unicode:characters_to_list</code> 的函数处理 unicode 字符</li></ul></li><li><p>epp</p><ul><li>Erlang 预处理器，扩展宏，插入必须的包含文件等</li></ul></li><li><p>转义字符</p></li><li><p>表达式/表达式序列</p><ul><li>表达式序列的值为序列中最后一个表达式的值</li></ul></li><li><p>函数引用</p></li><li><p>包含文件</p><ul><li><code>include</code></li><li><code>include_lib</code></li></ul></li><li><p>列表操作符</p><ul><li><code>++</code><ul><li>列表添加 <code>ListA ++ ListB</code><br>即把 ListB 附加到 ListA 尾部</li><li>模式匹配中的 <code>++</code><br><code>f("begin" ++ T) -> ...</code> 即相当于模式匹配 <code>[$b, $e, $g, $i, $n | T]</code></li></ul></li><li><code>--</code><br>列表删除 <code>ListA -- ListN</code> ，即从 ListA 中删除 ListB 中的所有元素，若元素 E 在 B 中重复出现 k 次，则只会从 ListA 中按顺序删除 k 个 E</li></ul></li><li><p>宏</p><ul><li>定义<ul><li>不带参数 <code>-define(Macro, ...)</code></li><li>带参数 <code>-define(Macro(X,Y), ...)</code></li><li>预定义宏<ul><li><code>?FILE</code> 当前文件名</li><li><code>?MODULE</code> 当前模块名</li><li><code>?LINE</code> 当前行号</li></ul></li></ul></li><li>宏的流程控制<ul><li><code>-undef(Macro)</code> 取消宏定义，在此语句后无法使用该宏</li><li><code>ifdef / ifndef / else / end</code></li><li>结合调试标志，扩展 debug 日志输出等</li></ul></li></ul></li><li><p>数值类型</p><ul><li>整型<ul><li>整型的计算是精确的</li><li>其计算结果代表的数据长度只受限于可用内存</li><li>表示法<ul><li>传统表示法，<code>1, 1989, -1337</code></li><li>K 进制整数，<code>2#01001011，16#fe34</code></li></ul></li></ul></li><li>浮点型<ul><li>内部以 IEEE 754 的 64 bit 格式表示</li></ul></li></ul></li><li><p>操作符优先级</p></li><li><p>进程字典</p><ul><li><p>每一个 Erlang Process 都有自己的进程字典</p></li><li><p>实际上提供的功能类似于全局变量</p></li><li><p>由于不是非破坏性赋值，会导致代码有副作用</p></li><li><p>尽量少用</p></li><li><p>添加/获取进程字典</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>@</span><span class=n>spec</span> <span class=nb>put</span><span class=p>(</span><span class=nv>Key</span><span class=p>,</span> <span class=nv>Value</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nv>OldValue</span> <span class=p>|</span> <span class=n>undefined</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>@</span><span class=n>spec</span> <span class=nb>get</span><span class=p>(</span><span class=nv>Key</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nv>Value</span> <span class=p>|</span> <span class=n>undefined</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>@</span><span class=n>spec</span> <span class=nb>get</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=p>[{</span><span class=nv>Key</span><span class=p>,</span> <span class=nv>Value</span><span class=p>}].</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div></li></ul></li><li><p>引用<br>使用 BIF <code>erlang:make_ref()</code> 创建引用</p></li></ul></li></ul></div><div class=tags><ul class=info><li>2015-04-22</li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li><li class=button title="show comments" id=toggle-comments><i class="fa-solid fa-message"></i></li></ul></div></div><div class=comments id=comments><section class="article discussion" style=display:none><script>function loadComment(){let t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","caoyue/caoyue.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("label","Comment"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",''),document.querySelector("section.article.discussion").innerHTML='',document.querySelector("section.article.discussion").appendChild(e)}loadComment(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{loadComment()});function toggleComment(){let e=document.querySelector("section.article.discussion");e.style.display=="none"?e.style.display="block":e.style.display="none"}document.querySelector("#toggle-comments").addEventListener("click",toggleComment)</script></section></div></div><footer class=footer><div>©2022 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch(e){}</script></div></footer></div></body></html>