<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ejabberd on 且听疯吟</title><link>https://blog.caoyue.me/tags/ejabberd/</link><description>Recent content in ejabberd on 且听疯吟</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>i@caoyue.me (caoyue)</managingEditor><webMaster>i@caoyue.me (caoyue)</webMaster><lastBuildDate>Thu, 01 Jan 2015 16:33:00 +0000</lastBuildDate><atom:link href="https://blog.caoyue.me/tags/ejabberd/index.xml" rel="self" type="application/rss+xml"/><item><title>ejabberd: Apple Push Notification Service</title><link>https://blog.caoyue.me/post/ejabberd-apns/</link><pubDate>Thu, 01 Jan 2015 16:33:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-apns/</guid><description>主要是通过 hook ejabberd 的离线消息处理，从而实现针对离线消息进行推送
1. Hook offline message 记录 device token
这一步没啥好说的，iOS 连接到 APNs 后获取到 device token，发给服务器，服务器负责维护好对应关系即可。
注意客户端退出时清理掉相应记录。
在 ejabberd 中新增一个模块，注册 offline_message_hook，大致如下：
start(Host, Opts) -&amp;gt; ?INFO_MSG(&amp;#34;Starting mod_push_service&amp;#34;, []), register(?MODULE, spawn(?MODULE, init, [Host, Opts])), ok. init(Host, _Opts) -&amp;gt; ejabberd_hooks:add(offline_message_hook, Host, ?MODULE, send_notification, 10), ok. stop(Host) -&amp;gt; ?INFO_MSG(&amp;#34;Stopping mod_push_service&amp;#34;, []), ejabberd_hooks:delete(offline_message_hook, Host, ?MODULE, send_notification, 10), ok. send_notification(From, To, Packet) -&amp;gt; dosomething. 2. Implement APNs 从 Apple 获取推送证书
在服务端使用该证书建立 ssl 连接
按照 Apple 文档生成指定格式的 Payload 并发送</description></item><item><title>ejabberd-MAM</title><link>https://blog.caoyue.me/post/ejabberd-mam/</link><pubDate>Tue, 23 Dec 2014 15:46:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-mam/</guid><description>MAM - Message Archive Management 1. Message Archive Archiving archived tag &amp;lt;message to=&amp;#39;juliet@capulet.lit/balcony&amp;#39; from=&amp;#39;romeo@montague.lit/orchard&amp;#39; type=&amp;#39;chat&amp;#39;&amp;gt; &amp;lt;body&amp;gt;Call me but love, and I&amp;#39;ll be new baptized; Henceforth I never will be Romeo.&amp;lt;/body&amp;gt; &amp;lt;archived by=&amp;#39;juliet@capulet.lit&amp;#39; id=&amp;#39;28482-98726-73623&amp;#39; /&amp;gt; &amp;lt;/message&amp;gt; 2. Querying Filtering
by jid &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;juliet1&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;with&amp;gt;juliet@capulet.lit&amp;lt;/with&amp;gt; &amp;lt;/query&amp;gt; &amp;lt;/iq&amp;gt; by time &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;juliet1&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;start&amp;gt;2010-06-07T00:00:00Z&amp;lt;/start&amp;gt; &amp;lt;end&amp;gt;2010-07-07T13:23:54Z&amp;lt;/end&amp;gt; &amp;lt;/query&amp;gt; &amp;lt;/iq&amp;gt; by max number by uid of message &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;q29303&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;start&amp;gt;2010-08-07T00:00:00Z&amp;lt;/start&amp;gt; &amp;lt;set xmlns=&amp;#39;http://jabber.</description></item><item><title>ejabberd Login module</title><link>https://blog.caoyue.me/post/ejabberd-login/</link><pubDate>Tue, 16 Sep 2014 15:45:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-login/</guid><description>懒得贴代码，画个渣图看下好了。
P.S 从图上可以看出 XMPP 确实是细（fán）致（suǒ）之极了，考虑到在移动设备上的使用，这样的效率肯定是无法接受的。
对特定的服务来说，没有必要做如此多的交互步骤，考虑做一些简化。
Update: 详细的 login 流程 gist d0ec83e9aa3c1899287d</description></item><item><title>XMPP protocol</title><link>https://blog.caoyue.me/post/xmpp-protocol/</link><pubDate>Tue, 05 Aug 2014 11:01:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/xmpp-protocol/</guid><description>XMPP 协议 XMPP 协议是一种基于 XML 的 IM 协议，其前身是 jabber，后来被 IETF 标准化。其他信息可以参考 wikipedia.
协议架构 通过 TCP socket 与 XMPP 服务器进行通信 传输的是预定格式的 XML 信息 通过解析 XML 提取请求类型和消息 消息格式 一个实体在 XMPP 网络中被称为一个节点，它有唯一的标示符 jabber identifier (JID)，实体可以是用户或者聊天室
XMPP 中定义了 3 个顶层元素： Message、Presence、IQ
Message
基本的消息通讯格式：
To：消息的接收方 from : 发送方的 JID body: 要发送的消息 type: normal：单纯的消息，不要求响应； chat：IM 消息 groupchat：聊天室 group chat headline：发送 alert 和 notification 消息 error：发送 message 出错时通知 &amp;lt;message from=&amp;#39;nobody@caoyue.me/test&amp;#39; to=&amp;#39;anybody@caoyue.me&amp;#39; type=&amp;#39;chat&amp;#39;&amp;gt; &amp;lt;body&amp;gt;Anybody?&amp;lt;/body&amp;gt; &amp;lt;/message&amp;gt; Presence
用来表明用户的状态，如：online、away、dnd (请勿打扰)等。</description></item><item><title>Thoughts on Erlang and ejabberd</title><link>https://blog.caoyue.me/post/thoughts-on-erlang-ejabberd/</link><pubDate>Sun, 03 Aug 2014 18:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/thoughts-on-erlang-ejabberd/</guid><description>分析 WhatsApp 架构的时候提到了他们使用的 Erlang + ejabberd 架构。看起来非常神奇，但感觉想要直接搬过来也有一些问题。
Erlang 优秀的工程师
Erlang 看起来语法简单、函数式编程、并发能力强，但就是——会的人太少了，连 Facebook 都找不到足够的优秀 Erlang 程序员，这是为什么呢……反正我们 HR 表示目前连投简历的人都没有 XD 语言本身
刚接触 Erlang，只能说下初步的感受，也有可能是见识不及，权当一看。 语法简单，特性少。很难说到底是优点还是缺点。Erlang 的语法可能一页纸就能写完。但是带来的是「我应该怎么开始？」这样的问题 学习成本。无论鼓吹者宣扬函数式多么好，语言始终是用来解决问题的。Java 再烂依然大把公司用得很 happy 。大部分程序员是务实的，只有能带来好处才会去原因学习。但是对习惯了面向对象命令式编程的程序员来说，学习和思维转换的成本可能根本比带来的好处要大得多。Golang 比 Erlang 火不是没有理由的 数据类型。比如不存在字符串而是使用 List ，不管从性能或是直觉上来说，总觉得有那么点奇怪 数据抽象能力。用 Erlang 开发的复杂应用实在看得头疼，数据抽象能力弱好处是灵活，但导致的后果就是代码里到处充斥着不知道意义的 tuple 和 record，它们之间可能还层层嵌套，让我感觉脑子时刻准备 StackOverflow 和其他语言的交互。Erlang 处处透露着一股高冷范儿，比如独特的错误恢复机制，自实现的进程等等，很难做到和其他语言合群。但是在自己的领域里，Erlang 做得足够好。 XMPP 协议 XMPP 协议实在是太「重」了！XMPP 协议基于 XML ，很大的问题是信息冗余太大，传输数据的很大部分（一般超过 60%）是协议相关，其中既有协议本身繁冗的关系，也有 XML 的原因。
对移动设备来说这将是个很大的问题——更多的流量消耗、以及相关的电量、网络效率等等。 XMPP 协议的另一个问题在于扩展的复杂。XMPP 协议本身已经定义了一大堆协议流程，如果想要在基础之上扩展，将会非常麻烦。
基本上使用 XMPP 协议的服务最后都会改换成自定义协议（比如 WhatsApp），也不是没有原因的。 想要快速开发 Erlang + ejabberd 还是不错的，XMPP 协议本身很开放和完善，各种平台的实现也很多，用来快速原型还是不错的。但是想要实现深度的定制和优化可能就需要更多的时间和精力了，尤其对于移动平台来说。</description></item><item><title>WhatsApp 的一点分析</title><link>https://blog.caoyue.me/post/whatsapp-and-erlang/</link><pubDate>Fri, 01 Aug 2014 18:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/whatsapp-and-erlang/</guid><description>最近的项目需要做一个跨平台的 IM 服务，想要参考下其他项目的架构。国内分享不多，微信基本没有参考价值，毕竟 QQ 的积累在那。陌陌从招聘及据网上抓包的内容看是 XMPP 协议，看起来可能是 Java 的 openfire 之类的 XMPP 路线。
国外的分享稍微多一些，像 WhatsApp 每年都会做一些相关的分享，看起来有些参考价值。
WhatsApp 目前的数据 月用户约为 4.65 亿 每天有 190 亿 消息进站/ 400 亿消息出站 6 亿图片,2 亿音频, 1 亿视频 峰值并发连接为 1.47 亿 消息峰值为每秒 34.2 万进站/ 71.2 万出站 节日期间流量更加惊人 支撑这些数据的硬件 约 550 台服务器 约 150 台 chat server, 可以支持 1.5 亿连接 约 250 台 mms 服务器 数据服务器内存为 512 GB，标准节点是 64 GB 除了视频，其他数据都存储在 SSD 上 超过 11000 个核心 Mnesia 使用了约 2TB 的内存 服务端架构 几乎全部使用 Erlang (经过了自己的改造) 服务器使用的是 FreeBSD 9.</description></item></channel></rss>