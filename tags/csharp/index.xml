<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>csharp on 且听疯吟</title><link>https://blog.caoyue.me/tags/csharp/</link><description>Recent content in csharp on 且听疯吟</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>i@caoyue.me (caoyue)</managingEditor><webMaster>i@caoyue.me (caoyue)</webMaster><lastBuildDate>Fri, 26 Jun 2015 18:54:00 +0000</lastBuildDate><atom:link href="https://blog.caoyue.me/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>如果 C# 支持 void 作为泛型参数</title><link>https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/</link><pubDate>Fri, 26 Jun 2015 18:54:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/</guid><description>有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的 比如，最近碰到一个问题，简化形式是这样的：
IEnumerable&amp;lt;int&amp;gt; Range(int n) { var i = 0; while (i &amp;lt;= n) { // DoSomething1... yield return i; i++; } } Range(n).ForEach(x =&amp;gt; DoSomething2(x)); void DoSomething2(x) { } 看出问题了么？ IEnumerable 接口是没有 ForEach 方法的，ForEach 是 List&amp;lt;T&amp;gt; 的方法，所以只能写成
```csharp Enumerable.Range(0, n).ToList().ForEach(x =&amp;gt; DoSomething(x)); ``` 但是显然这样就失去了延迟执行的意义了
我们也可以尝试使用 IEnumerable 的 Select 方法，变成这样：
```csharp Enumerable.Range(0, n).Select(x =&amp;gt; DoSomething2(x)); ``` 当然这样也行不通，因为我们的 DoSomething2 方法是 void 类型的
最后只能粗暴的给 DoSomething2 包装一个返回值</description></item><item><title>Qzzz</title><link>https://blog.caoyue.me/post/Qzzz/</link><pubDate>Sat, 28 Jun 2014 14:32:17 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/Qzzz/</guid><description>Windows 的计划任务功能不够用，于是试着写了个支持插件和动态加载的定时执行任务工具 Qzzz，暂时是个坑&amp;hellip;
Qzzz A scheduler app for windows.
How to use Run as a windows service
Use Install.bat to install the QzzzService Run as a console
Run Qzzz.exe and do not close the console. Create a plugin create a config file qzzz.json
{ &amp;#34;Id&amp;#34;: &amp;#34;323ADBF530C4307B336C670B3F5BD229&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;ToastPluginDemo&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;Description&amp;#34;: &amp;#34;Toast plugin demo&amp;#34;, &amp;#34;CronExpression&amp;#34;: &amp;#34;*/15 * * * * ?&amp;#34;, &amp;#34;StartAt&amp;#34;: &amp;#34;2014-06-01 00:00:00&amp;#34;, &amp;#34;EndAt&amp;#34;: &amp;#34;2014-07-01 00:01:00&amp;#34;, &amp;#34;PluginFileName&amp;#34;: &amp;#34;Qzzz.</description></item><item><title>在 Windows 8 Desktop App 中使用 Toast Notification</title><link>https://blog.caoyue.me/post/use-toast-in-windows-desktop-app/</link><pubDate>Sun, 22 Jun 2014 12:45:06 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/use-toast-in-windows-desktop-app/</guid><description>最近坐久了就感觉腰酸背痛，想要做个定时提醒，提醒自己定时休息走动一下。
现在的定时提醒软件要么太复杂要么太难看，本来想要使用系统自带的定时任务，但是 Windows 8 中废弃了计划任务中的弹出消息功能。
想到 Windows 8 中新增了 Toast Notification，能不能利用这个方式来提醒？但是没见过 Desktop app 使用这个功能，一直以为是 Windows Store App 专用的 API。
在翻 MSDN 的时候发现原来 Metro Toast Notification 适用范围也包括 Desktop app。然后折腾了一下，居然成功了:)
在 Desktop app 中使用 Windows 8/Windows RT API Toast 位于 Windows.UI.Notifications 命名空间中，但是默认情况下没法引用该命名空间，因为其中一些 API 在 Desktop 环境下是有限制的。幸运的是 Toast Notification 不属于其中。可以从 MSDN 上找到这些 API 的详细信息，其中就包括了适用范围 。
建立一个 Console Application，为了引用 Windows.UI.Notifications，需要编辑项目文件 .csproj。在第一个 PropertyGroup 节点中添加 &amp;lt;TargetPlatformVersion&amp;gt;8.0&amp;lt;/TargetPlatformVersion&amp;gt; 重新 Load 项目，添加引用。可以看到引用管理器左边添加了新的一列 Windows，添加 Windows.Data.Xml.Dom Windows.UI.Notifications</description></item><item><title>C# 中缀表达式计算</title><link>https://blog.caoyue.me/post/csharp-compute-expression/</link><pubDate>Mon, 28 Apr 2014 23:10:07 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/csharp-compute-expression/</guid><description>给出一个字符串的计算表达式如 1+2*(3-4)/5 ，不使用其他库如何计算其结果？
在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。
中缀表达式 中缀表达式 (Infix Expression)，即形如 a+b-c*d 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。
后缀表达式 后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 a+b 记作 a b +。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。
表达式转换 既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 调度场算法。实际上语法树的后序遍历也是后缀表示法。
简单分析下从中缀表达式到后缀表达式的过程：
定义两个栈 Operand（操作数栈）和 Operator（运算符栈）； 从左到右遍历字符串，按如下规则： 如果该字符为左括号，直接压入 Operator 栈中； 如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈； 如果该字符是操作符： 首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量； 查看 Operator 栈中是否存在运算符： 如不存在，将该操作符压入 Operator 栈中； 如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级： 该操作符优先级较高，将该操作符压入 Operand 栈中； 该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中； 如果该字符不是操作符也不是括号，则将其存入临时变量； 循环完成，将临时变量（即最后一个数字）压入 Operand 栈中； 将 Operator 栈依次弹出并压入到 Operand 栈中； 将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。 后缀表达式计算 将后缀表达式转换成堆栈 Suffix； 定义一个新的栈 Result; 依次弹出 Suffix 栈顶元素： 如果该元素不是运算符，将其压入 Result 栈中； 如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中； Result 栈顶元素即计算结果 这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。</description></item><item><title>Reference in CSharp</title><link>https://blog.caoyue.me/post/reference-in-csharp/</link><pubDate>Mon, 01 Jul 2013 11:11:11 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/reference-in-csharp/</guid><description>起因是 V2EX 的一个帖子.
C++ 中引用是一个很基础但是也很容易忽略的问题，那么在 C# 中呢？看下面的 Gist.
gist 5898137
分析 C# 中引用类型参数是按引用(即指针地址)来传递的，所以我们使用第一个 Swap 方法——结果是 a 和 b 的值没有变化。
再使用 ref 试试，OK，a 和 b 的值交换了。
再看没有使用 ref 的 Swap 方法。temp = a 实际上是令 temp 形参作为 Swap 函数的局部变量，即在栈上开辟空间存储了实参 a 指向的堆地址（形参 a 和 b 同理）。
操作完成后，可以看出，仅仅是在栈上的形参 temp、a、b 所存储的堆地址发生了改变，而原实参 a、b 所存储的堆地址并没有发生变化。
C# 的引用传递和值传递 引用类型作为参数时：
在修改变量本身时，结果类似于值传递，即不会改变传递前的变量的值，换句话说就是值传递传的是对象的值拷贝，而引用类型参数的值实际上就是其指向的堆对象的指针地址
即值传递传的是对象的值拷贝，函数内参数对象是调用时传递的对象的栈中对象的拷贝。
在修改变量的属性或字段时是引用传递，会影响到传递前的变量的值
如代码中，如果交换 a 和 b 的成员的值，则会修改实际对象的值。比如 SwapValue 方法可以成功交换。
这是因为形参 a 指向了堆中对象，修改其字段值实际上也就修改了该对象的字段，而实参 a 和 形参 a 指向的是同一对象，所以也就修改了实参 a 的值</description></item></channel></rss>