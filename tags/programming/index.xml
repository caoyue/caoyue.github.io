<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on 且听疯吟</title><link>https://blog.caoyue.me/tags/programming/</link><description>Recent content in programming on 且听疯吟</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>i@caoyue.me (caoyue)</managingEditor><webMaster>i@caoyue.me (caoyue)</webMaster><lastBuildDate>Wed, 31 May 2017 01:47:00 +0000</lastBuildDate><atom:link href="https://blog.caoyue.me/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>一个 ASP.NET MVC HtmlHelper 的 tricks</title><link>https://blog.caoyue.me/post/asp-net-mvc-htmlhelper/</link><pubDate>Wed, 31 May 2017 01:47:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/asp-net-mvc-htmlhelper/</guid><description>问题 先看下面一个简单的 ASP.NET MVC 5 的 demo：
model
public class TestModel { public List&amp;lt;int&amp;gt; Ints { get; set; } } controller
public ActionResult Index() { var testModel = new TestModel(); return View(testModel); } [ActionName(&amp;#34;Index&amp;#34;), HttpPost] public ActionResult Post(TestModel testModel) { return View(testModel); } view
@model Test.Controllers.TestModel &amp;lt;form action=&amp;#34;@Url.Action(&amp;#34;Index&amp;#34;)&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; @for (var i = 0; i &amp;lt; 10; i++) { @Html.TextBoxFor(model =&amp;gt; model.Ints[i]) } &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;Submit&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; 有没有看出什么问题？
View 里面的</description></item><item><title>写模板时的一些细节</title><link>https://blog.caoyue.me/post/html-details/</link><pubDate>Sun, 28 May 2017 03:14:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/html-details/</guid><description>最近从 farbox 迁移到了 bitcron，由于 bitcron 不再支持 html 的模板，只好用 jade 重写了一次
顺便整理了下之前写这个模板时碰到的一些细节，也许用得上吧
lang 国内很多网站都是不写这个 lang 属性的，比如 baidu。 而大部分国外网站都会写，Twitter 甚至为每一条推文都加上了 lang 属性
那么写上 lang 属性有什么意义呢？顾名思义，lang 属性声明了内容的语言。更详细的来说，比如:
浏览器可以根据 lang=en 知道当前网页是英文，于是可以问你是否需要开启翻译功能
Chrome 在版本 21 之后，开始根据 lang 属性来应用不同的默认字体。这意味着你可以为英语页面和中文、日文等页面设置不同的默认字体
这个选项没有出现在默认设置里，你可以使用这个 Chrome 扩展来设置：Advanced Font Settings
页面的 lang 属性会影响字体的显示
比如 思源黑体 中同时包含了中文字体和日文字体，我们知道日文中一部分汉字是相同的，为了节省空间，所以它们被放在了“同一个位置”上
然而即使是同样的字，也可能在字形上存在不同，比如，如果你安装了思源黑体，那么下面同样的字
门类 和 门类
&amp;lt;span lang=&amp;#34;ja-jp&amp;#34; style=&amp;#34;font-family:&amp;#39;Source Han Sans&amp;#39;&amp;#34;&amp;gt;门类&amp;lt;/span&amp;gt; &amp;lt;span lang=&amp;#34;zh-Hans&amp;#34; style=&amp;#34;font-family:&amp;#39;Source Han Sans&amp;#39;&amp;#34;&amp;gt;门类&amp;lt;/span&amp;gt; 显示出来的字形是不一样的，如图：
另外，由于中文字体 fallback 的关系，lang=en 下显示的是 lang=ja-jp 的字形，所以，如果发现网页显示的字形很奇怪，那么看看 lang 属性有没有正确的设置吧~
可以参考这里来决定选择用哪个 Language Code</description></item><item><title>炉石卡牌实现机制的一点猜想</title><link>https://blog.caoyue.me/post/hearthstone/</link><pubDate>Tue, 31 May 2016 18:43:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/hearthstone/</guid><description>假设我们要实现一个炉石的对战机制，要怎么做呢？
并没有游戏开发经验，所以以下都是乱猜加瞎扯~
分类 首先，我们把炉石里的主要元素分成几类：
法术
法术很好理解，一般来说法术包括几个要素
目标 可能是一个目标也可能是多个目标 可能包含一个筛选，比如「对非恶魔随从造成伤害」 效果 可能是给目标一个 buff 或者 debuff，也可能是造成伤害等等 大部分法术都是立即效果 也有一部分法术是触发效果，比如 奥秘，比如 本回合随从生命值不会降低到 1 点以下 武器
英雄
英雄技能可以看作一个法术 随从
随从本身具有的属性
花费/攻击/血量 类别： 恶魔/鱼人/野兽 其他
我们以 https://hearthstonejson.com/ 上的卡牌火车王的 Json 数据为例： { &amp;#34;id&amp;#34;: &amp;#34;EX1_116&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Leeroy Jenkins&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;&amp;lt;b&amp;gt;Charge&amp;lt;/b&amp;gt;. &amp;lt;b&amp;gt;Battlecry:&amp;lt;/b&amp;gt; Summon two 1/1 Whelps for your opponent.&amp;#34;, &amp;#34;rarity&amp;#34;: &amp;#34;LEGENDARY&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;MINION&amp;#34;, &amp;#34;cost&amp;#34;: 5, &amp;#34;attack&amp;#34;: 6, &amp;#34;health&amp;#34;: 2, &amp;#34;collectible&amp;#34;: true, &amp;#34;set&amp;#34;: &amp;#34;EXPERT1&amp;#34;, &amp;#34;faction&amp;#34;: &amp;#34;ALLIANCE&amp;#34;, &amp;#34;artist&amp;#34;: &amp;#34;Gabe from Penny Arcade&amp;#34;, &amp;#34;flavor&amp;#34;: &amp;#34;At least he has Angry Chicken.</description></item><item><title>使用 Travis CI 自动部署 React Native 项目 （iOS 篇）</title><link>https://blog.caoyue.me/post/react-native-travis-ci-ios/</link><pubDate>Wed, 09 Mar 2016 15:21:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/react-native-travis-ci-ios/</guid><description>编译、测试、打包、部署这一系列的操作实在是太麻烦而且容易出错漏，能自动化的东西我们就没必要手动去点。端着咖啡悠哉地等着叮的一声，安装包出现在面前，这才是我们想要的
花了点时间，把正在进行的 React Native 项目的自动部署完善了一下，实现了通过 Travis CI 自动编译测试，并打包成 ipa 发布到 FTP 的整个流程
现在只要 Push 到 Github 上，等到 Travis CI 运行完成，就直接可以拿到 ipa 包安装测试了
准备工作：
首先你需要一个 Github 账户
Travis CI 连接 Gtihub 后，会自动检查根目录下带有 .travis.yml 的项目
关于 Travis CI 的功能和文档，请参考 https://docs.travis-ci.com/
这里给出一个 React Native 项目的 yml 文件示例：
language: objective-c osx_image: xcode7.1 xcode_project: ios/MyApp.xcodeproj xcode_scheme: MyApp env: matrix: - SPEC=spec1 before_install: - ./scripts/decrypt_key.sh - ./scripts/add_key.sh - brew update install: - brew reinstall node flow watchman xctool - npm install -g react-native-cli branches: only: - master script: - .</description></item><item><title>react and react native</title><link>https://blog.caoyue.me/post/react-and-react-native/</link><pubDate>Tue, 27 Oct 2015 20:20:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/react-and-react-native/</guid><description>最近了解了下 react 和 react native，感觉看到了一条成为「Full-stack Developer」的捷径啊（雾
React 消息同步
不管是 Web 还是 Native 应用，一个很麻烦的问题就是保持某个 Message 在不同 View 之间的状态同步。
比如，收到一条消息，需要在未读标签显示状态和数字，然后未读列表中插入一条消息记录。
阅读消息后，需要从未读中去掉这条记录，同时在已读中新增一条记录，还不能忘了将未读数字减去。
我们是怎么处理这种情况？
要在接收消息的 handler 中判断各个 View 当前的状态，然后根据对应的状态写不同的处理代码，阅读消息同理。当然高端点的可能自己搞个 Manager 之类的东西去对这些逻辑进行管理。
但是，并没有什么用。一旦业务复杂，处理和 Debug 起来就很麻烦了。看上去未读是 1，点进去发现是空，这种场景想必见得也不少了。
还记得很久之前我们怎么写页面的吗？（多久？大概到 ASP 吧=-= 那时候我们没有这么多烦恼。因为我们是这么干的。不管什么操作，ok，刷新页面，可以保证所有状态都是正确的，so easy!
React + Flux 所做的正和我们很久之前的做法有点像。数据更新了？重新渲染一遍 View 不就好了。
但是将整个 DOM 重新渲染一遍是开销很大的，当然不可能真的这么做。
所以就有了 Virtual DOM。
其实我们对 View 所做的操作大部分都是修改内容，比如修改某个块里面的文字啦，对某个 list 增删改啦。这些都不需要完全重绘。
React 做到了「智能」去更新 DOM，只改变需要改变的地方。（嗯，就是不相信你能写出高效正确的操作 DOM 的代码，所以我们都帮你写好啦~（雾
组件化
通常我们的页面上的控件都是带有不同的状态的，比如选框是否选中等等。而不同情况下状态可能会根据一些参数去变化，这让一般情况下的组件复用变得很麻烦。
而 React 可以做到类似于函数的给定输入参数，输出固定的状态，可以很方便的实现 Web Components，也不会出现组件状态上的冲突。
而组件化的开发带来的效率提升是非常高的。
其他
另外经常看到人说 HTML 嵌在 JS 里面感觉很奇怪是不是模板耦合在代码里面之类的，我倒是觉得这种写法挺简洁优雅的。如果把 JSX 里面的 XML 看作是一个 XML 表示的 Object，这样理解可能会好点吧。当然你也可以使用纯 JS 的方式去写。</description></item><item><title>QQ 是怎么实现快速登录的</title><link>https://blog.caoyue.me/post/how-qq-quick-signin/</link><pubDate>Wed, 09 Sep 2015 18:02:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/how-qq-quick-signin/</guid><description>这个问题之前很好解决，使用浏览器 plugin 即可。
但是随着 Chrome 和 Firefox 都先后放弃了 NPAPI plugin，这一方法也行不通了，而且很多人是很讨厌 plugin 的。
但是在默认禁止了 NPAPI 的 Chrome 版本，QQ 依然可以实现快速登录（一键登录），是怎么做到的呢？
原理 其实不难猜。既然不存在 plugin，无法以此来实现浏览器内和本地客户端的直接通信，那么排除其他的黑科技，有一种很简单的方法可以实现这个效果。
那就是在客户端开一个 Server，在浏览器里面请求这个地址。
理论上这样是可以实现的，至于 QQ 是不是用的这种方法，稍微验证下好了。
验证 找一个有 QQ 快速登陆的页面，比如 mail.qq.com
登陆 QQ 客户端
打开浏览器的 Developer Tools -&amp;gt; Network
刷新页面，观察所有请求的 domain
好明显，这就是我们要找的了
完整请求 url 是这样的
https://localhost.ptlogin2.qq.com:4301/pt_get_uins?callback=ptui_getuins_CB&amp;amp;r=0.22949112393586502&amp;amp;pt_local_tk=-2027291081 看看这个请求的 Response Content
var var_sso_uin_list = [ { account: &amp;#34;xxxxxx&amp;#34;, client_type: 65793, face_index: 0, gender: 1, nickname: &amp;#34;xxx&amp;#34;, uin: &amp;#34;xxx&amp;#34;, uin_flag: xxxxx, }, ]; ptui_getuins_CB(var_sso_uin_list); 很明显是当前登录的用户信息</description></item><item><title>Does Facebook store plain-text passwords?</title><link>https://blog.caoyue.me/post/does-facebook-store-plain-text-passwords/</link><pubDate>Wed, 02 Sep 2015 18:23:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/does-facebook-store-plain-text-passwords/</guid><description>越来越多的网站开始更加关注安全问题了，比如，Facebook 会在你把密码从 abc123 改为 Abc123 的时候的时候提示你
Your new password is too similar to your current password. Please try another password.
很贴心是不是？但是，他们是怎么做到的？难道 Facebook 保存了用户的明文密码么？
编辑距离 计算两个字符串的相似性，或者说「编辑距离」很容易，我们有很多现成的算法和代码。
但是，显然 Facebook 不会傻到存储明文密码，存储的肯定是 hash(&amp;quot;abc123&amp;quot;)。
而字符串中的差别和 hash 结果并不是一一对应的。两个相近的字符串，其 hash 结果可能差别很大。
simhash 可能你听说过 simhash 算法。Google 就是使用这种算法来做网页查重的。
传统的 hash 算法如 md5，一般尽可能要求结果分布均匀，因此，原始字符串的微小变动也会导致 hash 结果出现很大差异。
而 simhash 是一种局部敏感的 hash 算法，选定位数，提取特征，然后对每一段特征值计算 hash，然后将每一段值处理到 simhash 结果，得到最后的 simhash 值。比较海明距离就可以大概知道两个文档的相似度了。
具体的算法懂得不多就不瞎说了……大概可以推测，对于长文档这种方法是有效的，但是对于短文本，如 password 来说，效果可能不会太好。
Facebook 的做法 事实上这个问题好奇的人也很多，Stack Exchange 上有一个回答 http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords，下面有一个自称接触过密码验证这部分代码的人肯定了这个猜测。
我觉得这种做法看起来还是挺合理的。
Facebook 用了一种看起来很「土」的方法，操作方法类似这样：
用户注册，密码 abc123，Facebook 保存了 `hash(&amp;ldquo;abc123&amp;rdquo;) 用户修改密码，提交新密码 Abc123 Facebook 拿到新密码，根据这个密码，生成一堆类似于 ABC123，abc123 这样相近的密码，使用同样的 hash 方法，去和 1 中的 hash 比对，一旦发现有相同的，那么可以判定新密码与旧密码是相似的。 很好的反向思维，不是去计算相似性，而是通过生成一堆相似密码来「暴力」尝试。</description></item><item><title>如果 C# 支持 void 作为泛型参数</title><link>https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/</link><pubDate>Fri, 26 Jun 2015 18:54:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/</guid><description>有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的 比如，最近碰到一个问题，简化形式是这样的：
IEnumerable&amp;lt;int&amp;gt; Range(int n) { var i = 0; while (i &amp;lt;= n) { // DoSomething1... yield return i; i++; } } Range(n).ForEach(x =&amp;gt; DoSomething2(x)); void DoSomething2(x) { } 看出问题了么？ IEnumerable 接口是没有 ForEach 方法的，ForEach 是 List&amp;lt;T&amp;gt; 的方法，所以只能写成
```csharp Enumerable.Range(0, n).ToList().ForEach(x =&amp;gt; DoSomething(x)); ``` 但是显然这样就失去了延迟执行的意义了
我们也可以尝试使用 IEnumerable 的 Select 方法，变成这样：
```csharp Enumerable.Range(0, n).Select(x =&amp;gt; DoSomething2(x)); ``` 当然这样也行不通，因为我们的 DoSomething2 方法是 void 类型的
最后只能粗暴的给 DoSomething2 包装一个返回值
Enumerable.Range(0, n).Select(x =&amp;gt; { DoSomething2(x); return true; }); 如果 IEnumerable 支持 ForEach 方法就好了？ 事实上 C# 设计者对此作了解释：“foreach” vs “ForEach” 总之来说，List&amp;lt;T&amp;gt;.</description></item><item><title>About Erlang: Records</title><link>https://blog.caoyue.me/post/about-erlang-records/</link><pubDate>Wed, 27 May 2015 13:59:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-erlang-records/</guid><description>1. tuple and record 现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?
-record(test, { a::binary(), b::binary() }). KeyValuePairs = [{a, &amp;lt;&amp;lt;&amp;#34;a&amp;#34;&amp;gt;&amp;gt;},{b, &amp;lt;&amp;lt;&amp;#34;b&amp;#34;&amp;gt;&amp;gt;}]. 很基础的问题，我们这样做：
Result = #test{ a = get_value(a, KeyValuePairs), b = get_value(a, KeyValuePairs) }. 如果 record 有一百个项呢？
重复的写 a = get_value(a, KeyValuePairs) 这样的代码一百次大概会让人怀疑「猿」生吧 :(
虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道
Erlang 的 record 实际上是用 tuple 来表示的，即 #test{a = &amp;lt;&amp;lt;&amp;quot;a&amp;quot;&amp;gt;&amp;gt;, b = &amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;gt;&amp;gt;} 实际上是 {test, &amp;lt;&amp;lt;&amp;quot;a&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;gt;&amp;gt;} 所有在运行时对 record 的操作实际上都是对 tuple 的操作 Result#test.a 实际上是 tuple 的 index 可以使用 record_info(fields, record) 获取 Record 的 fields 信息 所以我们可以这样</description></item><item><title>预排序遍历算法树</title><link>https://blog.caoyue.me/post/mptt-tree/</link><pubDate>Mon, 11 May 2015 21:43:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/mptt-tree/</guid><description>1. 预排序遍历树算法 mptt (Modified Preorder Tree Traversal)1 优点
查询效率高，只需要一次查询即可获得层级结构中某个节点的所有子节点，无需递归查询 缺点
插入、删除、移动节点效率较低 适用
在传统关系数据库中实现层级树结构 读压力 &amp;gt; 写压力， mptt 算法可以提高效率 写压力 &amp;gt; 读压力，使用传统的邻接表 (adjacency list model) 2. 增删查改 Create
假设增加的节点为 c, 该节点前一节点为 p 节点 c 左值为 p 的右值 +1，右值为 p 右值 +2 所有左值大于节点 c 的左值的节点，其左值均 +2 所有右值大于节点 c 的右值的节点，其右值均 +2 写入节点 c 到数据库 SELECT @cRight := rgt FROM mptt WHERE name = &amp;#39;p&amp;#39;; UPDATE mptt SET rgt = rgt + 2 WHERE rgt &amp;gt; @cRight ; UPDATE mptt SET lft = lft + 2 WHERE lft &amp;gt; @cRight ; INSERT INTO mptt(name, lft, rgt) VALUES(&amp;#39;c&amp;#39;, @cRight+ 1, @cRight+ 2); Read</description></item><item><title>关于 Erlang 的一些想法</title><link>https://blog.caoyue.me/post/about-erlang/</link><pubDate>Mon, 16 Mar 2015 13:59:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-erlang/</guid><description>断断续续学习和使用 Erlang 几个月了，感觉跟之前看待这门语言有了点变化，还是挺有意思的。
作为初学者可能理解不太准确，但有些东西还是可以记录一下。
关于函数式编程 刚开始从其他语言转移到函数式语言的时候还害怕所谓的思维转换，实际上担心有点多余
入门并不难，能理解把循环写成尾递归的过程就基本没什么问题了
更少的心智负担，不再需要考虑是传值还是传引用，以及糟糕的副作用
在某些问题上更接近思维过程，不需要关心怎么做，只需要关心做什么
比如 erlang 的 quicksort 可以这么写（注意这并不是高效的写法）：
qsort([]) -&amp;gt; []; qsort([Pivot | T]) -&amp;gt; qsort([X || X &amp;lt;- T, X &amp;lt; Pivot]) ++ [H] ++ qsort([X || X &amp;lt;- T, X &amp;gt;= Pivot]). 关于 Erlang 语法简单 没有大量的复杂的概念，不像某些《Thinking in XXXX》，看完巨厚一本书你发现自己还是啥也不懂 没有大量的奇技淫巧 大概看了一个多月，就基本可以把 ejabberd 代码从头到尾过一遍了 多看多用，我自己入门看的 《Erlang Programing》 pattern match 用过才知道有多好用 据说效率极其惊人 据说 C# 也要加入了 并发 process 需要并发执行一个任务的时候，最容易想到的就是新开一个 process 去处理 Erlang 的 process 是轻量的，开启和关闭消耗也小，不需要操心各种并发问题 避免锁 实际上开始写命令式代码的时候，我倒是不怎么担心死锁，担心的反而是应该在哪里加锁…… Erlang 的并发模型没有试图去解决锁的问题，而是从根源避免了它，那就是根本不允许全局变量共享（当然你需要共享，可以使用 ETS 或者外部数据库） 对我而言，这种做法减轻了不少心智负担 鼓励崩溃和热更新 写代码的时候 Server 不用不停重启刷新的感觉太好 效率 入门快</description></item><item><title>原来 IP 地址还可以用混合进制表示</title><link>https://blog.caoyue.me/post/ip-address-as-octal/</link><pubDate>Sun, 18 May 2014 18:55:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ip-address-as-octal/</guid><description>今天发现 Google 的时候发现收录了一个奇怪的地址，形如 23.244.200.000000000354，而且这个地址居然还是可以访问的。很显然这不是域名，尝试 ping 一下，返回地址来自于 23.244.200.236，可以看出 000000000354 是 236 的八进制表示形式。
###混合进制
查了下，原来 IP 地址居然可以混合进制来显示……前导的 0 的数字会被当作八进制来处理。而且可以同时使用不同进制：包括十六进制、八进制和十进制。
比如 http://0x17.244.0xc8.00000354 这样奇葩的地址也是可以访问的……
###DWORD 形式的 IP
还有更奇葩的，整数型的 IP —— 比如这个：http://401918188 ，同样可以访问。
转换过程是将 23.244.200.236 转换为二进制形式，不足 8 为的数字用 0 补足： 00010111111101001100100011101100，然后将这一串二进制数字转换为整数，即可得到整数型的 IP 地址。
当然，如果将这个整数换成其他进制也是可以的，比如：
http://02775144354 和 http://0x17f4c8ec
###可省略的 0
当然，奇葩还没有结束。比如这样的 IP 地址 192.168.1 也是可以访问的……因为某部分为 0 则可以省略。OK，那我们怎么知道省略的是哪一部分呢？别急，「聪明」的标准的制定者们早就想到这一点了，规则如下：
abbr IP A 0.0.0.A A.B A.0.0.B A.B.C A.B.0.C A.B.C.D A.B.C.D ###其他
原 IP 127.0.0.1 按上面的方法改变下形式
http://0x7f.0.000000000001 http://2130706433 http://017700000001 http://0x7f000001 http://127.</description></item><item><title>C# 中缀表达式计算</title><link>https://blog.caoyue.me/post/csharp-compute-expression/</link><pubDate>Mon, 28 Apr 2014 23:10:07 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/csharp-compute-expression/</guid><description>给出一个字符串的计算表达式如 1+2*(3-4)/5 ，不使用其他库如何计算其结果？
在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。
中缀表达式 中缀表达式 (Infix Expression)，即形如 a+b-c*d 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。
后缀表达式 后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 a+b 记作 a b +。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。
表达式转换 既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 调度场算法。实际上语法树的后序遍历也是后缀表示法。
简单分析下从中缀表达式到后缀表达式的过程：
定义两个栈 Operand（操作数栈）和 Operator（运算符栈）； 从左到右遍历字符串，按如下规则： 如果该字符为左括号，直接压入 Operator 栈中； 如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈； 如果该字符是操作符： 首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量； 查看 Operator 栈中是否存在运算符： 如不存在，将该操作符压入 Operator 栈中； 如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级： 该操作符优先级较高，将该操作符压入 Operand 栈中； 该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中； 如果该字符不是操作符也不是括号，则将其存入临时变量； 循环完成，将临时变量（即最后一个数字）压入 Operand 栈中； 将 Operator 栈依次弹出并压入到 Operand 栈中； 将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。 后缀表达式计算 将后缀表达式转换成堆栈 Suffix； 定义一个新的栈 Result; 依次弹出 Suffix 栈顶元素： 如果该元素不是运算符，将其压入 Result 栈中； 如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中； Result 栈顶元素即计算结果 这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。</description></item><item><title>Firefox 的表单缓存「Bug」</title><link>https://blog.caoyue.me/post/firefox-form-cache/</link><pubDate>Sat, 07 Sep 2013 11:06:11 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/firefox-form-cache/</guid><description>##问题
在使用 Firefox 测试网站的时候遇到一个奇怪的问题。
把一份数据写入类型为 hidden 的 input 中时，比如
&amp;lt;input type=&amp;#34;hidden&amp;#34; value=&amp;#34;@Model.Count&amp;#34; id=&amp;#34;Count&amp;#34; /&amp;gt; 然后在用 Javascript 修改这个值，比如后台数据原为 0，
var count = parseInt($(&amp;#34;#Count&amp;#34;).val()); $(&amp;#34;#Count&amp;#34;).val(count + 1); 不提交表单，刷新页面，发现 $(&amp;quot;#Count&amp;quot;).val() 的值却不是后台数据的 0，而是我们修改过后的值，这个值被缓存了。
##原因
使用其他浏览器测试可以发现，这个问题仅出现在 Firefox 中。从而可以考虑是否 Firefox 对表单缓存的实现「有问题」。
##解决
设置 form 的 autocomplete=&amp;quot;off&amp;quot;</description></item></channel></rss>