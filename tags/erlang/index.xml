<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang on 且听疯吟</title><link>https://blog.caoyue.me/tags/erlang/</link><description>Recent content in erlang on 且听疯吟</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>i@caoyue.me (caoyue)</managingEditor><webMaster>i@caoyue.me (caoyue)</webMaster><lastBuildDate>Sat, 22 Aug 2015 01:14:00 +0000</lastBuildDate><atom:link href="https://blog.caoyue.me/tags/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>Joe Armstrong and Erlang</title><link>https://blog.caoyue.me/post/joe-armstrong-and-erlang/</link><pubDate>Sat, 22 Aug 2015 01:14:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/joe-armstrong-and-erlang/</guid><description>无意中翻到 Joe Armstrong 发在 erlang-questions 里的文章，Ways to get started 以及 history of erlang。
如果你不知道 Joe Armstrong 是谁，我们给他的另一个称呼是 the father of Erlang :)
大概没有人比他更有资格写这种文章了吧。
在高手眼中大道至简，我们不一定学的来，但是听听还是很有启发的
随便瞎扯几句
忘掉工具 Forget about git/IDEs/rebar etc.
Forget about the tools
如果没有 IDE，没有自动打包工具，我们怎么编写和运行代码？
记住，shell 和文本编辑器对任何语言都是适用的。
当然我并不觉得这意味着需要放弃 IDE 之类的工具，而是在 get started 的时候，对程序怎么工作的有基本的了解是有好处的。
某种意义上来说，过于复杂的工具链意味着，一旦它没有按照你想象的运行，就需要花费更多的时间去解决它。
rebar!
当然，不能忘了 rebar!
事实上 rebar 已经快要成为 erlang project 的标配了。 Tools like rebar etc are under to automate something but if you don&amp;rsquo;t</description></item><item><title>About Erlang: Records</title><link>https://blog.caoyue.me/post/about-erlang-records/</link><pubDate>Wed, 27 May 2015 13:59:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-erlang-records/</guid><description>1. tuple and record 现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?
-record(test, { a::binary(), b::binary() }). KeyValuePairs = [{a, &amp;lt;&amp;lt;&amp;#34;a&amp;#34;&amp;gt;&amp;gt;},{b, &amp;lt;&amp;lt;&amp;#34;b&amp;#34;&amp;gt;&amp;gt;}]. 很基础的问题，我们这样做：
Result = #test{ a = get_value(a, KeyValuePairs), b = get_value(a, KeyValuePairs) }. 如果 record 有一百个项呢？
重复的写 a = get_value(a, KeyValuePairs) 这样的代码一百次大概会让人怀疑「猿」生吧 :(
虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道
Erlang 的 record 实际上是用 tuple 来表示的，即 #test{a = &amp;lt;&amp;lt;&amp;quot;a&amp;quot;&amp;gt;&amp;gt;, b = &amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;gt;&amp;gt;} 实际上是 {test, &amp;lt;&amp;lt;&amp;quot;a&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;gt;&amp;gt;} 所有在运行时对 record 的操作实际上都是对 tuple 的操作 Result#test.a 实际上是 tuple 的 index 可以使用 record_info(fields, record) 获取 Record 的 fields 信息 所以我们可以这样</description></item><item><title>Erlang Programming 笔记 3</title><link>https://blog.caoyue.me/post/erlang-programming-3/</link><pubDate>Thu, 23 Apr 2015 17:28:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/erlang-programming-3/</guid><description>6. 编译并运行程序 （略） 7. 并发 机制 Erlang 程序由成百上千个 Process 组成，这些 Process 之间可以互发消息 Process 能否接收到或者理解消息是不确定的，要知道结果必须向该 Process 发送消息询问并等待 Process 之间可以互相 Link ，当 Process 消亡时与之相连的 Process 会收到消息 8. 并发编程 并发原语
Pid = spawn(Module, FuncName, Args)
创建一个新的 Process，用于对 Func 求值，并返回该 Process 的 pid Pid ! Message 向指定 Pid 的 Process 发送消息，返回值为 Message 本身 消息发送是异步的，无需等待即可进行其他操作 receive ... end 接收一个发给当前进程的消息 self()</description></item><item><title>Erlang Programming 笔记 2</title><link>https://blog.caoyue.me/post/erlang-programming-2/</link><pubDate>Wed, 22 Apr 2015 17:25:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/erlang-programming-2/</guid><description>4. 异常 抛出异常
显式的 exit(Why) 终止当前 Process 如果当前 Process 未捕获这个异常，则系统会向所有 link 该 Process 的 Process 广播 {'EXIT', Pid, Why} 消息 显式的 throw(Why) 抛出供其调用者捕获的异常 最好是添加注释说明抛出的异常 如何处理由调用者选择，包括忽略 系统错误 erlang:error(Why) try..catch 捕获异常
try/catch 本身会消耗一点性能
推荐的 try/catch 风格
%% 首先对 FuncOrExpressionSequence 求值 %% 如果没有产生异常则顺序进行 Patterm 匹配, 匹配成功后执行后面的表达式 %% 如果有异常抛出, 则顺序匹配 ExPattern(ExceptionType 是 throw、exit、error 中的一个, 默认为 throw) %% after 块中的代码用于清理工作,绝对会执行 %% after 可以省略 try FuncOrExpressionSequence of Pattern1 [when Guard1] -&amp;gt;Expressions1; Pattern2 [when Guard2] -&amp;gt;Expressions2; .</description></item><item><title>Erlang Programming 笔记 1</title><link>https://blog.caoyue.me/post/erlang-programming-1/</link><pubDate>Tue, 21 Apr 2015 17:05:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/erlang-programming-1/</guid><description>1. Erlang 优势 并发和分布式 主流语言使用共享内存模型，类似于 x = x + n 的代码导致了在多核环境下需要小心的处理锁的问题 Erlang 使用消息模型，Process 间不共享数据，从而避免了锁的问题 无锁避免了顺序瓶颈，添加节点到网络更容易 错误处理 多数语言默认认为程序不会出错 Erlang 采用不同的设计决策——注定要出错，那就让他出错，出错后恢复就行了。即 Erlang 程序出错后，会交由更高级的 Process 来处理（重启 Child Process、系列全部终止、重启相关 Process 等等），从而实现对错误的分级和容错处理 同时带来了热更新的好处，进一步保证了可用性 2. 入门 Shell
f(). 会释放所有绑定的变量 崩溃文件分析
webtool:start(). 原子
使用单引号括起来的字符也是原子
这使得原子可以以大写字母开头，或者带有空格
&amp;#39;a&amp;#39; = a. %a &amp;#39;Monday&amp;#39;. &amp;#39;an atom with spaces&amp;#39;. 列表</description></item><item><title>Efficiency Guide：关于 Erlang 效率的 8 个迷思</title><link>https://blog.caoyue.me/post/the-eight-myths-of-erlang-performance/</link><pubDate>Wed, 18 Mar 2015 16:57:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/the-eight-myths-of-erlang-performance/</guid><description>Premature optimization is the root of all evil. -- D.E. Knuth 过早的优化是万恶之源. -- D.E. Knuth 渣翻译，且作读书笔记 :)
原文：The Eight Myths of Erlang Performance
迷思 1：Funs 很慢 funs 曾经是比较慢，不，应该说是特别慢，甚至比那个 apply/3 还慢。因为以前我们都是用一堆的语法糖啦，普通的元组啦,还有 apply/3 啦加上我们的奇技淫巧来实现的。
不过这些都是老黄历了，在 R6B 我们给了它专有的数据类型，并且在 R7B 做了更牛逼的优化，现在它的调用消耗已经降低到
本地调用和 apply/3 之间了。
不靠谱的 Note : 这里的 funs 应该是包含了 anonymous function 和 F = fun FunctionName/Arity; F(Arg1, Arg2, ..., Argn) 这些调用方式，在调用效率上这两种应该是基本等价的 在 OTP R5 和更早之前的版本中，funs 使用元组来表示，在之后的版本中有了专有的数据结构和优化1 对于参数个数已知的函数，M:F([Arg1, Arg2, &amp;hellip; , Argn]) 的调用优于 apply 使用 apply 调用的函数编译器无法优化，同时许多分析工具也无法分析其细节2 迷思 2：列表推导很慢 列表推导曾经是用 funs 来实现的，当然参照第一点，你懂的。</description></item><item><title>关于 Erlang 的一些想法</title><link>https://blog.caoyue.me/post/about-erlang/</link><pubDate>Mon, 16 Mar 2015 13:59:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-erlang/</guid><description>断断续续学习和使用 Erlang 几个月了，感觉跟之前看待这门语言有了点变化，还是挺有意思的。
作为初学者可能理解不太准确，但有些东西还是可以记录一下。
关于函数式编程 刚开始从其他语言转移到函数式语言的时候还害怕所谓的思维转换，实际上担心有点多余
入门并不难，能理解把循环写成尾递归的过程就基本没什么问题了
更少的心智负担，不再需要考虑是传值还是传引用，以及糟糕的副作用
在某些问题上更接近思维过程，不需要关心怎么做，只需要关心做什么
比如 erlang 的 quicksort 可以这么写（注意这并不是高效的写法）：
qsort([]) -&amp;gt; []; qsort([Pivot | T]) -&amp;gt; qsort([X || X &amp;lt;- T, X &amp;lt; Pivot]) ++ [H] ++ qsort([X || X &amp;lt;- T, X &amp;gt;= Pivot]). 关于 Erlang 语法简单 没有大量的复杂的概念，不像某些《Thinking in XXXX》，看完巨厚一本书你发现自己还是啥也不懂 没有大量的奇技淫巧 大概看了一个多月，就基本可以把 ejabberd 代码从头到尾过一遍了 多看多用，我自己入门看的 《Erlang Programing》 pattern match 用过才知道有多好用 据说效率极其惊人 据说 C# 也要加入了 并发 process 需要并发执行一个任务的时候，最容易想到的就是新开一个 process 去处理 Erlang 的 process 是轻量的，开启和关闭消耗也小，不需要操心各种并发问题 避免锁 实际上开始写命令式代码的时候，我倒是不怎么担心死锁，担心的反而是应该在哪里加锁…… Erlang 的并发模型没有试图去解决锁的问题，而是从根源避免了它，那就是根本不允许全局变量共享（当然你需要共享，可以使用 ETS 或者外部数据库） 对我而言，这种做法减轻了不少心智负担 鼓励崩溃和热更新 写代码的时候 Server 不用不停重启刷新的感觉太好 效率 入门快</description></item><item><title>Erlang/OTP Supervisor : one-for-one and simple-one-for-one</title><link>https://blog.caoyue.me/post/supervisor-simple-one-for-one/</link><pubDate>Tue, 20 Jan 2015 14:45:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/supervisor-simple-one-for-one/</guid><description>Supervisor 的四个 Restart Strategy 中，关于 one for one 和 simple one for one , 虽然很多地方都说 simple one for one 是 one for one 的简化版，但两者之间还是有一些不同。
1. 先来看一个简单的 one for one 和 simple one for one 的例子 one for one
init(_Args) -&amp;gt; {ok, {{one_for_one, 1, 60}, [{call, {call, start_link, []}, permanent, brutal_kill, worker, [call]}]}}. simple one for one init(_Args) -&amp;gt; {ok, {{simple_one_for_one, 0, 1}, [{call, {call, start_link, []}, permanent, brutal_kill, worker, [call]}]}}.</description></item><item><title>ejabberd: Apple Push Notification Service</title><link>https://blog.caoyue.me/post/ejabberd-apns/</link><pubDate>Thu, 01 Jan 2015 16:33:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-apns/</guid><description>主要是通过 hook ejabberd 的离线消息处理，从而实现针对离线消息进行推送
1. Hook offline message 记录 device token
这一步没啥好说的，iOS 连接到 APNs 后获取到 device token，发给服务器，服务器负责维护好对应关系即可。
注意客户端退出时清理掉相应记录。
在 ejabberd 中新增一个模块，注册 offline_message_hook，大致如下：
start(Host, Opts) -&amp;gt; ?INFO_MSG(&amp;#34;Starting mod_push_service&amp;#34;, []), register(?MODULE, spawn(?MODULE, init, [Host, Opts])), ok. init(Host, _Opts) -&amp;gt; ejabberd_hooks:add(offline_message_hook, Host, ?MODULE, send_notification, 10), ok. stop(Host) -&amp;gt; ?INFO_MSG(&amp;#34;Stopping mod_push_service&amp;#34;, []), ejabberd_hooks:delete(offline_message_hook, Host, ?MODULE, send_notification, 10), ok. send_notification(From, To, Packet) -&amp;gt; dosomething. 2. Implement APNs 从 Apple 获取推送证书</description></item><item><title>ejabberd-MAM</title><link>https://blog.caoyue.me/post/ejabberd-mam/</link><pubDate>Tue, 23 Dec 2014 15:46:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-mam/</guid><description>MAM - Message Archive Management 1. Message Archive Archiving
archived tag &amp;lt;message to=&amp;#39;juliet@capulet.lit/balcony&amp;#39; from=&amp;#39;romeo@montague.lit/orchard&amp;#39; type=&amp;#39;chat&amp;#39;&amp;gt; &amp;lt;body&amp;gt;Call me but love, and I&amp;#39;ll be new baptized; Henceforth I never will be Romeo.&amp;lt;/body&amp;gt; &amp;lt;archived by=&amp;#39;juliet@capulet.lit&amp;#39; id=&amp;#39;28482-98726-73623&amp;#39; /&amp;gt; &amp;lt;/message&amp;gt; 2. Querying Filtering
by jid &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;juliet1&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;with&amp;gt;juliet@capulet.lit&amp;lt;/with&amp;gt; &amp;lt;/query&amp;gt; &amp;lt;/iq&amp;gt; by time &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;juliet1&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;start&amp;gt;2010-06-07T00:00:00Z&amp;lt;/start&amp;gt; &amp;lt;end&amp;gt;2010-07-07T13:23:54Z&amp;lt;/end&amp;gt; &amp;lt;/query&amp;gt; &amp;lt;/iq&amp;gt; by max number by uid of message &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;q29303&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;start&amp;gt;2010-08-07T00:00:00Z&amp;lt;/start&amp;gt; &amp;lt;set xmlns=&amp;#39;http://jabber.</description></item><item><title>ejabberd Login module</title><link>https://blog.caoyue.me/post/ejabberd-login/</link><pubDate>Tue, 16 Sep 2014 15:45:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-login/</guid><description>懒得贴代码，画个渣图看下好了。
P.S 从图上可以看出 XMPP 确实是细（fán）致（suǒ）之极了，考虑到在移动设备上的使用，这样的效率肯定是无法接受的。
对特定的服务来说，没有必要做如此多的交互步骤，考虑做一些简化。
Update: 详细的 login 流程 gist d0ec83e9aa3c1899287d</description></item><item><title>Thoughts on Erlang and ejabberd</title><link>https://blog.caoyue.me/post/thoughts-on-erlang-ejabberd/</link><pubDate>Sun, 03 Aug 2014 18:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/thoughts-on-erlang-ejabberd/</guid><description>分析 WhatsApp 架构的时候提到了他们使用的 Erlang + ejabberd 架构。看起来非常神奇，但感觉想要直接搬过来也有一些问题。
Erlang 优秀的工程师
Erlang 看起来语法简单、函数式编程、并发能力强，但就是——会的人太少了，连 Facebook 都找不到足够的优秀 Erlang 程序员，这是为什么呢……反正我们 HR 表示目前连投简历的人都没有 XD 语言本身
刚接触 Erlang，只能说下初步的感受，也有可能是见识不及，权当一看。 语法简单，特性少。很难说到底是优点还是缺点。Erlang 的语法可能一页纸就能写完。但是带来的是「我应该怎么开始？」这样的问题 学习成本。无论鼓吹者宣扬函数式多么好，语言始终是用来解决问题的。Java 再烂依然大把公司用得很 happy 。大部分程序员是务实的，只有能带来好处才会去原因学习。但是对习惯了面向对象命令式编程的程序员来说，学习和思维转换的成本可能根本比带来的好处要大得多。Golang 比 Erlang 火不是没有理由的 数据类型。比如不存在字符串而是使用 List ，不管从性能或是直觉上来说，总觉得有那么点奇怪 数据抽象能力。用 Erlang 开发的复杂应用实在看得头疼，数据抽象能力弱好处是灵活，但导致的后果就是代码里到处充斥着不知道意义的 tuple 和 record，它们之间可能还层层嵌套，让我感觉脑子时刻准备 StackOverflow 和其他语言的交互。Erlang 处处透露着一股高冷范儿，比如独特的错误恢复机制，自实现的进程等等，很难做到和其他语言合群。但是在自己的领域里，Erlang 做得足够好。 XMPP 协议 XMPP 协议实在是太「重」了！XMPP 协议基于 XML ，很大的问题是信息冗余太大，传输数据的很大部分（一般超过 60%）是协议相关，其中既有协议本身繁冗的关系，也有 XML 的原因。
对移动设备来说这将是个很大的问题——更多的流量消耗、以及相关的电量、网络效率等等。 XMPP 协议的另一个问题在于扩展的复杂。XMPP 协议本身已经定义了一大堆协议流程，如果想要在基础之上扩展，将会非常麻烦。
基本上使用 XMPP 协议的服务最后都会改换成自定义协议（比如 WhatsApp），也不是没有原因的。 想要快速开发 Erlang + ejabberd 还是不错的，XMPP 协议本身很开放和完善，各种平台的实现也很多，用来快速原型还是不错的。但是想要实现深度的定制和优化可能就需要更多的时间和精力了，尤其对于移动平台来说。</description></item><item><title>WhatsApp 的一点分析</title><link>https://blog.caoyue.me/post/whatsapp-and-erlang/</link><pubDate>Fri, 01 Aug 2014 18:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/whatsapp-and-erlang/</guid><description>最近的项目需要做一个跨平台的 IM 服务，想要参考下其他项目的架构。国内分享不多，微信基本没有参考价值，毕竟 QQ 的积累在那。陌陌从招聘及据网上抓包的内容看是 XMPP 协议，看起来可能是 Java 的 openfire 之类的 XMPP 路线。
国外的分享稍微多一些，像 WhatsApp 每年都会做一些相关的分享，看起来有些参考价值。
WhatsApp 目前的数据 月用户约为 4.65 亿 每天有 190 亿 消息进站/ 400 亿消息出站 6 亿图片,2 亿音频, 1 亿视频 峰值并发连接为 1.47 亿 消息峰值为每秒 34.2 万进站/ 71.2 万出站 节日期间流量更加惊人 支撑这些数据的硬件 约 550 台服务器 约 150 台 chat server, 可以支持 1.5 亿连接 约 250 台 mms 服务器 数据服务器内存为 512 GB，标准节点是 64 GB 除了视频，其他数据都存储在 SSD 上 超过 11000 个核心 Mnesia 使用了约 2TB 的内存 服务端架构 几乎全部使用 Erlang (经过了自己的改造) 服务器使用的是 FreeBSD 9.</description></item></channel></rss>