<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="如此生活三十年"><meta name=author content="caoyue"><title>且听疯吟 / Posts</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry><div class=title><a href=https://blog.caoyue.me/post/project-timeline/>Project Timeline</a></div><div class=content><p>做了一个同步微博、Twitter 和 Rss Feed 到本地的工具，方便保存和查看自己的数据，以及用自己的数据做一些好玩的事。</p><hr><p><strong><a href=https://github.com/caoyue/MyTimeline>MyTimeline</a></strong></p><ul><li><p>聚合分散在各个网站上的 Timeline<br>Support:</p><ul><li>Rss Feed</li><li>Twitter Oauth</li><li>Weibo Oauth</li></ul></li><li><p>同步发送消息到第三方<br><a href=http://i.caoyue.me/update>/update</a><br>Support:</p><ul><li>Twitter</li><li>Weibo</li></ul></li><li><p>按日期查看过往记录<br><a href=http://i.caoyue.me/past>/past</a></p></li><li><p>对所有记录的统计图表<br><a href=http://i.caoyue.me/statistic>/statistic</a><br>Support：</p><ul><li>按时段统计</li><li>按月份统计</li><li>按分类统计</li></ul></li></ul><p><strong>TODO</strong></p><ul><li>其他第三方支持</li><li>搜索</li><li>Other&mldr;</li></ul><p><strong>Tools</strong></p><ul><li>Linux</li><li>Python</li><li>Web.py</li><li>Nginx/Gunicorn</li><li>MySql</li><li>Google Chart</li></ul><p><strong>Demo</strong></p><ul><li><a href=http://i.caoyue.me>Demo</a></li></ul><p><strong>License</strong></p><ul><li>MIT</li></ul><p><em>Feel free to give me some feedback:)</em></p></div><div class=tags><ul class=info><li>2013-07-30</li><li><a href=https://blog.caoyue.me/tags/python>#python</a></li><li><a href=https://blog.caoyue.me/tags/project>#project</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/goodby-google-reader/>Goodbye Google Reader</a></div><div class=content><p>Google Reader 关闭了。<br>重度拖延症的坏处就是直到这两天才开始寻找替代品。不考虑自建服务了，抓取和存储、搜索都成问题，跨平台支持也少有做好的。<br>不出意外就在目前大热的线上服务 Feedly 和 Digg Reader 中选了。<br>遗憾的是基本没有一家能完全满足需求——也许也只是在强求另一个 Google Reader 的完美复制品罢了。但是残缺不全的功能——基础的搜索都没有、极低的抓取频率确实也很难让人满意。</p><p>那么 Google Reader 到底好在哪呢？<br>从 Google Reader 出来之后其他 RSS 订阅服务基本都死气沉沉了就可想而知了。</p><p>我个人的体会：<br>1、界面功能简洁实用。现在大热的 Feedly 到 Digg Reader 哪个不是借鉴了 Google Reader 的功能和界面？<br>2、搜索，比起手动同步到 Evernote 什么的，只要你记得在 Google Reader 里面看过，搜索就行了。而这些结果天生就是被组织过的——这才是符合我需要的个性化搜索啊！<br>3、被 Google 砍掉的社交功能，这是我认为 Google 做过的最好的社交产品，可惜了。比如可以订阅别人的分享，很容易发现一些有趣的东西。看大牛今天看了什么内容不比听他们闲话家常有意思么？<br>4、Google 的强大抓取和存储。对比 Feedly 和 Digg Reader 很明显，Google 的抓取频率要高得多。而一旦被抓到，这些条目都会存储在 Google 的服务器上，不用担心网站会消失。而且方便的加星和 Tag 可以很好的组织知识库。<br>5、算法推荐排序。Google Reader 有一个神奇排序，会根据你的阅读历史，条目 like 人数等等因数来排序。据说有人用 Google 的精准推荐来做和谐订阅搜集……<br>6、Google 的稳定服务，曾经我们都以为 Google 永远是可靠的……</p><p>就算 Google Reader 拥有如此高的用户粘性和活跃度，它还是死了。<br>虽然社交搜索很热门，也许是未来的趋势。但是并不是非此即彼，我们总需要一个空间来过滤、积累和整合信息。<br>Google 内部限制死了 Google Reader 的发展，使它所做过的一系列有意思的扩展最后都为他人做了不那么好看的嫁衣，但愿 Google Reader 的死去能让 RSS 更活跃，也算功德一件了。</p><p>Goodbye, Google Reader!</p></div><div class=tags><ul class=info><li>2013-07-02</li><li><a href=https://blog.caoyue.me/tags/life>#life</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/reference-in-csharp/>Reference in CSharp</a></div><div class=content><p>起因是 V2EX 的一个<a href=http://v2ex.com/t/74234>帖子</a>.<br>C++ 中引用是一个很基础但是也很容易忽略的问题，那么在 C# 中呢？看下面的 Gist.</p><p><code>gist 5898137</code></p><h3 id=分析>分析</h3><p>C# 中引用类型参数是按引用(即指针地址)来传递的，所以我们使用第一个 Swap 方法——结果是 a 和 b 的值没有变化。<br>再使用 ref 试试，OK，a 和 b 的值交换了。</p><p>再看没有使用 ref 的 Swap 方法。<code>temp = a</code> 实际上是令 temp 形参作为 Swap 函数的局部变量，即在栈上开辟空间存储了实参 a 指向的堆地址（形参 a 和 b 同理）。<br>操作完成后，可以看出，仅仅是在栈上的形参 temp、a、b 所存储的堆地址发生了改变，而原实参 a、b 所存储的堆地址并没有发生变化。</p><h3 id=c-的引用传递和值传递>C# 的引用传递和值传递</h3><p>引用类型作为参数时：</p><ul><li><p>在修改变量本身时，结果类似于值传递，即不会改变传递前的变量的值，换句话说就是值传递传的是对象的值拷贝，而引用类型参数的值实际上就是其指向的堆对象的指针地址<br>即值传递传的是对象的值拷贝，函数内参数对象是调用时传递的对象的栈中对象的拷贝。</p></li><li><p>在修改变量的属性或字段时是引用传递，会影响到传递前的变量的值<br>如代码中，如果交换 a 和 b 的成员的值，则会修改实际对象的值。比如 <code>SwapValue</code> 方法可以成功交换。<br>这是因为形参 a 指向了堆中对象，修改其字段值实际上也就修改了该对象的字段，而实参 a 和 形参 a 指向的是同一对象，所以也就修改了实参 a 的值</p></li><li><p>参数使用了 ref 后，才是引用传递。不管修改变量本身还是修改变量的属性或字段，都会影响到传递前的变量的值<br>因为使用 ref 后，传递了实参 a 自身在栈上的地址而不是堆中对象的地址（即 C/C++ 中指针的指针）。因此改变形参 a 实际上就相当于改变了实参 a。同时通过操纵引用可以间接操纵 a 的字段。</p></li></ul><h3 id=other>Other</h3><ul><li>Stack 堆栈，Heap 托管堆</li><li>事实上关于引用传递和值传递这两个概念实际上没有很好的定义，反而容易产生误解</li><li>一般情况下可以将 C# 的引用理解为指针，但是实际上它们还是有区别的</li></ul><p>P.S. 如果你使用 ReSharper 的话，你会发现第一个 Swap 方法中 ReSharper 提示 a 和 b <code>value assigned is not used</code>，交换变量的三行代码其实都可以 Remove。</p><hr><h4 id=update>Update</h4><p>看起来好像解释的更不清楚了<br>关于所谓的「引用传递」和「值传递」，其实大可不必纠结这个名称，弄清楚这些是怎么作用的就好</p><p>感觉变成了「看了一些容易误解的技术文章，然后写了一些更容易误解的文章」的循环 😅</p></div><div class=tags><ul class=info><li>2013-07-01</li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/refresh-windows8/>Refresh Window 8</a></div><div class=content><p>Windows 8 的 Refresh Windows 8 还是挺好用的。之前安装的 Visual Studio 出了问题弄得环境一团糟，而 VS 附带的一大堆没用的东西一个个卸载起来实在是麻烦，索性直接 Refresh 了。<br>Refresh 是需要安装盘的。如果只有 ISO 镜像而没有安装盘，可以用下面的方法：</p><ol><li>提取 Windows 8 镜像中 sources 下的 install.wim 放到比如 <code>E:\Install</code> 下</li><li>以管理员身份运行的命令提示符中键入下面的命令回车运行<br><code>reagentc /setosimage /path E:\sources /index 2</code></li></ol><p>Refresh 之后不需要重新激活，而且所有系统和用户设置（不包括磁贴布局）会保留。但是所有安装在系统分区的程序（包括驱动）将会丢失，注册表也不会被备份，依赖注册表的程序可能无法运行。而 Metro Apps 会自动重新安装。完成后会有一份被删除的程序的列表放在桌面上。<br>整个过程大概 10 分钟完成。完成后记得在磁盘清理中删除旧的系统文件。</p></div><div class=tags><ul class=info><li>2013-06-17</li><li><a href=https://blog.caoyue.me/tags/life>#life</a></li><li><a href=https://blog.caoyue.me/tags/windows>#windows</a></li></ul></div></div><nav class=pager><a class=pre href=/posts/page/4/>Previous</a></nav></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>