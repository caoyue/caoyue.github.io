<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 且听疯吟</title><link>https://blog.caoyue.me/posts/</link><description>Recent content in Posts on 且听疯吟</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>i@caoyue.me (caoyue)</managingEditor><webMaster>i@caoyue.me (caoyue)</webMaster><lastBuildDate>Wed, 19 Jan 2022 08:39:00 +0000</lastBuildDate><atom:link href="https://blog.caoyue.me/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>关于微软收购动视暴雪</title><link>https://blog.caoyue.me/post/thoughts-about-Microsoft-purchase-of-Activision-Blizzard/</link><pubDate>Wed, 19 Jan 2022 08:39:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/thoughts-about-Microsoft-purchase-of-Activision-Blizzard/</guid><description>这是一个初听很震撼，细想好像没什么毛病的收购。
不管是作为十多年暴雪全家桶玩家，还是单纯作为随着电子游戏成长起来的一代，或者说即将成为元宇宙的第一波韭菜，各种意义上都算是见证历史了。
感觉几个有意思的点：
🤑 687 亿美元，现金 怎么说呢，最近各种新闻也是频繁刷新我对金钱数量的认识了
恒大：和我的债务比起来就是个弟弟
💰 只用了约一半现金储备 什么叫财大气粗啊~
💸 687 亿美元大约相当于整个网易市值，约是索尼市值的一半 Phil Spencer 是真的厉害，毕竟能赚钱的人很多，但是能让老板一下子掏出来近 700 亿美刀的人……
🎮 收购完成后，游戏业务微软排到了第三，第一是腾讯，第二是索尼 玩家：你有什么拿得出手的大作吗？
企鹅：啊，没有啊。
玩家：你有自己的硬件平台吗？
企鹅：啊，没有啊。
玩家：你有自己的平台吗？
企鹅：啊，没有啊。
玩家：那你凭什么第一？
企鹅：sorry，会赚钱就是为所欲为。
📈 收购消息传出后，动视暴雪股票暴涨，索尼大跌，任天堂微涨，育碧 EA 双双上扬 只有索尼受伤的世界达成了~
🤷‍♂️ 今夜大量玩家跪在微软门口，他们手上举着“救救魔兽”“救救星际”“救救守望”“风暴要火”……最后只有一位举着“暗黑不朽上线”的玩家被保安拖走了，因为微软没有手机。 虽然微软没有手机，但是现在他们有糖果传奇了
想想 Windows 11 刚上线不久的 WSA，所以这也在你的计划之中吗阿软！
😉 这波啊，利好元宇宙 请问核聚变和元宇宙的共同点是什么：
永远离我们还有五十年~
最后，救救 Wow！</description></item><item><title>夜晚的潜水艇-陈春成</title><link>https://blog.caoyue.me/post/submarine-at-night/</link><pubDate>Sun, 05 Sep 2021 22:13:44 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/submarine-at-night/</guid><description>夜晚的潜水艇-陈春成 对我而言，这是一本难得的能带来纯粹的愉悦阅读体验的书了。
阅读这本书，灵魂好像被塞进一艘参杂着博尔赫斯的诗句、古老深山中炼丹炉的烟气、苏联红砖房里的单簧管、漂浮着纤毫毕现的隐秘心绪的潜水艇，在斑驳静谧的天空、大地和海底游弋。
放下书本，灵魂抽离而出，从防盗窗的空隙，钻回钢铁水泥的躯壳。
但至少，在某一个夜晚，有一艘蓝色的潜水艇，和一段奇异而愉悦的旅程。
在朋友圈里安利了这本书 一个朋友问我缘由，我说因为……好看，朋友玩笑表示毫无说服力。 在我看来读书是一件很个人的事情，你无法像吃药那样通过疗效来证明它的有效性。 何况先入为主的读后感，对旁人很难说有什么用处。 用俗套但有用的话来说，和书的相遇无非是缘 份一道桥。 这只是一个契机，也许错过这次安利，终会有另一次偶遇让你看到它； 也许最后你也不会看或者不喜欢这本书。 椋鸟不一定会找到属于自己的灰烬之歌。 对社会动物来说，生活大概率并不会因此有什么影响。 那么，补上这篇无用的 算不上理由的理由 读后感，送给这个朋友吧😂</description></item><item><title>鼠疫-加缪</title><link>https://blog.caoyue.me/post/La-Peste/</link><pubDate>Sun, 16 May 2021 22:17:20 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/La-Peste/</guid><description>一点介绍 一个关于鼠疫爆发下，形形色色人们展现出的绝望、贪婪、疯狂，以及勇气和良知的故事。
关于作品 我看的这个版本，表述有点拖沓，缺乏一点文学上的趣味性。
不知道是译者的缘故还是原文如此。当然，不影响整个作品的光芒。
向来对外国人名的“脸盲”，对这些国外作品往往很难沉下心来品味。
但即使忽略具体行文，单纯去看整个故事，依然能感受到那种力透纸背的沉重。
习惯了文学作品中的“装腔作势”，才更能察觉到荒诞中的真实、中性和理智。
一点感想 困境下的贪婪与疯狂，勇气与良知，永远存在，重复上演。
不管困境来源于鼠疫、法西斯还是病毒。
不管在世界上的哪一个角落。</description></item><item><title>Open git repository with browser in powershell</title><link>https://blog.caoyue.me/post/open-git-repository-with-browser-in-powershell/</link><pubDate>Thu, 22 Jun 2017 09:16:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/open-git-repository-with-browser-in-powershell/</guid><description>最近沉迷于 vscode 和 powershell 不能自拔，真的是太好用了~
顺便撸了一个小功能，用来直接在 powershell 中用浏览器打开对应 git repository 的地址
食用方法：
在 powershell 中输入 code $PROFILE 来编辑 profile (或者你也可以使用其他的编辑器~
将以下内容添加到 profile 文件结尾并保存
function Open-GitWeb { $r = git remote -v | Select-String -Pattern &amp;#34;(https:\/\/|git@)(?&amp;lt;git&amp;gt;.*)\.git&amp;#34; if ($r.Matches.Length -gt 0) { $t = &amp;#34;https://&amp;#34; + ($r.Matches[0].Groups | Where-Object {$_.Name -eq &amp;#34;git&amp;#34;}).Value.Replace(&amp;#34;:&amp;#34;, &amp;#34;/&amp;#34;) Write-Host &amp;#34;gh: openning &amp;#34;,$t,&amp;#34;...&amp;#34; -ForegroundColor &amp;#34;green&amp;#34; Start-Process $t } else { Write-Host &amp;#34;gh: not a git repository or origin not set correctly.</description></item><item><title>一个 ASP.NET MVC HtmlHelper 的 tricks</title><link>https://blog.caoyue.me/post/asp-net-mvc-htmlhelper/</link><pubDate>Wed, 31 May 2017 01:47:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/asp-net-mvc-htmlhelper/</guid><description>问题 先看下面一个简单的 ASP.NET MVC 5 的 demo：
model
public class TestModel { public List&amp;lt;int&amp;gt; Ints { get; set; } } controller
public ActionResult Index() { var testModel = new TestModel(); return View(testModel); } [ActionName(&amp;#34;Index&amp;#34;), HttpPost] public ActionResult Post(TestModel testModel) { return View(testModel); } view
@model Test.Controllers.TestModel &amp;lt;form action=&amp;#34;@Url.Action(&amp;#34;Index&amp;#34;)&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; @for (var i = 0; i &amp;lt; 10; i++) { @Html.TextBoxFor(model =&amp;gt; model.Ints[i]) } &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;Submit&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; 有没有看出什么问题？</description></item><item><title>写模板时的一些细节</title><link>https://blog.caoyue.me/post/html-details/</link><pubDate>Sun, 28 May 2017 03:14:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/html-details/</guid><description>最近从 farbox 迁移到了 bitcron，由于 bitcron 不再支持 html 的模板，只好用 jade 重写了一次
顺便整理了下之前写这个模板时碰到的一些细节，也许用得上吧
lang 国内很多网站都是不写这个 lang 属性的，比如 baidu。 而大部分国外网站都会写，Twitter 甚至为每一条推文都加上了 lang 属性
那么写上 lang 属性有什么意义呢？顾名思义，lang 属性声明了内容的语言。更详细的来说，比如:
浏览器可以根据 lang=en 知道当前网页是英文，于是可以问你是否需要开启翻译功能
Chrome 在版本 21 之后，开始根据 lang 属性来应用不同的默认字体。这意味着你可以为英语页面和中文、日文等页面设置不同的默认字体
这个选项没有出现在默认设置里，你可以使用这个 Chrome 扩展来设置：Advanced Font Settings
页面的 lang 属性会影响字体的显示
比如 思源黑体 中同时包含了中文字体和日文字体，我们知道日文中一部分汉字是相同的，为了节省空间，所以它们被放在了“同一个位置”上
然而即使是同样的字，也可能在字形上存在不同，比如，如果你安装了思源黑体，那么下面同样的字
门类 和 门类
&amp;lt;span lang=&amp;#34;ja-jp&amp;#34; style=&amp;#34;font-family:&amp;#39;Source Han Sans&amp;#39;&amp;#34;&amp;gt;门类&amp;lt;/span&amp;gt; &amp;lt;span lang=&amp;#34;zh-Hans&amp;#34; style=&amp;#34;font-family:&amp;#39;Source Han Sans&amp;#39;&amp;#34;&amp;gt;门类&amp;lt;/span&amp;gt; 显示出来的字形是不一样的，如图：
另外，由于中文字体 fallback 的关系，lang=en 下显示的是 lang=ja-jp 的字形，所以，如果发现网页显示的字形很奇怪，那么看看 lang 属性有没有正确的设置吧~</description></item><item><title>炉石卡牌实现机制的一点猜想</title><link>https://blog.caoyue.me/post/hearthstone/</link><pubDate>Tue, 31 May 2016 18:43:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/hearthstone/</guid><description>假设我们要实现一个炉石的对战机制，要怎么做呢？
并没有游戏开发经验，所以以下都是乱猜加瞎扯~
分类 首先，我们把炉石里的主要元素分成几类：
法术
法术很好理解，一般来说法术包括几个要素
目标 可能是一个目标也可能是多个目标 可能包含一个筛选，比如「对非恶魔随从造成伤害」 效果 可能是给目标一个 buff 或者 debuff，也可能是造成伤害等等 大部分法术都是立即效果 也有一部分法术是触发效果，比如 奥秘，比如 本回合随从生命值不会降低到 1 点以下 武器
英雄
英雄技能可以看作一个法术 随从
随从本身具有的属性
花费/攻击/血量 类别： 恶魔/鱼人/野兽 其他
我们以 https://hearthstonejson.com/ 上的卡牌火车王的 Json 数据为例： { &amp;#34;id&amp;#34;: &amp;#34;EX1_116&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Leeroy Jenkins&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;&amp;lt;b&amp;gt;Charge&amp;lt;/b&amp;gt;. &amp;lt;b&amp;gt;Battlecry:&amp;lt;/b&amp;gt; Summon two 1/1 Whelps for your opponent.</description></item><item><title>晒书：《魔兽世界编年史》</title><link>https://blog.caoyue.me/post/wow-chronicle/</link><pubDate>Wed, 06 Apr 2016 22:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/wow-chronicle/</guid><description>从《凯恩之书》开始就期待了，终于出了编年史
不负责任的猜想是暴雪觉得魔兽世界这个剧情坑太大太多懒得圆吧
还好终于出了
中亚还是挺快的，原来预计发货时间排到 6 月，都想去美亚订了
幸好还是提前发货了
大部分是为信仰充值吧
不过这次编年史的内容还是挺有趣的
有很多剧情上的填坑和重新解读
当然也少不了暴雪粑粑的吃书
比预计的要薄一点，但还是挺有分量的
这只是 Volume Ⅰ，估计后续还会有几本（SHUT UP AND TAKE MY MONEY!
印刷质量还行，但也没有到惊艳的程度。
意外的发现 Printed in China =-=
英文看得还是有点费力……
慢慢啃吧，有什么好玩的内容会更新在这里（大概吧~
For the Horde!</description></item><item><title>使用 Travis CI 自动部署 React Native 项目 （iOS 篇）</title><link>https://blog.caoyue.me/post/react-native-travis-ci-ios/</link><pubDate>Wed, 09 Mar 2016 15:21:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/react-native-travis-ci-ios/</guid><description>编译、测试、打包、部署这一系列的操作实在是太麻烦而且容易出错漏，能自动化的东西我们就没必要手动去点。端着咖啡悠哉地等着叮的一声，安装包出现在面前，这才是我们想要的
花了点时间，把正在进行的 React Native 项目的自动部署完善了一下，实现了通过 Travis CI 自动编译测试，并打包成 ipa 发布到 FTP 的整个流程
现在只要 Push 到 Github 上，等到 Travis CI 运行完成，就直接可以拿到 ipa 包安装测试了
准备工作：
首先你需要一个 Github 账户
Travis CI 连接 Gtihub 后，会自动检查根目录下带有 .travis.yml 的项目
关于 Travis CI 的功能和文档，请参考 https://docs.travis-ci.com/
这里给出一个 React Native 项目的 yml 文件示例：
language:objective-cosx_image:xcode7.1xcode_project:ios/MyApp.xcodeprojxcode_scheme:MyAppenv:matrix:- SPEC=spec1before_install:- ./scripts/decrypt_key.sh- ./scripts/add_key.sh- brew updateinstall:- brew reinstall node flow watchman xctool- npm install -g react-native-clibranches:only:- masterscript:- ./scripts/release.sh首先设置项目编译环境： 包括 language 和 要使用的编译镜像 osx_image，并指定项目文件和编译的 scheme
证书加密： 由于 iOS 打包过程需要一些证书密钥，这些是无法公开 Push 到 Github 的</description></item><item><title>react and react native</title><link>https://blog.caoyue.me/post/react-and-react-native/</link><pubDate>Tue, 27 Oct 2015 20:20:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/react-and-react-native/</guid><description>最近了解了下 react 和 react native，感觉看到了一条成为「Full-stack Developer」的捷径啊（雾
React 消息同步
不管是 Web 还是 Native 应用，一个很麻烦的问题就是保持某个 Message 在不同 View 之间的状态同步。
比如，收到一条消息，需要在未读标签显示状态和数字，然后未读列表中插入一条消息记录。
阅读消息后，需要从未读中去掉这条记录，同时在已读中新增一条记录，还不能忘了将未读数字减去。
我们是怎么处理这种情况？
要在接收消息的 handler 中判断各个 View 当前的状态，然后根据对应的状态写不同的处理代码，阅读消息同理。当然高端点的可能自己搞个 Manager 之类的东西去对这些逻辑进行管理。
但是，并没有什么用。一旦业务复杂，处理和 Debug 起来就很麻烦了。看上去未读是 1，点进去发现是空，这种场景想必见得也不少了。
还记得很久之前我们怎么写页面的吗？（多久？大概到 ASP 吧=-= 那时候我们没有这么多烦恼。因为我们是这么干的。不管什么操作，ok，刷新页面，可以保证所有状态都是正确的，so easy!
React + Flux 所做的正和我们很久之前的做法有点像。数据更新了？重新渲染一遍 View 不就好了。
但是将整个 DOM 重新渲染一遍是开销很大的，当然不可能真的这么做。
所以就有了 Virtual DOM。
其实我们对 View 所做的操作大部分都是修改内容，比如修改某个块里面的文字啦，对某个 list 增删改啦。这些都不需要完全重绘。
React 做到了「智能」去更新 DOM，只改变需要改变的地方。（嗯，就是不相信你能写出高效正确的操作 DOM 的代码，所以我们都帮你写好啦~（雾
组件化
通常我们的页面上的控件都是带有不同的状态的，比如选框是否选中等等。而不同情况下状态可能会根据一些参数去变化，这让一般情况下的组件复用变得很麻烦。
而 React 可以做到类似于函数的给定输入参数，输出固定的状态，可以很方便的实现 Web Components，也不会出现组件状态上的冲突。</description></item><item><title>QQ 是怎么实现快速登录的</title><link>https://blog.caoyue.me/post/how-qq-quick-signin/</link><pubDate>Wed, 09 Sep 2015 18:02:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/how-qq-quick-signin/</guid><description>这个问题之前很好解决，使用浏览器 plugin 即可。
但是随着 Chrome 和 Firefox 都先后放弃了 NPAPI plugin，这一方法也行不通了，而且很多人是很讨厌 plugin 的。
但是在默认禁止了 NPAPI 的 Chrome 版本，QQ 依然可以实现快速登录（一键登录），是怎么做到的呢？
原理 其实不难猜。既然不存在 plugin，无法以此来实现浏览器内和本地客户端的直接通信，那么排除其他的黑科技，有一种很简单的方法可以实现这个效果。
那就是在客户端开一个 Server，在浏览器里面请求这个地址。
理论上这样是可以实现的，至于 QQ 是不是用的这种方法，稍微验证下好了。
验证 找一个有 QQ 快速登陆的页面，比如 mail.qq.com
登陆 QQ 客户端
打开浏览器的 Developer Tools -&amp;gt; Network
刷新页面，观察所有请求的 domain
好明显，这就是我们要找的了
完整请求 url 是这样的
https://localhost.ptlogin2.qq.com:4301/pt_get_uins?callback=ptui_getuins_CB&amp;amp;r=0.22949112393586502&amp;amp;pt_local_tk=-2027291081 看看这个请求的 Response Content
var var_sso_uin_list = [ { account: &amp;#34;xxxxxx&amp;#34;, client_type: 65793, face_index: 0, gender: 1, nickname: &amp;#34;xxx&amp;#34;, uin: &amp;#34;xxx&amp;#34;, uin_flag: xxxxx, }, ]; ptui_getuins_CB(var_sso_uin_list); 很明显是当前登录的用户信息</description></item><item><title>Does Facebook store plain-text passwords?</title><link>https://blog.caoyue.me/post/does-facebook-store-plain-text-passwords/</link><pubDate>Wed, 02 Sep 2015 18:23:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/does-facebook-store-plain-text-passwords/</guid><description>越来越多的网站开始更加关注安全问题了，比如，Facebook 会在你把密码从 abc123 改为 Abc123 的时候的时候提示你
Your new password is too similar to your current password. Please try another password.
很贴心是不是？但是，他们是怎么做到的？难道 Facebook 保存了用户的明文密码么？
编辑距离 计算两个字符串的相似性，或者说「编辑距离」很容易，我们有很多现成的算法和代码。
但是，显然 Facebook 不会傻到存储明文密码，存储的肯定是 hash(&amp;quot;abc123&amp;quot;)。
而字符串中的差别和 hash 结果并不是一一对应的。两个相近的字符串，其 hash 结果可能差别很大。
simhash 可能你听说过 simhash 算法。Google 就是使用这种算法来做网页查重的。
传统的 hash 算法如 md5，一般尽可能要求结果分布均匀，因此，原始字符串的微小变动也会导致 hash 结果出现很大差异。
而 simhash 是一种局部敏感的 hash 算法，选定位数，提取特征，然后对每一段特征值计算 hash，然后将每一段值处理到 simhash 结果，得到最后的 simhash 值。比较海明距离就可以大概知道两个文档的相似度了。
具体的算法懂得不多就不瞎说了……大概可以推测，对于长文档这种方法是有效的，但是对于短文本，如 password 来说，效果可能不会太好。
Facebook 的做法 事实上这个问题好奇的人也很多，Stack Exchange 上有一个回答 http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords，下面有一个自称接触过密码验证这部分代码的人肯定了这个猜测。
我觉得这种做法看起来还是挺合理的。
Facebook 用了一种看起来很「土」的方法，操作方法类似这样：
用户注册，密码 abc123，Facebook 保存了 `hash(&amp;ldquo;abc123&amp;rdquo;) 用户修改密码，提交新密码 Abc123 Facebook 拿到新密码，根据这个密码，生成一堆类似于 ABC123，abc123 这样相近的密码，使用同样的 hash 方法，去和 1 中的 hash 比对，一旦发现有相同的，那么可以判定新密码与旧密码是相似的。 很好的反向思维，不是去计算相似性，而是通过生成一堆相似密码来「暴力」尝试。</description></item><item><title>Joe Armstrong and Erlang</title><link>https://blog.caoyue.me/post/joe-armstrong-and-erlang/</link><pubDate>Sat, 22 Aug 2015 01:14:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/joe-armstrong-and-erlang/</guid><description>无意中翻到 Joe Armstrong 发在 erlang-questions 里的文章，Ways to get started 以及 history of erlang。
如果你不知道 Joe Armstrong 是谁，我们给他的另一个称呼是 the father of Erlang :)
大概没有人比他更有资格写这种文章了吧。
在高手眼中大道至简，我们不一定学的来，但是听听还是很有启发的
随便瞎扯几句
忘掉工具 Forget about git/IDEs/rebar etc.
Forget about the tools
如果没有 IDE，没有自动打包工具，我们怎么编写和运行代码？
记住，shell 和文本编辑器对任何语言都是适用的。
当然我并不觉得这意味着需要放弃 IDE 之类的工具，而是在 get started 的时候，对程序怎么工作的有基本的了解是有好处的。
某种意义上来说，过于复杂的工具链意味着，一旦它没有按照你想象的运行，就需要花费更多的时间去解决它。
rebar!
当然，不能忘了 rebar!
事实上 rebar 已经快要成为 erlang project 的标配了。 Tools like rebar etc are under to automate something but if you don&amp;rsquo;t</description></item><item><title>重命名 Windows 10 账户文件夹</title><link>https://blog.caoyue.me/post/rename-user-folder-in-windows-10/</link><pubDate>Sat, 01 Aug 2015 13:35:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/rename-user-folder-in-windows-10/</guid><description>升级到 Windows 10 之后，很糟心的是通过 Microsoft Account 登录的时候，默认创建的账户文件夹居然不是 Microsoft Account 的 name，明明是 nick@outlook.com，结果创建出来的却是 nic …… 完全不知道这帮人怎么做到的 =-=
不管有没有强迫症，每次看到这个错的名字都实在不能忍，找到个修改的方法
参考了来自 superuser 的解决方法，原文针对的是 Windows 8，不过对 Windows 10 依然有效
原文地址 http://superuser.com/questions/495290/how-to-rename-user-folder-in-windows-8
步骤如下：
用 nic 代表原来的账户名 用 nick 代表新的账户名 下面的操作中用你自己的需求替换 nic 和 nick 1. 创建一个本地管理员账户 Windows 10 中创建本地账户的选项藏得更深了，可以按如下方法操作
打开 Setting 找到 Family &amp;amp; other users 点击 Add someone else to this PC 弹出添加对话框，选择下面的 the person I want to add doesn't have an email address 继续选择 Add a user without a Microsoft Account 填写用户名密码，创建本地账户 点击创建的用户，Change Account Type 为 Administrator 2.</description></item><item><title>XMPP 安全相关</title><link>https://blog.caoyue.me/post/xmpp-security/</link><pubDate>Tue, 07 Jul 2015 18:01:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/xmpp-security/</guid><description>最近又从头看 XMPP 的 RFC1，有时候也考虑如果是自己来设计，会如何做。
之前的印象是 XMPP 的繁琐和低效，现在看来，作为通用的协议，XMPP 确实有做得不错的地方，从头看下来还是有不少收获的。
现在项目告一段落，回头整理下 XMPP 服务端安全方面的一些简单想法，大概想到哪写到哪吧，安全方面懂得不多，欢迎指正。
考虑到安全，我们的初始目标大概包括这些：
与服务端通信安全（不被窃听/篡改） 鉴别用户身份 保护用户数据 TLS TLS2 用于在两个通信应用程序之间提供保密性和数据完整性，是必须开启的。
SASL SASL3 是一种验证用户身份的框架。XMPP 本身没有办法分辨用户身份，必须借助于 SASL 协议。
SASL 协议确定了客户端和服务端沟通的应答机制及传输的编码方法，剩下的就需要自己实现了。
要识别用户身份，你需要在 SASL 的框架下定义和服务端交换的具体身份信息（比如用户名、密码），以及实现身份信息的存储和验证方式，而不需要考虑其他细节。
具体到 XMPP 下 SASL 的验证流程（如果建立了 TLS 连接，此时是在 TLS 连接上的）：
一般不必支持所有的 SASL mechanisms ，选择安全性更可靠的，比如 SCRAM-SHA-1 (尽量不要使用 plain)：
详细登录流程可以参考 ejabberd: Login
SCRAM-SHA-1 SCRAM4（Salted Challenge Response Authentication Mechanism） 是近年才开始使用的更安全的一种加密验证机制，可以很好的在 Server 和 Client 之间做双向的验证，已经有很多的服务开始使用这种方式验证了，比如 MongoDB。XMPP 也在协议中提供了这种方式的说明。
不讨论详细的加密算法细节，客户端验证登录时，大概流程如下：
client 发送想要登录的 username 到 server (即 auth) server 为该 username 生成/查找出 salt（s)，和 iteration count（i）、server nonce (r) 一并发回给 client （challenge，base64 编码） client 使用给定的 salt 和 iteration count 加密持有的 password，发回给 server （如果服务端对该 client 使用的 salt 和 iteration count 是固定的话，可以存储下生成的 client key，从而避免在 client 明文存储密码，会更安全） server 验证结果，如果成功则返回 success，并附上计算值 client 校验 success 中返回的值，通过则证明 server 拥有 client 的验证 end_to_end 如果有非常严格的安全需求，可以考虑 OpenPGP ，XMPP 协议也提供了有限的支持</description></item><item><title>如果 C# 支持 void 作为泛型参数</title><link>https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/</link><pubDate>Fri, 26 Jun 2015 18:54:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/</guid><description>有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的 比如，最近碰到一个问题，简化形式是这样的：
IEnumerable&amp;lt;int&amp;gt; Range(int n) { var i = 0; while (i &amp;lt;= n) { // DoSomething1... yield return i; i++; } } Range(n).ForEach(x =&amp;gt; DoSomething2(x)); void DoSomething2(x) { } 看出问题了么？ IEnumerable 接口是没有 ForEach 方法的，ForEach 是 List&amp;lt;T&amp;gt; 的方法，所以只能写成
```csharp Enumerable.Range(0, n).ToList().ForEach(x =&amp;gt; DoSomething(x)); ``` 但是显然这样就失去了延迟执行的意义了
我们也可以尝试使用 IEnumerable 的 Select 方法，变成这样：
```csharp Enumerable.Range(0, n).Select(x =&amp;gt; DoSomething2(x)); ``` 当然这样也行不通，因为我们的 DoSomething2 方法是 void 类型的
最后只能粗暴的给 DoSomething2 包装一个返回值</description></item><item><title>About Erlang: Records</title><link>https://blog.caoyue.me/post/about-erlang-records/</link><pubDate>Wed, 27 May 2015 13:59:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-erlang-records/</guid><description>1. tuple and record 现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?
-record(test, { a::binary(), b::binary() }). KeyValuePairs = [{a, &amp;lt;&amp;lt;&amp;#34;a&amp;#34;&amp;gt;&amp;gt;},{b, &amp;lt;&amp;lt;&amp;#34;b&amp;#34;&amp;gt;&amp;gt;}]. 很基础的问题，我们这样做：
Result = #test{ a = get_value(a, KeyValuePairs), b = get_value(a, KeyValuePairs) }. 如果 record 有一百个项呢？
重复的写 a = get_value(a, KeyValuePairs) 这样的代码一百次大概会让人怀疑「猿」生吧 :(
虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道
Erlang 的 record 实际上是用 tuple 来表示的，即 #test{a = &amp;lt;&amp;lt;&amp;quot;a&amp;quot;&amp;gt;&amp;gt;, b = &amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;gt;&amp;gt;} 实际上是 {test, &amp;lt;&amp;lt;&amp;quot;a&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;gt;&amp;gt;} 所有在运行时对 record 的操作实际上都是对 tuple 的操作 Result#test.a 实际上是 tuple 的 index 可以使用 record_info(fields, record) 获取 Record 的 fields 信息 所以我们可以这样</description></item><item><title>预排序遍历算法树</title><link>https://blog.caoyue.me/post/mptt-tree/</link><pubDate>Mon, 11 May 2015 21:43:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/mptt-tree/</guid><description>1. 预排序遍历树算法 mptt (Modified Preorder Tree Traversal)1 优点
查询效率高，只需要一次查询即可获得层级结构中某个节点的所有子节点，无需递归查询 缺点
插入、删除、移动节点效率较低 适用
在传统关系数据库中实现层级树结构 读压力 &amp;gt; 写压力， mptt 算法可以提高效率 写压力 &amp;gt; 读压力，使用传统的邻接表 (adjacency list model) 2. 增删查改 Create
假设增加的节点为 c, 该节点前一节点为 p 节点 c 左值为 p 的右值 +1，右值为 p 右值 +2 所有左值大于节点 c 的左值的节点，其左值均 +2 所有右值大于节点 c 的右值的节点，其右值均 +2 写入节点 c 到数据库 SELECT@cRight:=rgtFROMmpttWHEREname=&amp;#39;p&amp;#39;;UPDATEmpttSETrgt=rgt+2WHERErgt&amp;gt;@cRight;UPDATEmpttSETlft=lft+2WHERElft&amp;gt;@cRight;INSERTINTOmptt(name,lft,rgt)VALUES(&amp;#39;c&amp;#39;,@cRight+1,@cRight+2); Read
查询节点 c 的子节点：
查询所有左值大于 c 的左值且右值小于 c 的右值的节点</description></item><item><title>关于 unicode</title><link>https://blog.caoyue.me/post/about-unicode/</link><pubDate>Tue, 28 Apr 2015 11:12:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-unicode/</guid><description>对这些概念头疼了很久，尝试简单的整理下，不确切的地方欢迎指正~
1. Unicode Unicode 是一个字符集，而不是一种编码方案 简单来说 Unicode 是希望给地球上每一个字符一个数字编号，从而解决不同编码之间不统一的问题 Unicode 是没法直接拿来用的，我们使用的是它的编码方案 2. 编码方案 通常使用的 UTF-8，UTF-16 等等都是 Unicode 的编码方案 所谓编码方案就是按一定的规则对 Unicode 的字符编号进行编码 当然不同的编码的同一个字符，最后解析成 Unicode 字符编号都是一样的 3. 字体与 Unicode 计算机使用字符的 Unicode 编号去寻找字体内的字符 字体内部的特殊数据结构存储了 Unicode 编号和字符的对应关系 4. 例子 汉字 月 的 Unicode 编号 10 进制为 26376 Unicode 编号表示为 16 进制 是 U+6708 在 python 中用 u&amp;quot;\u6708&amp;quot; 表示 在 UTF-8 中的编码是 0xE6 0x9C 0x88 ，使用了 3 个 Byte 来表示 5.</description></item><item><title>Erlang Programming 笔记 3</title><link>https://blog.caoyue.me/post/erlang-programming-3/</link><pubDate>Thu, 23 Apr 2015 17:28:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/erlang-programming-3/</guid><description>6. 编译并运行程序 （略） 7. 并发 机制 Erlang 程序由成百上千个 Process 组成，这些 Process 之间可以互发消息 Process 能否接收到或者理解消息是不确定的，要知道结果必须向该 Process 发送消息询问并等待 Process 之间可以互相 Link ，当 Process 消亡时与之相连的 Process 会收到消息 8. 并发编程 并发原语
Pid = spawn(Module, FuncName, Args)
创建一个新的 Process，用于对 Func 求值，并返回该 Process 的 pid Pid ! Message 向指定 Pid 的 Process 发送消息，返回值为 Message 本身 消息发送是异步的，无需等待即可进行其他操作 receive ... end 接收一个发给当前进程的消息 self()</description></item><item><title>Erlang Programming 笔记 2</title><link>https://blog.caoyue.me/post/erlang-programming-2/</link><pubDate>Wed, 22 Apr 2015 17:25:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/erlang-programming-2/</guid><description>4. 异常 抛出异常
显式的 exit(Why) 终止当前 Process 如果当前 Process 未捕获这个异常，则系统会向所有 link 该 Process 的 Process 广播 {'EXIT', Pid, Why} 消息 显式的 throw(Why) 抛出供其调用者捕获的异常 最好是添加注释说明抛出的异常 如何处理由调用者选择，包括忽略 系统错误 erlang:error(Why) try..catch 捕获异常
try/catch 本身会消耗一点性能
推荐的 try/catch 风格
%% 首先对 FuncOrExpressionSequence 求值 %% 如果没有产生异常则顺序进行 Patterm 匹配, 匹配成功后执行后面的表达式 %% 如果有异常抛出, 则顺序匹配 ExPattern(ExceptionType 是 throw、exit、error 中的一个, 默认为 throw) %% after 块中的代码用于清理工作,绝对会执行 %% after 可以省略 try FuncOrExpressionSequence of Pattern1 [when Guard1] -&amp;gt;Expressions1; Pattern2 [when Guard2] -&amp;gt;Expressions2; .</description></item><item><title>Erlang Programming 笔记 1</title><link>https://blog.caoyue.me/post/erlang-programming-1/</link><pubDate>Tue, 21 Apr 2015 17:05:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/erlang-programming-1/</guid><description>1. Erlang 优势 并发和分布式 主流语言使用共享内存模型，类似于 x = x + n 的代码导致了在多核环境下需要小心的处理锁的问题 Erlang 使用消息模型，Process 间不共享数据，从而避免了锁的问题 无锁避免了顺序瓶颈，添加节点到网络更容易 错误处理 多数语言默认认为程序不会出错 Erlang 采用不同的设计决策——注定要出错，那就让他出错，出错后恢复就行了。即 Erlang 程序出错后，会交由更高级的 Process 来处理（重启 Child Process、系列全部终止、重启相关 Process 等等），从而实现对错误的分级和容错处理 同时带来了热更新的好处，进一步保证了可用性 2. 入门 Shell
f(). 会释放所有绑定的变量 崩溃文件分析
webtool:start(). 原子
使用单引号括起来的字符也是原子
这使得原子可以以大写字母开头，或者带有空格
&amp;#39;a&amp;#39; = a. %a &amp;#39;Monday&amp;#39;. &amp;#39;an atom with spaces&amp;#39;. 列表</description></item><item><title>Efficiency Guide：关于 Erlang 效率的 8 个迷思</title><link>https://blog.caoyue.me/post/the-eight-myths-of-erlang-performance/</link><pubDate>Wed, 18 Mar 2015 16:57:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/the-eight-myths-of-erlang-performance/</guid><description>Premature optimization is the root of all evil. -- D.E. Knuth 过早的优化是万恶之源. -- D.E. Knuth 渣翻译，且作读书笔记 :)
原文：The Eight Myths of Erlang Performance
迷思 1：Funs 很慢 funs 曾经是比较慢，不，应该说是特别慢，甚至比那个 apply/3 还慢。因为以前我们都是用一堆的语法糖啦，普通的元组啦,还有 apply/3 啦加上我们的奇技淫巧来实现的。
不过这些都是老黄历了，在 R6B 我们给了它专有的数据类型，并且在 R7B 做了更牛逼的优化，现在它的调用消耗已经降低到
本地调用和 apply/3 之间了。
不靠谱的 Note : 这里的 funs 应该是包含了 anonymous function 和 F = fun FunctionName/Arity; F(Arg1, Arg2, ..., Argn) 这些调用方式，在调用效率上这两种应该是基本等价的 在 OTP R5 和更早之前的版本中，funs 使用元组来表示，在之后的版本中有了专有的数据结构和优化1 对于参数个数已知的函数，M:F([Arg1, Arg2, &amp;hellip; , Argn]) 的调用优于 apply 使用 apply 调用的函数编译器无法优化，同时许多分析工具也无法分析其细节2 迷思 2：列表推导很慢 列表推导曾经是用 funs 来实现的，当然参照第一点，你懂的。</description></item><item><title>关于 Erlang 的一些想法</title><link>https://blog.caoyue.me/post/about-erlang/</link><pubDate>Mon, 16 Mar 2015 13:59:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/about-erlang/</guid><description>断断续续学习和使用 Erlang 几个月了，感觉跟之前看待这门语言有了点变化，还是挺有意思的。
作为初学者可能理解不太准确，但有些东西还是可以记录一下。
关于函数式编程 刚开始从其他语言转移到函数式语言的时候还害怕所谓的思维转换，实际上担心有点多余
入门并不难，能理解把循环写成尾递归的过程就基本没什么问题了
更少的心智负担，不再需要考虑是传值还是传引用，以及糟糕的副作用
在某些问题上更接近思维过程，不需要关心怎么做，只需要关心做什么
比如 erlang 的 quicksort 可以这么写（注意这并不是高效的写法）：
qsort([]) -&amp;gt; []; qsort([Pivot | T]) -&amp;gt; qsort([X || X &amp;lt;- T, X &amp;lt; Pivot]) ++ [H] ++ qsort([X || X &amp;lt;- T, X &amp;gt;= Pivot]). 关于 Erlang 语法简单 没有大量的复杂的概念，不像某些《Thinking in XXXX》，看完巨厚一本书你发现自己还是啥也不懂 没有大量的奇技淫巧 大概看了一个多月，就基本可以把 ejabberd 代码从头到尾过一遍了 多看多用，我自己入门看的 《Erlang Programing》 pattern match 用过才知道有多好用 据说效率极其惊人 据说 C# 也要加入了 并发 process 需要并发执行一个任务的时候，最容易想到的就是新开一个 process 去处理 Erlang 的 process 是轻量的，开启和关闭消耗也小，不需要操心各种并发问题 避免锁 实际上开始写命令式代码的时候，我倒是不怎么担心死锁，担心的反而是应该在哪里加锁…… Erlang 的并发模型没有试图去解决锁的问题，而是从根源避免了它，那就是根本不允许全局变量共享（当然你需要共享，可以使用 ETS 或者外部数据库） 对我而言，这种做法减轻了不少心智负担 鼓励崩溃和热更新 写代码的时候 Server 不用不停重启刷新的感觉太好 效率 入门快</description></item><item><title>Erlang/OTP Supervisor : one-for-one and simple-one-for-one</title><link>https://blog.caoyue.me/post/supervisor-simple-one-for-one/</link><pubDate>Tue, 20 Jan 2015 14:45:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/supervisor-simple-one-for-one/</guid><description>Supervisor 的四个 Restart Strategy 中，关于 one for one 和 simple one for one , 虽然很多地方都说 simple one for one 是 one for one 的简化版，但两者之间还是有一些不同。
1. 先来看一个简单的 one for one 和 simple one for one 的例子 one for one
init(_Args) -&amp;gt; {ok, {{one_for_one, 1, 60}, [{call, {call, start_link, []}, permanent, brutal_kill, worker, [call]}]}}. simple one for one init(_Args) -&amp;gt; {ok, {{simple_one_for_one, 0, 1}, [{call, {call, start_link, []}, permanent, brutal_kill, worker, [call]}]}}.</description></item><item><title>ejabberd: Apple Push Notification Service</title><link>https://blog.caoyue.me/post/ejabberd-apns/</link><pubDate>Thu, 01 Jan 2015 16:33:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-apns/</guid><description>主要是通过 hook ejabberd 的离线消息处理，从而实现针对离线消息进行推送
1. Hook offline message 记录 device token
这一步没啥好说的，iOS 连接到 APNs 后获取到 device token，发给服务器，服务器负责维护好对应关系即可。
注意客户端退出时清理掉相应记录。
在 ejabberd 中新增一个模块，注册 offline_message_hook，大致如下：
start(Host, Opts) -&amp;gt; ?INFO_MSG(&amp;#34;Starting mod_push_service&amp;#34;, []), register(?MODULE, spawn(?MODULE, init, [Host, Opts])), ok. init(Host, _Opts) -&amp;gt; ejabberd_hooks:add(offline_message_hook, Host, ?MODULE, send_notification, 10), ok. stop(Host) -&amp;gt; ?INFO_MSG(&amp;#34;Stopping mod_push_service&amp;#34;, []), ejabberd_hooks:delete(offline_message_hook, Host, ?MODULE, send_notification, 10), ok. send_notification(From, To, Packet) -&amp;gt; dosomething. 2. Implement APNs 从 Apple 获取推送证书</description></item><item><title>ejabberd-MAM</title><link>https://blog.caoyue.me/post/ejabberd-mam/</link><pubDate>Tue, 23 Dec 2014 15:46:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-mam/</guid><description>MAM - Message Archive Management 1. Message Archive Archiving
archived tag &amp;lt;message to=&amp;#39;juliet@capulet.lit/balcony&amp;#39; from=&amp;#39;romeo@montague.lit/orchard&amp;#39; type=&amp;#39;chat&amp;#39;&amp;gt; &amp;lt;body&amp;gt;Call me but love, and I&amp;#39;ll be new baptized; Henceforth I never will be Romeo.&amp;lt;/body&amp;gt; &amp;lt;archived by=&amp;#39;juliet@capulet.lit&amp;#39; id=&amp;#39;28482-98726-73623&amp;#39; /&amp;gt; &amp;lt;/message&amp;gt; 2. Querying Filtering
by jid &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;juliet1&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;with&amp;gt;juliet@capulet.lit&amp;lt;/with&amp;gt; &amp;lt;/query&amp;gt; &amp;lt;/iq&amp;gt; by time &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;juliet1&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;start&amp;gt;2010-06-07T00:00:00Z&amp;lt;/start&amp;gt; &amp;lt;end&amp;gt;2010-07-07T13:23:54Z&amp;lt;/end&amp;gt; &amp;lt;/query&amp;gt; &amp;lt;/iq&amp;gt; by max number by uid of message &amp;lt;iq type=&amp;#39;get&amp;#39; id=&amp;#39;q29303&amp;#39;&amp;gt; &amp;lt;query xmlns=&amp;#39;urn:xmpp:mam:tmp&amp;#39;&amp;gt; &amp;lt;start&amp;gt;2010-08-07T00:00:00Z&amp;lt;/start&amp;gt; &amp;lt;set xmlns=&amp;#39;http://jabber.</description></item><item><title>ejabberd Login module</title><link>https://blog.caoyue.me/post/ejabberd-login/</link><pubDate>Tue, 16 Sep 2014 15:45:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ejabberd-login/</guid><description>懒得贴代码，画个渣图看下好了。
P.S 从图上可以看出 XMPP 确实是细（fán）致（suǒ）之极了，考虑到在移动设备上的使用，这样的效率肯定是无法接受的。
对特定的服务来说，没有必要做如此多的交互步骤，考虑做一些简化。
Update: 详细的 login 流程 gist d0ec83e9aa3c1899287d</description></item><item><title>XMPP protocol</title><link>https://blog.caoyue.me/post/xmpp-protocol/</link><pubDate>Tue, 05 Aug 2014 11:01:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/xmpp-protocol/</guid><description>XMPP 协议 XMPP 协议是一种基于 XML 的 IM 协议，其前身是 jabber，后来被 IETF 标准化。其他信息可以参考 wikipedia.
协议架构 通过 TCP socket 与 XMPP 服务器进行通信 传输的是预定格式的 XML 信息 通过解析 XML 提取请求类型和消息 消息格式 一个实体在 XMPP 网络中被称为一个节点，它有唯一的标示符 jabber identifier (JID)，实体可以是用户或者聊天室
XMPP 中定义了 3 个顶层元素： Message、Presence、IQ
Message
基本的消息通讯格式：
To：消息的接收方 from : 发送方的 JID body: 要发送的消息 type: normal：单纯的消息，不要求响应； chat：IM 消息 groupchat：聊天室 group chat headline：发送 alert 和 notification 消息 error：发送 message 出错时通知 &amp;lt;message from=&amp;#39;nobody@caoyue.</description></item><item><title>Thoughts on Erlang and ejabberd</title><link>https://blog.caoyue.me/post/thoughts-on-erlang-ejabberd/</link><pubDate>Sun, 03 Aug 2014 18:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/thoughts-on-erlang-ejabberd/</guid><description>分析 WhatsApp 架构的时候提到了他们使用的 Erlang + ejabberd 架构。看起来非常神奇，但感觉想要直接搬过来也有一些问题。
Erlang 优秀的工程师
Erlang 看起来语法简单、函数式编程、并发能力强，但就是——会的人太少了，连 Facebook 都找不到足够的优秀 Erlang 程序员，这是为什么呢……反正我们 HR 表示目前连投简历的人都没有 XD 语言本身
刚接触 Erlang，只能说下初步的感受，也有可能是见识不及，权当一看。 语法简单，特性少。很难说到底是优点还是缺点。Erlang 的语法可能一页纸就能写完。但是带来的是「我应该怎么开始？」这样的问题 学习成本。无论鼓吹者宣扬函数式多么好，语言始终是用来解决问题的。Java 再烂依然大把公司用得很 happy 。大部分程序员是务实的，只有能带来好处才会去原因学习。但是对习惯了面向对象命令式编程的程序员来说，学习和思维转换的成本可能根本比带来的好处要大得多。Golang 比 Erlang 火不是没有理由的 数据类型。比如不存在字符串而是使用 List ，不管从性能或是直觉上来说，总觉得有那么点奇怪 数据抽象能力。用 Erlang 开发的复杂应用实在看得头疼，数据抽象能力弱好处是灵活，但导致的后果就是代码里到处充斥着不知道意义的 tuple 和 record，它们之间可能还层层嵌套，让我感觉脑子时刻准备 StackOverflow 和其他语言的交互。Erlang 处处透露着一股高冷范儿，比如独特的错误恢复机制，自实现的进程等等，很难做到和其他语言合群。但是在自己的领域里，Erlang 做得足够好。 XMPP 协议 XMPP 协议实在是太「重」了！XMPP 协议基于 XML ，很大的问题是信息冗余太大，传输数据的很大部分（一般超过 60%）是协议相关，其中既有协议本身繁冗的关系，也有 XML 的原因。
对移动设备来说这将是个很大的问题——更多的流量消耗、以及相关的电量、网络效率等等。 XMPP 协议的另一个问题在于扩展的复杂。XMPP 协议本身已经定义了一大堆协议流程，如果想要在基础之上扩展，将会非常麻烦。
基本上使用 XMPP 协议的服务最后都会改换成自定义协议（比如 WhatsApp），也不是没有原因的。 想要快速开发 Erlang + ejabberd 还是不错的，XMPP 协议本身很开放和完善，各种平台的实现也很多，用来快速原型还是不错的。但是想要实现深度的定制和优化可能就需要更多的时间和精力了，尤其对于移动平台来说。</description></item><item><title>WhatsApp 的一点分析</title><link>https://blog.caoyue.me/post/whatsapp-and-erlang/</link><pubDate>Fri, 01 Aug 2014 18:51:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/whatsapp-and-erlang/</guid><description>最近的项目需要做一个跨平台的 IM 服务，想要参考下其他项目的架构。国内分享不多，微信基本没有参考价值，毕竟 QQ 的积累在那。陌陌从招聘及据网上抓包的内容看是 XMPP 协议，看起来可能是 Java 的 openfire 之类的 XMPP 路线。
国外的分享稍微多一些，像 WhatsApp 每年都会做一些相关的分享，看起来有些参考价值。
WhatsApp 目前的数据 月用户约为 4.65 亿 每天有 190 亿 消息进站/ 400 亿消息出站 6 亿图片,2 亿音频, 1 亿视频 峰值并发连接为 1.47 亿 消息峰值为每秒 34.2 万进站/ 71.2 万出站 节日期间流量更加惊人 支撑这些数据的硬件 约 550 台服务器 约 150 台 chat server, 可以支持 1.5 亿连接 约 250 台 mms 服务器 数据服务器内存为 512 GB，标准节点是 64 GB 除了视频，其他数据都存储在 SSD 上 超过 11000 个核心 Mnesia 使用了约 2TB 的内存 服务端架构 几乎全部使用 Erlang (经过了自己的改造) 服务器使用的是 FreeBSD 9.</description></item><item><title>Qzzz</title><link>https://blog.caoyue.me/post/Qzzz/</link><pubDate>Sat, 28 Jun 2014 14:32:17 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/Qzzz/</guid><description>Windows 的计划任务功能不够用，于是试着写了个支持插件和动态加载的定时执行任务工具 Qzzz，暂时是个坑&amp;hellip;
Qzzz A scheduler app for windows.
How to use Run as a windows service
Use Install.bat to install the QzzzService Run as a console
Run Qzzz.exe and do not close the console. Create a plugin create a config file qzzz.json
{ &amp;#34;Id&amp;#34;: &amp;#34;323ADBF530C4307B336C670B3F5BD229&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;ToastPluginDemo&amp;#34;, &amp;#34;Version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;Description&amp;#34;: &amp;#34;Toast plugin demo&amp;#34;, &amp;#34;CronExpression&amp;#34;: &amp;#34;*/15 * * * * ?&amp;#34;, &amp;#34;StartAt&amp;#34;: &amp;#34;2014-06-01 00:00:00&amp;#34;, &amp;#34;EndAt&amp;#34;: &amp;#34;2014-07-01 00:01:00&amp;#34;, &amp;#34;PluginFileName&amp;#34;: &amp;#34;Qzzz.</description></item><item><title>在 Windows 8 Desktop App 中使用 Toast Notification</title><link>https://blog.caoyue.me/post/use-toast-in-windows-desktop-app/</link><pubDate>Sun, 22 Jun 2014 12:45:06 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/use-toast-in-windows-desktop-app/</guid><description>最近坐久了就感觉腰酸背痛，想要做个定时提醒，提醒自己定时休息走动一下。
现在的定时提醒软件要么太复杂要么太难看，本来想要使用系统自带的定时任务，但是 Windows 8 中废弃了计划任务中的弹出消息功能。
想到 Windows 8 中新增了 Toast Notification，能不能利用这个方式来提醒？但是没见过 Desktop app 使用这个功能，一直以为是 Windows Store App 专用的 API。
在翻 MSDN 的时候发现原来 Metro Toast Notification 适用范围也包括 Desktop app。然后折腾了一下，居然成功了:)
在 Desktop app 中使用 Windows 8/Windows RT API Toast 位于 Windows.UI.Notifications 命名空间中，但是默认情况下没法引用该命名空间，因为其中一些 API 在 Desktop 环境下是有限制的。幸运的是 Toast Notification 不属于其中。可以从 MSDN 上找到这些 API 的详细信息，其中就包括了适用范围 。
建立一个 Console Application，为了引用 Windows.UI.Notifications，需要编辑项目文件 .csproj。在第一个 PropertyGroup 节点中添加 &amp;lt;TargetPlatformVersion&amp;gt;8.0&amp;lt;/TargetPlatformVersion&amp;gt; 重新 Load 项目，添加引用。可以看到引用管理器左边添加了新的一列 Windows，添加 Windows.Data.Xml.Dom Windows.UI.Notifications</description></item><item><title>泰山游记</title><link>https://blog.caoyue.me/post/tai-shan/</link><pubDate>Sun, 01 Jun 2014 21:45:06 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/tai-shan/</guid><description>准备 好吧，其实没啥准备，完全是一场说滚就滚的旅行。
吃 直接从车站打的到了天外村。一家叫做「麓山鲁菜馆」的饭馆，还没等到吃完就后悔了，价格略贵而且难吃。
比如有道特色菜叫「泰山三美」，上来才发现就是白菜豆腐汤，不说食材质量不怎么好，还差一美呢，问了老板说是泰山水——这不叫「珍珠翡翠白玉汤」真是可惜了……
上山 徒步上山都是从红门开始的。隔天外村也比较近。到的时候是晚上八点左右。
挺热闹的，到处都是专业和不专业的背包客，很多大妈在推销她们的登山装备。有些还是挺有用的。比如拐杖，竹子做的，很便宜，两元一支。开始不想买来着，后来大妈吓唬我说没这个很难登上去，我就没骨气的买了……后来事实证明确实也挺有用的，基本是人手一个。
由于我们是晚上登山，所以买了手电，确实也有用，因为山上没路灯，不带连上厕所都得摸黑。另外看天气可能下雨，买了雨衣，挡雨防寒都不错。
然后由于兴奋，犯了个错误。吃完饭过来就开始爬山了。其实应该先休息消化一会儿。
另外一个错误就是一开始就一顿猛冲，还没到中天门就已经累的不行了。结果听人说还不到一半，后面更陡，要不是晚上缆车不开，估计就直接坐缆车了（所以晚上爬山还有这么个好处，想放弃也没办法，上不去也下不来，只能往上爬了）。
过了中天门，确实更陡。
台阶从面前往上铺开，简直一眼望不到头，只看到天边不知道是星光还是灯光。
我这个除了每天下楼买宵夜之外没有其他锻炼的新手爬山者心里一股感觉油然而生，「我 X，真他妈高！」
爬过这一折，还没来得及回望下面的芸芸众生感叹一下「老子真牛 X 」就发现面前又冒出来一条比之前更长更陡的路，简直要怀疑人生到底是他妈为了为什么人类何苦要自我折磨。
不过还好和朋友一起的，有人一起支持鼓励的感觉好多了。也学会了不要看其他地方，一心看着脚下的台阶，一步一步走。路上看到不少人感觉都是机械式的在动了……
到了极限的时候感觉腿都发软，T 恤也不知道湿了又干几次了。不过真的像以前体育老师说的，超过了极限反而就好了。
后来到了十八盘的时候，爬上去之后还小小得瑟了下「十八盘也不过如此」然后收到了一堆鄙视的眼神……
到了南天门往下看的时候还真的是不敢相信。看远处的万家灯火和下面的人群，简直难以想象是自己一步一步爬上来的。
然后去日观峰等日出，到的时候大概是夜里一点左右，花了五个小时从山脚上来。对我来说，平时估计步行五个小时都够呛……
日观峰上都是租个军大衣就靠着山石或者躺着休息下的人群，挺热闹的，打牌玩杀人游戏的都有。
结果天公不作美，下起了小雨，一直下下停停的。到了凌晨虽然雨停了，不过一点日出的迹象都没了。
虽然没看到日出云海，但是见识了下人海。夜里没发现，天亮才发现满山都是各种奇葩姿势等日出的人，不知道哪位喊了句「山上的朋友你们好吗」莫名其妙的就戳中笑点了……
下山 没看到日出只能下山了。而且还下起了雨。极其影响心情啊。
不过慢慢发现雨中也别有一番趣味来着，顺便好好欣赏了下晚上上山错过的景色。
就是下山的时候看着下面腿发抖，真怕一不小心就直接圆润的滚下去了……所幸最后平安下山 :)
也有缆车下山，不过只到中天门。之后可以坐旅游大巴或者走下山。
下山比上山还是快得多，除了小心一点之外也没上山那么累，全程没有怎么休息，用了三个小时左右，下来之后差点出租车上睡着……
Tips 推荐大家准备：
2L 左右的饮用水。如果怕负担的话山上每隔一段有卖，基本是 5 块左右。有盐水之类的更好 零食，补充体力，巧克力糖什么的不错 山下卖的拐杖，上山下山都挺好用 如果是晚上登山或者下山，请带手电筒 看天气预报，如果可能下雨请带雨衣 毛巾。擦汗用，虽然擦不过来…… 防寒衣物，羽绒服什么的。没有洁癖的可以在山上租 10 块一件的军大衣，防寒效果不错 Money。山上每过一段都会有小商店，需要的东西基本都可以买到，价格当然也会贵点不过也还好，另外木有刷卡的地方 移动电源。山上下山加起来可能要七八个小时，对微博狂人来说手机电源可能不够用，还是带个移动电源比较保险 朋友。登上去之后简直难以相信自己能爬上来。都是靠朋友支持鼓励，聊聊天插科打诨之类的也很能放松。如果自己一个人来的就在路上勾搭个基友/妹子吧。山上大部分地段 3G 信号都不错，没事发个微博朋友圈什么的炫耀下也不错 信心。千万不要想放弃，也不要想还有多远。反正走着走着就发现到南天门了。感觉撑不住的时候休息下缓一缓，宁可走一回站几分钟休息下，千万不要休息太长时间，因为一旦完全放松下来就很难有斗志继续了</description></item><item><title>原来 IP 地址还可以用混合进制表示</title><link>https://blog.caoyue.me/post/ip-address-as-octal/</link><pubDate>Sun, 18 May 2014 18:55:00 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/ip-address-as-octal/</guid><description>今天发现 Google 的时候发现收录了一个奇怪的地址，形如 23.244.200.000000000354，而且这个地址居然还是可以访问的。很显然这不是域名，尝试 ping 一下，返回地址来自于 23.244.200.236，可以看出 000000000354 是 236 的八进制表示形式。
###混合进制
查了下，原来 IP 地址居然可以混合进制来显示……前导的 0 的数字会被当作八进制来处理。而且可以同时使用不同进制：包括十六进制、八进制和十进制。
比如 http://0x17.244.0xc8.00000354 这样奇葩的地址也是可以访问的……
###DWORD 形式的 IP
还有更奇葩的，整数型的 IP —— 比如这个：http://401918188 ，同样可以访问。
转换过程是将 23.244.200.236 转换为二进制形式，不足 8 为的数字用 0 补足： 00010111111101001100100011101100，然后将这一串二进制数字转换为整数，即可得到整数型的 IP 地址。
当然，如果将这个整数换成其他进制也是可以的，比如：
http://02775144354 和 http://0x17f4c8ec
###可省略的 0
当然，奇葩还没有结束。比如这样的 IP 地址 192.168.1 也是可以访问的……因为某部分为 0 则可以省略。OK，那我们怎么知道省略的是哪一部分呢？别急，「聪明」的标准的制定者们早就想到这一点了，规则如下：
abbr IP A 0.0.0.A A.B A.0.0.B A.B.C A.B.0.C A.</description></item><item><title>C# 中缀表达式计算</title><link>https://blog.caoyue.me/post/csharp-compute-expression/</link><pubDate>Mon, 28 Apr 2014 23:10:07 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/csharp-compute-expression/</guid><description>给出一个字符串的计算表达式如 1+2*(3-4)/5 ，不使用其他库如何计算其结果？
在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。
中缀表达式 中缀表达式 (Infix Expression)，即形如 a+b-c*d 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。
后缀表达式 后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 a+b 记作 a b +。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。
表达式转换 既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 调度场算法。实际上语法树的后序遍历也是后缀表示法。
简单分析下从中缀表达式到后缀表达式的过程：
定义两个栈 Operand（操作数栈）和 Operator（运算符栈）； 从左到右遍历字符串，按如下规则： 如果该字符为左括号，直接压入 Operator 栈中； 如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈； 如果该字符是操作符： 首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量； 查看 Operator 栈中是否存在运算符： 如不存在，将该操作符压入 Operator 栈中； 如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级： 该操作符优先级较高，将该操作符压入 Operand 栈中； 该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中； 如果该字符不是操作符也不是括号，则将其存入临时变量； 循环完成，将临时变量（即最后一个数字）压入 Operand 栈中； 将 Operator 栈依次弹出并压入到 Operand 栈中； 将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。 后缀表达式计算 将后缀表达式转换成堆栈 Suffix； 定义一个新的栈 Result; 依次弹出 Suffix 栈顶元素： 如果该元素不是运算符，将其压入 Result 栈中； 如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中； Result 栈顶元素即计算结果 这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。</description></item><item><title>A Wox plugin let you search firefox bookmarks</title><link>https://blog.caoyue.me/post/wox-plugin/</link><pubDate>Fri, 25 Apr 2014 23:36:11 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/wox-plugin/</guid><description>###关于 Wox
最初是看到 V2EX 上的一个帖子 v2ex.com/t/93922，然后作者真的去写了并且发布在 Github 上了。
Windows 上的快速启动软件已经很多了，但是不管从功能、界面乃至理念来讲和 Alfred 都相去甚远，尤其是 Workflow 的概念。
Wox 现在发布了第一个 beta 版本，看上去已经很不错了，希望这个项目能坚持下去吧。
###Wox.Plugin.FirefoxBookmarks
Wox 的插件开发也比较简单，可以参考文档。写了个搜索 Firefox 书签的插件。
原理是读取 Firefox 书签，然后根据参数查询返回结果。
首先我们要获取到 Firefox Profile 的位置。Firefox 支持多个 Profile，我们可以获取到默认的 Profile 。Firefox Profile 路径及配置都保存在 %appdata%\Mozilla\Firefox\profiles.ini 中。打开这个配置文件可以看到每个 Profile 配置包含的参数：&amp;ldquo;IsRelative&amp;rdquo; 值为 &amp;ldquo;0&amp;rdquo; 代表绝对路径，&amp;ldquo;1&amp;rdquo; 代表相对路径；&amp;ldquo;Default=1&amp;rdquo; 代表默认启动的 Profile。
虽然可以通过引入 WindowsAPI （即 [DllImport(&amp;quot;kernel32&amp;quot;)]）来解析 ini 配置文件，不过无需如此小题大做，毕竟只需要找到其中一行即可。下面是一个读取 Firefox 默认 Profile 的方法：
gist 11324134
这种读取方法对某些 Portable 版本无效，所以同时也提供了手动配置路径的方法。
Firefox 书签以及历史记录都保存在 Profile 里的 places.sqlite 中。其表结构可以参考 developer.mozilla.org/en-US/docs/The_Places_database。
其中 moz_bookmarks 表中存储了书签及书签文件夹，且通过外键 fk 和 moz_places 关联。</description></item><item><title>Firefox 的表单缓存「Bug」</title><link>https://blog.caoyue.me/post/firefox-form-cache/</link><pubDate>Sat, 07 Sep 2013 11:06:11 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/firefox-form-cache/</guid><description>##问题
在使用 Firefox 测试网站的时候遇到一个奇怪的问题。
把一份数据写入类型为 hidden 的 input 中时，比如
&amp;lt;input type=&amp;#34;hidden&amp;#34; value=&amp;#34;@Model.Count&amp;#34; id=&amp;#34;Count&amp;#34; /&amp;gt; 然后在用 Javascript 修改这个值，比如后台数据原为 0，
var count = parseInt($(&amp;#34;#Count&amp;#34;).val()); $(&amp;#34;#Count&amp;#34;).val(count + 1); 不提交表单，刷新页面，发现 $(&amp;quot;#Count&amp;quot;).val() 的值却不是后台数据的 0，而是我们修改过后的值，这个值被缓存了。
##原因
使用其他浏览器测试可以发现，这个问题仅出现在 Firefox 中。从而可以考虑是否 Firefox 对表单缓存的实现「有问题」。
##解决
设置 form 的 autocomplete=&amp;quot;off&amp;quot;</description></item><item><title>Whoosh 全文搜索</title><link>https://blog.caoyue.me/post/whoosh-search/</link><pubDate>Mon, 05 Aug 2013 14:58:53 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/whoosh-search/</guid><description>Whoosh 是一个纯 Python 实现的全文搜索组件。基础架构和 Lucene 比较像。使用试了试，记录一些东西。
中文分词
Whoosh 本身只有英文分词，因此需要添加中文分词组件。
最后选择了 Jieba 这个 Python 中文分词组件，初步测试分词效果还不错。有时间会把几个中文分词组件对比一下看看。
Jieba 已经封装好了 ChineseAnalyzer for Whoosh，只需要引用 from jieba.analyse import ChineseAnalyzer 来替换 Whoosh 的 Analyzer 即可。
HTML 抽取
对于纯文本直接分析建立索引即可。
而对于 HTML 文本，我们需要先将其中的文本抽取出来再进行运行分析程序。否则其中的 HTML 标签将会被当作文本来分析，比如搜索 &amp;ldquo;span&amp;rdquo; 将会得到所有包含 &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; 的内容。举个例子，用 HTMLParser 来提取文本，其他类似功能的模块也有不少。
def html_strip(html): from HTMLParser import HTMLParser html = html.strip() html = html.strip(&amp;#34;\n&amp;#34;) result = [] parse = HTMLParser() parse.handle_data = result.append parse.feed(html) parse.close() return &amp;#34;&amp;#34;.join(result) 关键词 Highlight
默认的高亮结果只会包含结果命中的部分碎片，需要不同展示可以使用不同的 Fragmenters 。比如展示全文需要 whoosh.</description></item><item><title>Project Timeline</title><link>https://blog.caoyue.me/post/project-timeline/</link><pubDate>Tue, 30 Jul 2013 16:49:59 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/project-timeline/</guid><description>做了一个同步微博、Twitter 和 Rss Feed 到本地的工具，方便保存和查看自己的数据，以及用自己的数据做一些好玩的事。
MyTimeline
聚合分散在各个网站上的 Timeline
Support:
Rss Feed Twitter Oauth Weibo Oauth 同步发送消息到第三方
/update
Support:
Twitter Weibo 按日期查看过往记录
/past
对所有记录的统计图表
/statistic
Support：
按时段统计 按月份统计 按分类统计 TODO
其他第三方支持 搜索 Other&amp;hellip; Tools
Linux Python Web.py Nginx/Gunicorn MySql Google Chart Demo
Demo License
MIT Feel free to give me some feedback:)</description></item><item><title>Goodbye Google Reader</title><link>https://blog.caoyue.me/post/goodby-google-reader/</link><pubDate>Tue, 02 Jul 2013 17:36:50 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/goodby-google-reader/</guid><description>Google Reader 关闭了。
重度拖延症的坏处就是直到这两天才开始寻找替代品。不考虑自建服务了，抓取和存储、搜索都成问题，跨平台支持也少有做好的。
不出意外就在目前大热的线上服务 Feedly 和 Digg Reader 中选了。
遗憾的是基本没有一家能完全满足需求——也许也只是在强求另一个 Google Reader 的完美复制品罢了。但是残缺不全的功能——基础的搜索都没有、极低的抓取频率确实也很难让人满意。
那么 Google Reader 到底好在哪呢？
从 Google Reader 出来之后其他 RSS 订阅服务基本都死气沉沉了就可想而知了。
我个人的体会：
1、界面功能简洁实用。现在大热的 Feedly 到 Digg Reader 哪个不是借鉴了 Google Reader 的功能和界面？
2、搜索，比起手动同步到 Evernote 什么的，只要你记得在 Google Reader 里面看过，搜索就行了。而这些结果天生就是被组织过的——这才是符合我需要的个性化搜索啊！
3、被 Google 砍掉的社交功能，这是我认为 Google 做过的最好的社交产品，可惜了。比如可以订阅别人的分享，很容易发现一些有趣的东西。看大牛今天看了什么内容不比听他们闲话家常有意思么？
4、Google 的强大抓取和存储。对比 Feedly 和 Digg Reader 很明显，Google 的抓取频率要高得多。而一旦被抓到，这些条目都会存储在 Google 的服务器上，不用担心网站会消失。而且方便的加星和 Tag 可以很好的组织知识库。
5、算法推荐排序。Google Reader 有一个神奇排序，会根据你的阅读历史，条目 like 人数等等因数来排序。据说有人用 Google 的精准推荐来做和谐订阅搜集……
6、Google 的稳定服务，曾经我们都以为 Google 永远是可靠的……
就算 Google Reader 拥有如此高的用户粘性和活跃度，它还是死了。</description></item><item><title>Reference in CSharp</title><link>https://blog.caoyue.me/post/reference-in-csharp/</link><pubDate>Mon, 01 Jul 2013 11:11:11 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/reference-in-csharp/</guid><description>起因是 V2EX 的一个帖子.
C++ 中引用是一个很基础但是也很容易忽略的问题，那么在 C# 中呢？看下面的 Gist.
gist 5898137
分析 C# 中引用类型参数是按引用(即指针地址)来传递的，所以我们使用第一个 Swap 方法——结果是 a 和 b 的值没有变化。
再使用 ref 试试，OK，a 和 b 的值交换了。
再看没有使用 ref 的 Swap 方法。temp = a 实际上是令 temp 形参作为 Swap 函数的局部变量，即在栈上开辟空间存储了实参 a 指向的堆地址（形参 a 和 b 同理）。
操作完成后，可以看出，仅仅是在栈上的形参 temp、a、b 所存储的堆地址发生了改变，而原实参 a、b 所存储的堆地址并没有发生变化。
C# 的引用传递和值传递 引用类型作为参数时：
在修改变量本身时，结果类似于值传递，即不会改变传递前的变量的值，换句话说就是值传递传的是对象的值拷贝，而引用类型参数的值实际上就是其指向的堆对象的指针地址
即值传递传的是对象的值拷贝，函数内参数对象是调用时传递的对象的栈中对象的拷贝。
在修改变量的属性或字段时是引用传递，会影响到传递前的变量的值
如代码中，如果交换 a 和 b 的成员的值，则会修改实际对象的值。比如 SwapValue 方法可以成功交换。
这是因为形参 a 指向了堆中对象，修改其字段值实际上也就修改了该对象的字段，而实参 a 和 形参 a 指向的是同一对象，所以也就修改了实参 a 的值</description></item><item><title>Refresh Window 8</title><link>https://blog.caoyue.me/post/refresh-windows8/</link><pubDate>Mon, 17 Jun 2013 16:46:49 +0000</pubDate><author>i@caoyue.me (caoyue)</author><guid>https://blog.caoyue.me/post/refresh-windows8/</guid><description>Windows 8 的 Refresh Windows 8 还是挺好用的。之前安装的 Visual Studio 出了问题弄得环境一团糟，而 VS 附带的一大堆没用的东西一个个卸载起来实在是麻烦，索性直接 Refresh 了。
Refresh 是需要安装盘的。如果只有 ISO 镜像而没有安装盘，可以用下面的方法：
提取 Windows 8 镜像中 sources 下的 install.wim 放到比如 E:\Install 下 以管理员身份运行的命令提示符中键入下面的命令回车运行
reagentc /setosimage /path E:\sources /index 2 Refresh 之后不需要重新激活，而且所有系统和用户设置（不包括磁贴布局）会保留。但是所有安装在系统分区的程序（包括驱动）将会丢失，注册表也不会被备份，依赖注册表的程序可能无法运行。而 Metro Apps 会自动重新安装。完成后会有一份被删除的程序的列表放在桌面上。
整个过程大概 10 分钟完成。完成后记得在磁盘清理中删除旧的系统文件。</description></item></channel></rss>