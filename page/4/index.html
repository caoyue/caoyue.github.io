<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#a6d6d6"/><meta name="msapplication-TileColor" content="#a6d6d6"/><meta name="msapplication-TileImage" content="/icon/favicon.ico"/><meta name="referrer" content="no-referrer"/><title>且听疯吟</title><link rel="alternate" type="application/rss+xml" title="atom 1.0" href="/atom.xml"/><link rel="apple-touch-icon" sizes="192x192" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="48x48" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="192x192" href="/icon/favicon.ico"/><link rel="stylesheet" href="/css/normalize.css"/><link rel="stylesheet" href="/css/style.css"/><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><div class="header"><a href="/" title="this is a link">且听疯吟</a><span>如此生活三十年</span></div><div class="left"><ul class="list"><li><a href="/" title="Home">Home</a></li><li><a href="/archives" title="archive">Archive</a></li><li><a href="/tags" title="Tags">Tags</a></li></ul></div><div class="right"><div class="entry"><div class="title"><a href="/post/about-unicode/">关于 unicode</a></div><div class="content"><p>对这些概念头疼了很久，尝试简单的整理下，不确切的地方欢迎指正~</p>
<h4 id="1-Unicode"><a href="#1-Unicode" class="headerlink" title="1. Unicode"></a>1. Unicode</h4><ul>
<li>Unicode 是一个<strong>字符集</strong>，而不是一种编码方案</li>
<li>简单来说 Unicode 是希望给地球上每一个字符一个数字编号，从而解决不同编码之间不统一的问题</li>
<li>Unicode 是没法直接拿来用的，我们使用的是它的编码方案</li>
</ul>
<h4 id="2-编码方案"><a href="#2-编码方案" class="headerlink" title="2. 编码方案"></a>2. 编码方案</h4><ul>
<li>通常使用的 <code>UTF-8</code>，<code>UTF-16</code> 等等都是 Unicode 的编码方案</li>
<li>所谓编码方案就是按一定的规则对 Unicode 的字符编号进行编码</li>
<li>当然不同的编码的<strong>同一个字符</strong>，最后解析成 Unicode 字符编号都是一样的</li>
</ul>
<h4 id="3-字体与-Unicode"><a href="#3-字体与-Unicode" class="headerlink" title="3. 字体与 Unicode"></a>3. 字体与 Unicode</h4><ul>
<li>计算机使用字符的 Unicode 编号去寻找字体内的字符</li>
<li>字体内部的特殊数据结构存储了 Unicode 编号和字符的对应关系</li>
</ul>
<h4 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h4><ul>
<li>汉字 <code>月</code> 的 Unicode 编号 10 进制为 <code>26376</code></li>
<li>Unicode 编号表示为 16 进制 是 <code>U+6708</code></li>
<li>在 python 中用 <code>u&quot;\u6708&quot;</code> 表示</li>
<li>在 UTF-8 中的编码是 <code>0xE6 0x9C 0x88</code> ，使用了 3 个 Byte 来表示</li>
</ul>
<h4 id="5-UTF-8-和-Unicode-转换"><a href="#5-UTF-8-和-Unicode-转换" class="headerlink" title="5. UTF-8 和 Unicode 转换"></a>5. UTF-8 和 Unicode 转换</h4><ul>
<li><p>Unicode 转 UTF-8</p>
<ul>
<li>汉字 <code>月</code> 的 Unicode 是 <code>26376</code>，转换为二进制是 <code>1100111 00001000</code></li>
<li>根据值大于 <code>0x800</code> 小于 <code>0x10000</code> 可以判断为三字节存储</li>
<li>将 Unicode 二进制从低位往高位取出二进制数字，每次取 6 位，并按一定的规则进行填补</li>
</ul>
<blockquote>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>110 011100 001000<br><strong>1110</strong>0110 <strong>10</strong>011100 <strong>10</strong>001000<br>0xE6 0x9C 0x88</p>
</blockquote>
</li>
<li><p>UTF-8 转 Unicode<br>同理进行逆运算即可</p>
</li>
</ul>
<h4 id="6-遗留编码"><a href="#6-遗留编码" class="headerlink" title="6. 遗留编码"></a>6. 遗留编码</h4><ul>
<li><code>ASCII</code>、<code>GB 2312</code>、<code>Big5</code>、<code>GBK</code>、<code>GB 18030</code> 这些都属于遗留编码方案</li>
<li>GB 2312 通常认为是<strong>字符集</strong>和<strong>编码方案</strong>一体的</li>
<li>将 GB 2313 编码转换为 Unicode 编号，需要通过转换表查询，无法像 UTF-8 一样直接根据编码规则转换</li>
</ul>
</div><div><ul class="info"><li>2015-04-28</li><li><a href="/tags/programming/">#programming</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/erlang-programming-3/">Erlang Programming 笔记 3</a></div><div class="content"><h3 id="6-编译并运行程序"><a href="#6-编译并运行程序" class="headerlink" title="6. 编译并运行程序"></a>6. 编译并运行程序</h3><ul>
<li>（略）</li>
</ul>
<h3 id="7-并发"><a href="#7-并发" class="headerlink" title="7. 并发"></a>7. 并发</h3><ul>
<li>机制<ul>
<li>Erlang 程序由成百上千个 Process 组成，这些 Process 之间可以互发消息</li>
<li>Process 能否接收到或者理解消息是不确定的，要知道结果必须向该 Process 发送消息询问并等待</li>
<li>Process 之间可以互相 Link ，当 Process 消亡时与之相连的 Process 会收到消息</li>
</ul>
</li>
</ul>
<h3 id="8-并发编程"><a href="#8-并发编程" class="headerlink" title="8. 并发编程"></a>8. 并发编程</h3><ul>
<li><p>并发原语</p>
<ul>
<li><code>Pid = spawn(Module, FuncName, Args)</code><br>创建一个新的 Process，用于对 Func 求值，并返回该 Process 的 pid</li>
<li><code>Pid ! Message</code><ul>
<li>向指定 Pid 的 Process 发送消息，返回值为 Message 本身</li>
<li>消息发送是异步的，无需等待即可进行其他操作</li>
</ul>
</li>
<li><code>receive ... end</code><ul>
<li>接收一个发给当前进程的消息</li>
</ul>
</li>
<li><code>self()</code><br>获取自己的 pid</li>
</ul>
</li>
<li><p>注册进程</p>
<ul>
<li><code>register(AnAtom, Pid)</code></li>
<li><code>unregiseter(AnAtom)</code><br>进程死亡时会自动 unregiseter</li>
</ul>
</li>
<li><p>编写并发程序的一般模式</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span> <span class="params">(concurrency)</span>.</span><br><span class="line"><span class="keyword">-compile</span><span class="params">(export_all)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    spawn(?MODULE, loop, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></span><br><span class="line">    Pid ! &#123;self(), Request&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">         &#123;Pid, Response&#125; -&gt;</span><br><span class="line">             &#123;Pid, Response&#125;</span><br><span class="line">     <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">(X)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;From, Any&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), <span class="string">&quot;Received!&quot;</span>&#125;,</span><br><span class="line">            io:format(<span class="string">&quot;Received: ~p~n&quot;</span>, [Any]),</span><br><span class="line">            loop(X)</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% run in erlang shell</span></span><br><span class="line">Pid = concurrency:start().</span><br><span class="line"><span class="comment">%% &lt;0.33.0&gt;</span></span><br><span class="line">concurrency:rpc(Pid, <span class="string">&quot;test！&quot;</span>)</span><br><span class="line"><span class="comment">%% Received: &quot;test&quot;</span></span><br><span class="line"><span class="comment">%% &#123;&lt;0.56.0&gt;,&quot;Received!&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</div><div><ul class="info"><li>2015-04-23</li><li><a href="/tags/erlang/">#erlang</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/erlang-programming-2/">Erlang Programming 笔记 2</a></div><div class="content"><h3 id="4-异常"><a href="#4-异常" class="headerlink" title="4. 异常"></a>4. 异常</h3><ul>
<li><p>抛出异常</p>
<ul>
<li>显式的 <code>exit(Why)</code><ul>
<li>终止当前 Process</li>
<li>如果当前 Process 未捕获这个异常，则系统会向所有 link 该 Process 的 Process 广播 <code>&#123;&#39;EXIT&#39;, Pid, Why&#125;</code> 消息</li>
</ul>
</li>
<li>显式的 <code>throw(Why)</code><ul>
<li>抛出供其调用者捕获的异常</li>
<li>最好是添加注释说明抛出的异常</li>
<li>如何处理由调用者选择，包括忽略</li>
</ul>
</li>
<li>系统错误 <code>erlang:error(Why)</code></li>
</ul>
</li>
<li><p><code>try..catch</code> 捕获异常</p>
<ul>
<li><p>try&#x2F;catch 本身会消耗一点性能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/666111/how-do-i-elegantly-check-many-conditions-in-erlang/669075#669075">推荐的 try&#x2F;catch 风格</a></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 首先对 FuncOrExpressionSequence 求值</span></span><br><span class="line"><span class="comment">%% 如果没有产生异常则顺序进行 Patterm 匹配, 匹配成功后执行后面的表达式</span></span><br><span class="line"><span class="comment">%% 如果有异常抛出, 则顺序匹配 ExPattern(ExceptionType 是 throw、exit、error 中的一个, 默认为 throw)</span></span><br><span class="line"><span class="comment">%% after 块中的代码用于清理工作,绝对会执行</span></span><br><span class="line"><span class="comment">%% after 可以省略</span></span><br><span class="line"><span class="keyword">try</span> FuncOrExpressionSequence <span class="keyword">of</span></span><br><span class="line">    Pattern1 [<span class="keyword">when</span> Guard1] -&gt;Expressions1;</span><br><span class="line">    Pattern2 [<span class="keyword">when</span> Guard2] -&gt;Expressions2;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    ExceptionType: ExPattern1 [<span class="keyword">when</span> ExGuard1] -&gt;ExExpressions1;</span><br><span class="line">    ExceptionType: ExPattern2 [<span class="keyword">when</span> ExGuard2] -&gt;ExExpressions2;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">after</span></span><br><span class="line">    AfterExpressions</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>栈跟踪</p>
<ul>
<li><p>在触发异常的时候可以调用 <code>erlang:get_stacktrace/0</code> 来查看最近的栈跟踪信息，可以获得异常函数的调用路径（尾递归调用除外）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> func()</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">	error: X -&gt;</span><br><span class="line">		&#123;X, erlang:get_stacktrace()&#125;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-顺序型编程进阶"><a href="#5-顺序型编程进阶" class="headerlink" title="5. 顺序型编程进阶"></a>5. 顺序型编程进阶</h3><ul>
<li><p>BIF (built-in function)</p>
<ul>
<li><p>binary</p>
<ul>
<li><p>相对于 List 活着 tuple , binary 更节省内存，输入输出更为高效</p>
</li>
<li><p><code>binary_to_term/term_to_binary</code> 可将任何的 binary 和 Erlang 值（List、atom、tuple 甚至 binary 等）转换成为 binary，但是这个 binary 是以所谓的 「外部数据格式」 存储的，类似于其他语言的序列化与反序列化）</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = &lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&gt;&gt;.</span><br><span class="line">B = term_to_binary(A).</span><br><span class="line"><span class="comment">%% &lt;&lt;131,109,0,0,0,3,1,2,3&gt;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>binary 中的数字，每一个都在 0~255 之间（因为每一个数字表示一个 byte，其值在 0000 0000 ~ 1111 1111 [0 ~ 2<sup>9</sup> -1] 之间）</p>
</li>
<li><p>GB2312 的汉字转成 UTF-8 时，绝大多数是 3 个字节</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = &lt;&lt;<span class="string">&quot;且听疯吟&quot;</span>/utf8&gt;&gt;.</span><br><span class="line"><span class="comment">%% &lt;&lt;228,184,148,229,144,172,231,150,175,229,144,159&gt;&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>bit 语法</p>
<ul>
<li><p>封包与解包</p>
<ul>
<li><p>以 RGB 色彩为例：<br>创建一个 16 bit (2 byte)的内存块，存放一个 RGB 三元组，并为 Red 分配 5 bit，为 Green 分配 6 bit，为 Blue 分配 5 bit</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Red = <span class="number">2</span>,</span><br><span class="line">Green = <span class="number">60</span>,</span><br><span class="line">Blue = <span class="number">29</span>,</span><br><span class="line">RGB = &lt;&lt;Red:<span class="number">5</span>, Green:<span class="number">6</span>, Blue:<span class="number">5</span>&gt;&gt;.</span><br><span class="line"><span class="comment">%% &lt;&lt;23, 157&gt;&gt;</span></span><br><span class="line">&lt;&lt;R1:<span class="number">5</span>, G1:<span class="number">6</span>, B1:<span class="number">5</span>&gt;&gt; = RGB.</span><br><span class="line">&#123;R1, G1, B1&#125;.</span><br><span class="line"><span class="comment">%% &#123;2, 60, 29&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意取值范围。比如我们为 Blue 分配了 5 bit，但是为 Blue 赋值 61，转换成二进制为 111101，超过了 5 bit，则会发生截断，取低五位，即实际值为 29</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">integer_to_list</span><span class="params">(<span class="number">61</span>,<span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">%% &quot;111101&quot;</span></span><br><span class="line"><span class="function"><span class="title">integer_to_list</span><span class="params">(<span class="number">29</span>,<span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">%% &quot;11101&quot;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;&lt;2:5,60:6,61:5&gt;&gt; == &lt;&lt;2:5,60:6,29:5&gt;&gt;.</span></span><br><span class="line"><span class="function">%% <span class="title">true</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>bit 语法表达式<ul>
<li>形如 <code>&lt;&lt;E1, E2, E3, ... , En&gt;&gt;</code></li>
<li>每一个元素都是二进制数据中的一个区块</li>
<li>元素的值表示有下面几种方式<ul>
<li><code>Value</code></li>
<li><code>Value:Size</code></li>
<li><code>Value/TypeSpecifierList</code></li>
<li><code>Value:Size/TypeSpecifierList</code></li>
</ul>
</li>
<li>其中 <code>TypeSpecifierList</code> 是形如 <code>End-Sign-Type-Unit</code> 组成的字符串，其中不同的 Type 选项如下，每一个都可以忽略且没有顺序要求：<ul>
<li><code>End = big / native / little</code><br>决定字节序，默认 big</li>
<li><code>Sign = signerd / unsigned</code><br>仅用于模式匹配，默认 unsigned</li>
<li><code>Type = integer/ float / binary</code><br>默认 integer</li>
<li><code>Unit = 1 / 2 / 3 / ... / 255</code><ul>
<li>整个区块长度为 Size * Unit，其值必须大于或等于 0 且是 8 的倍数</li>
<li>其值依赖于 Type，如果 Type 是 integer 或者 float，则值为 1 ，是 binary 则值为 8</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>binary 模式匹配</li>
</ul>
</li>
<li><p>apply</p>
<ul>
<li><code>apply(Module, Func, [Arg1, Arg2, ... , Argn])</code></li>
<li>对于参数个数已知的函数，<code>M:Func([Arg1, Arg2, ... , Argn])</code> 的调用优于 apply</li>
<li>使用 apply 调用的函数编译器无法优化，同时许多分析工具也无法分析其细节</li>
<li>如无必要尽量少用 apply</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>module</li>
<li>import</li>
<li>export</li>
<li>compile<ul>
<li>编译器选项，常用的 <code>-compile(export_all).</code></li>
</ul>
</li>
<li>vsn<br>无语法意义，用于文档分析</li>
<li>用户定义属性 <code>-SomeTag(Value)</code><ul>
<li>该值会被编译进模块</li>
<li>该值可以在运行时使用 <code>attrs:module_info()</code> 提取</li>
<li><code>beam_lib</code> 提供了一系列不加载模块代码就能分析的函数</li>
</ul>
</li>
</ul>
</li>
<li><p>块表达式<br>把多个表达式组织为单个表达式</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">	Expression1,</span><br><span class="line">	Expression2,</span><br><span class="line">	...</span><br><span class="line">	ExpressionN</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔</p>
<ul>
<li>Erlang 中不存在布尔类型，通常使用原子 <code>true/false</code> 代替作为布尔符号使用</li>
<li>布尔表达式：<code>and / not / or / xor</code></li>
</ul>
</li>
<li><p>字符集</p>
<ul>
<li>Erlang 默认编码为 <code>ISO-8859-1 (Latin-1)</code></li>
<li>Erlang 内部没有字符串数据类型，而是用一串整数列表表示</li>
<li>因此要注意 Unicode 字符的处理</li>
<li>使用 unicode 模块中如 <code>unicode:characters_to_list</code> 的函数处理 unicode 字符</li>
</ul>
</li>
<li><p>epp</p>
<ul>
<li>Erlang 预处理器，扩展宏，插入必须的包含文件等</li>
</ul>
</li>
<li><p>转义字符</p>
</li>
<li><p>表达式&#x2F;表达式序列</p>
<ul>
<li>表达式序列的值为序列中最后一个表达式的值</li>
</ul>
</li>
<li><p>函数引用</p>
</li>
<li><p>包含文件</p>
<ul>
<li><code>include</code></li>
<li><code>include_lib</code></li>
</ul>
</li>
<li><p>列表操作符</p>
<ul>
<li><code>++</code><ul>
<li>列表添加 <code>ListA ++ ListB</code><br>即把 ListB 附加到 ListA 尾部</li>
<li>模式匹配中的 <code>++</code><br><code>f(&quot;begin&quot; ++ T) -&gt; ...</code> 即相当于模式匹配 <code>[$b, $e, $g, $i, $n | T]</code></li>
</ul>
</li>
<li><code>--</code><br>列表删除 <code>ListA -- ListN</code> ，即从 ListA 中删除 ListB 中的所有元素，若元素 E 在 B 中重复出现 k 次，则只会从 ListA 中按顺序删除 k 个 E</li>
</ul>
</li>
<li><p>宏</p>
<ul>
<li>定义<ul>
<li>不带参数 <code>-define(Macro, ...)</code></li>
<li>带参数 <code>-define(Macro(X,Y), ...)</code></li>
<li>预定义宏<ul>
<li><code>?FILE</code> 当前文件名</li>
<li><code>?MODULE</code> 当前模块名</li>
<li><code>?LINE</code> 当前行号</li>
</ul>
</li>
</ul>
</li>
<li>宏的流程控制<ul>
<li><code>-undef(Macro)</code> 取消宏定义，在此语句后无法使用该宏</li>
<li><code>ifdef / ifndef / else / end</code></li>
<li>结合调试标志，扩展 debug 日志输出等</li>
</ul>
</li>
</ul>
</li>
<li><p>数值类型</p>
<ul>
<li>整型<ul>
<li>整型的计算是精确的</li>
<li>其计算结果代表的数据长度只受限于可用内存</li>
<li>表示法<ul>
<li>传统表示法，<code>1, 1989, -1337</code></li>
<li>K 进制整数，<code>2#01001011，16#fe34</code></li>
</ul>
</li>
</ul>
</li>
<li>浮点型<ul>
<li>内部以 IEEE 754 的 64 bit 格式表示</li>
</ul>
</li>
</ul>
</li>
<li><p>操作符优先级</p>
</li>
<li><p>进程字典</p>
<ul>
<li><p>每一个 Erlang Process 都有自己的进程字典</p>
</li>
<li><p>实际上提供的功能类似于全局变量</p>
</li>
<li><p>由于不是非破坏性赋值，会导致代码有副作用</p>
</li>
<li><p>尽量少用</p>
</li>
<li><p>添加&#x2F;获取进程字典</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@spec put(Key, Value) -&gt; OldValue | undefined.</span><br><span class="line">@spec get(Key) -&gt; Value | undefined.</span><br><span class="line">@spec get() -&gt; [&#123;Key, Value&#125;].</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>引用<br>使用 BIF <code>erlang:make_ref()</code> 创建引用</p>
</li>
</ul>
</li>
</ul>
</div><div><ul class="info"><li>2015-04-22</li><li><a href="/tags/erlang/">#erlang</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/erlang-programming-1/">Erlang Programming 笔记 1</a></div><div class="content"><h3 id="1-Erlang-优势"><a href="#1-Erlang-优势" class="headerlink" title="1. Erlang 优势"></a>1. Erlang 优势</h3><ol>
<li>并发和分布式<ul>
<li>主流语言使用共享内存模型，类似于 <code>x = x + n</code> 的代码导致了在多核环境下需要小心的处理锁的问题</li>
<li>Erlang 使用消息模型，Process 间不共享数据，从而避免了锁的问题</li>
<li>无锁避免了顺序瓶颈，添加节点到网络更容易</li>
</ul>
</li>
<li>错误处理<ul>
<li>多数语言默认认为程序不会出错</li>
<li>Erlang 采用不同的设计决策——注定要出错，那就让他出错，出错后恢复就行了。即 Erlang 程序出错后，会交由更高级的 Process 来处理（重启 Child Process、系列全部终止、重启相关 Process 等等），从而实现对错误的分级和容错处理</li>
<li>同时带来了热更新的好处，进一步保证了可用性</li>
</ul>
</li>
</ol>
<h3 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a>2. 入门</h3><ul>
<li><p>Shell</p>
<ul>
<li><code>f().</code> 会释放所有绑定的变量</li>
<li>崩溃文件分析<br><code>webtool:start().</code></li>
</ul>
</li>
<li><p>原子</p>
<ul>
<li><p>使用单引号括起来的字符也是原子</p>
</li>
<li><p>这使得原子可以以大写字母开头，或者带有空格</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;a&#x27; = a.  <span class="comment">%a</span></span><br><span class="line">&#x27;Monday&#x27;.</span><br><span class="line">&#x27;an atom with spaces&#x27;.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>列表</p>
<ul>
<li><p>可以包含不同类型</p>
</li>
<li><p>访问列表的头是高效的，所以通常函数处理也从列表头取起</p>
</li>
<li><p>插入元素到列表头部是高效的</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>].</span><br><span class="line">C = [<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span> | A ]. <span class="comment">% [&quot;c&quot;,&quot;d&quot;,&quot;a&quot;,&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尽量避免使用 <code>List ++ [H]</code> 这样的操作，通常情况下添加元素到列表尾部是极为低效的（重新生成新的列表），只有在列表非常短的时候可以这样用</li>
<li>添加在头部然后使用 <code>lists:reverse/1</code> 反转通常比添加在列表尾部效率要高</li>
<li>尽量使用经过高度优化的 BIF ，比如反转列表 <code>lists:reverse/1</code>，可以从源码中找到它的定义，但是这个定义通常是作为简单的声明，实际上编译器会使用这个函数在系统内部更为高效的版本</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>严格说来 Erlang 中并没有字符串</p>
</li>
<li><p>字符串实际上是整数列表的一种「速记&#x2F;代表」形式</p>
</li>
<li><p>可用 <code>$</code> 来表示字符串的整数值</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = $a.  <span class="comment">% 97</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-顺序型编程"><a href="#3-顺序型编程" class="headerlink" title="3. 顺序型编程"></a>3. 顺序型编程</h3><ul>
<li><p>beam<br>beam 是 Bogdan’s Erlang Abstract Machine 的缩写</p>
</li>
<li><p>匿名函数 fun</p>
<ul>
<li><p>fun 也可以拥有多个子句</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TempFun = <span class="keyword">fun</span> (&#123;square, X&#125;) -&gt; X*X;</span><br><span class="line">	          (&#123;double,X&#125;) -&gt; X+X</span><br><span class="line">  	  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>列表解析</p>
<ul>
<li><p>列表解析实现最简单的 Map</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">map</span><span class="params">(F, L)</span> = [F<span class="params">(X)</span> || X &lt;- L].</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>列表解析中的生成器实际上也可以起到过滤的作用</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ X || &#123;X, _&#125; &lt;- [ a,&#123;c, d&#125;, <span class="string">&quot;aa&quot;</span>, &#123;<span class="string">&quot;c&quot;</span>, e&#125;]].</span><br><span class="line"><span class="comment">% [ c, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>快排算法</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">qsort</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">    [];</span><br><span class="line"><span class="function"><span class="title">qsort</span><span class="params">([Pivot | T])</span> -&gt;</span></span><br><span class="line">			qsort([X || X &lt;- T, X &lt; Pivot])</span><br><span class="line">			++ [H] ++</span><br><span class="line">			qsort([X || X &lt;- T, X &gt;= Pivot]).</span><br></pre></td></tr></table></figure>
</li>
<li><p>毕达哥拉斯三元组</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pythag</span><span class="params">(N)</span> -&gt;</span></span><br><span class="line">	[&#123;A, B, C&#125; || A &lt;- lists:seq(<span class="number">1</span>, N),</span><br><span class="line">			  B &lt;- lists:seq(<span class="number">1</span>, N),</span><br><span class="line">			  C &lt;- lists:seq(<span class="number">1</span>, N),</span><br><span class="line">			  A + B + C =&lt; N,</span><br><span class="line">			  A*A + B*B =:= C*C</span><br><span class="line">	].</span><br></pre></td></tr></table></figure>
</li>
<li><p>全排列</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">perms</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">	[[]];</span><br><span class="line"><span class="function"><span class="title">perms</span><span class="params">(List)</span> -&gt;</span></span><br><span class="line">	[ [H | T] || H &lt;- L, T &lt;- perms(L -- [H]) ].</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>断言</p>
<ul>
<li><p>以 when 开头</p>
</li>
<li><p>用 <code>;</code> 隔开的断言，只要有一个为 <code>true</code> 则断言序列成立</p>
</li>
<li><p>用 <code>,</code> 隔开的断言，只有全部为 <code>true</code> 断言才会成立</p>
</li>
<li><p>合法的断言必须保证没有副作用，可以包含一些无副作用的 BIF ，但无法使用用户自定义的布尔表达式函数</p>
</li>
<li><p><code>and, or</code> 和 <code>andalso, orelse</code><br><a href="http://blog.caoyue.me/post/erlang-guard-and-andalso-or-orelse">Erlang Guard: and&#x2F;andalso, or&#x2F;orelse </a></p>
</li>
<li><p><code>==</code> 和 <code>=:=</code>，<code>/=</code> 和 <code>=/=</code></p>
<ul>
<li><p><code>=:=</code> 代表精确等于，在比较的时候不会对数据类型进行转换</p>
</li>
<li><p><code>=/=</code> 代表精确不等于</p>
</li>
<li><p>99% 的情况下应使用 <code>=:=</code> 或 <code>=/=</code></p>
</li>
<li><p>模式匹配中实际上是 <code>=:=</code>，即 <code>f(12)</code> 不会匹配到 <code>f(12.0)</code></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1.0</span>. <span class="comment">% true</span></span><br><span class="line"><span class="number">1</span> =:= <span class="number">1.0</span>。 <span class="comment">%false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>比较运算符的优先级</p>
<ul>
<li><p>不同数据类型也可以比较大小，其优先级是：</p>
<p><code>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary</code></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="string">&quot;1&quot;</span>&gt;&gt; &gt; [<span class="string">&quot;2&quot;</span>].   <span class="comment">% true</span></span><br><span class="line">[<span class="string">&quot;2&quot;</span>] &gt; &#123;<span class="string">&quot;3&quot;</span>&#125;. <span class="comment">% true</span></span><br><span class="line">&#123;<span class="string">&quot;3&quot;</span>&#125; &gt; &#x27;atom&#x27;. <span class="comment">% true</span></span><br><span class="line">atom &gt; <span class="number">1</span>. <span class="comment">% true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>record</p>
<ul>
<li>Record 实际上只是 tuple 的「伪装」，其本质上是一个 tuple</li>
</ul>
</li>
<li><p>case&#x2F;if</p>
<ul>
<li>Erlang 中不存在多个 case 匹配一个执行块的语法</li>
<li>Erlang 中任何表达式都是有值的，包括 case，因此可以有 <code>X = case ... end</code></li>
<li>Case 最后使用 <code>_</code> , if 最后使用 <code>true</code> 是保证所有分支得到匹配的方法</li>
</ul>
</li>
<li><p>累加器</p>
<ul>
<li>存储迭代过程中的临时容器</li>
</ul>
</li>
</ul>
</div><div><ul class="info"><li>2015-04-21</li><li><a href="/tags/erlang/">#erlang</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/the-eight-myths-of-erlang-performance/">Efficiency Guide：关于 Erlang 效率的 8 个迷思</a></div><div class="content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Premature optimization is the root of all evil. -- D.E. Knuth</span><br><span class="line">过早的优化是万恶之源. -- D.E. Knuth</span><br></pre></td></tr></table></figure>

<p>渣翻译，且作读书笔记 :)<br>原文：<a target="_blank" rel="noopener" href="http://www.erlang.org/doc/efficiency_guide/myths.html">The Eight Myths of Erlang Performance</a></p>
<hr>
<h4 id="迷思-1：Funs-很慢"><a href="#迷思-1：Funs-很慢" class="headerlink" title="迷思 1：Funs 很慢"></a>迷思 1：Funs 很慢</h4><p>funs 曾经是比较慢，不，应该说是特别慢，甚至比那个 <code>apply/3</code> 还慢。因为以前我们都是用一堆的语法糖啦，普通的元组啦,还有 <code>apply/3</code> 啦加上我们的奇技淫巧来实现的。<br>不过这些都是老黄历了，在 R6B 我们给了它专有的数据类型，并且在 R7B 做了更牛逼的优化，现在它的调用消耗已经降低到<br>本地调用和 <code>apply/3</code> 之间了。</p>
<blockquote>
<h4 id="不靠谱的-Note"><a href="#不靠谱的-Note" class="headerlink" title="不靠谱的 Note :"></a>不靠谱的 Note :</h4><ol>
<li>这里的 funs 应该是包含了 anonymous function 和 <code>F = fun FunctionName/Arity; F(Arg1, Arg2, ..., Argn)</code> 这些调用方式，在调用效率上这两种应该是基本等价的</li>
<li>在 OTP R5 和更早之前的版本中，funs 使用元组来表示，在之后的版本中有了专有的数据结构和优化[^1]</li>
<li>对于参数个数已知的函数，M:F([Arg1, Arg2, … , Argn]) 的调用优于 apply</li>
<li>使用 apply 调用的函数编译器无法优化，同时许多分析工具也无法分析其细节[^2]</li>
</ol>
</blockquote>
<h4 id="迷思-2：列表推导很慢"><a href="#迷思-2：列表推导很慢" class="headerlink" title="迷思 2：列表推导很慢"></a>迷思 2：列表推导很慢</h4><p>列表推导曾经是用 funs 来实现的，当然参照第一点，你懂的。<br>现在编译器把列表推导重写成一个普通的递归函数。当然，写成尾递归加反转的方式看起来会更快。真的吗？我们下回分解。</p>
<h4 id="迷思-3：尾递归函数远快于普通递归函数"><a href="#迷思-3：尾递归函数远快于普通递归函数" class="headerlink" title="迷思 3：尾递归函数远快于普通递归函数"></a>迷思 3：尾递归函数<strong>远</strong>快于普通递归函数</h4><p>我们都知道普通递归函数会在堆栈上留下一堆可能不再使用的数据，而垃圾回收器没有这么聪明，它会不停的拷贝这些数据。而尾递归中这些数据会很快消亡。</p>
<p>在 R7B 之前这么说没错。在 R7B 中，编译器会把从来不会被用到的数据引用重写成空列表，这样垃圾回器收器就不需要做无用功了。</p>
<p>当然即使是在优化过后，尾递归函数还是在大多数时候还是比一个普通递归要快。<br>实际上这跟每次递归调用中消耗的堆栈空间有关。一般来说普通递归每次消耗的堆栈空间比尾递归所分配的堆空间要多。更多的内存消耗意味着更多的垃圾回收，以及更多的堆栈遍历。</p>
<p>在 R12B 以及后续版本中我们又进行了优化，减少了递归调用需要的堆栈空间，普通递归和一个尾递归需要得内存空间在大部分情况下都差不多了。<code>lists:map/2</code>，<code>lists:filter/2</code>，列表推导，和其他一些普通递归函数占用的内存空间和尾递归实现一样了。</p>
<p>回到我们的老问题，哪一个更快？</p>
<p>看情况。在 Solaris&#x2F;Sparc 上，普通递归看起来稍微快那么一点点，即使对于那些有很多元素的列表。在 x86 架构上，尾递归要比普通递归快近 30%。</p>
<p>剩下的就是个人口味的选择了。如果需要追求极限的速度，就必须要自己<strong>衡量</strong>了。你再也不能拍着胸脯说尾递归在所有情况下都快于普通递归。</p>
<p>注意：一个尾递归函数，如果最后的结果不需要 <code>lists:reverse/1</code>，显然比一个递归函数要快，因为尾递归函数不需要构造数据项（例如，对列表求和函数）。</p>
<h4 id="迷思-4：-总是不好的"><a href="#迷思-4：-总是不好的" class="headerlink" title="迷思 4：++ 总是不好的"></a>迷思 4：<code>++</code> 总是不好的</h4><p><code>++</code> 操作符的名声总是很糟糕。其实你们都误解了它。主要是跟下面这种写法有关：</p>
<ul>
<li><strong>不要</strong>这样做<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">naive_reverse</span><span class="params">([H|T])</span> -&gt;</span></span><br><span class="line">    naive_reverse(T)++[H];</span><br><span class="line"><span class="function"><span class="title">naive_reverse</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">    [].</span><br></pre></td></tr></table></figure>
这是效率最低的反转列表的方式。因为 <code>++</code> 操作符原理是拷贝它左边的列表，结果就是一遍又一遍的拷贝……最终导致 n<sup>2</sup> 的复杂度。</li>
<li>像这样的使用是没问题的<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">naive_but_ok_reverse</span><span class="params">([H|T], Acc)</span> -&gt;</span></span><br><span class="line">    naive_but_ok_reverse(T, [H]++Acc);</span><br><span class="line"><span class="function"><span class="title">naive_but_ok_reverse</span><span class="params">([], Acc)</span> -&gt;</span></span><br><span class="line">    Acc.</span><br></pre></td></tr></table></figure>
每一个列表元素只会被拷贝一次。变化的值 <code>Acc</code> 在 <code>++</code> 操作符的右边，它不会被拷贝。</li>
<li>有经验的 Erlang 程序员会这么写<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">vanilla_reverse</span><span class="params">([H|T], Acc)</span> -&gt;</span></span><br><span class="line">    vanilla_reverse(T, [H|Acc]);</span><br><span class="line"><span class="function"><span class="title">vanilla_reverse</span><span class="params">([], Acc)</span> -&gt;</span></span><br><span class="line">    Acc.</span><br></pre></td></tr></table></figure>
这个会稍微更有效率一点，因为没有构建列表元素，只是直接拷贝它而已。（如果编译器没有自动将 <code>[H] ++ Acc</code> 重写为 <code>[H | Acc]</code>，那这种写法就毫无疑问的胜出了）</li>
</ul>
<h4 id="迷思-5：字符串很慢"><a href="#迷思-5：字符串很慢" class="headerlink" title="迷思 5：字符串很慢"></a>迷思 5：字符串很慢</h4><p>某种程度上来说，操作不当会导致字符串处理起来很慢。<br>在 Erlang 中，需要在字符串的使用方式上多注意。<br>另外如果打算用正则表达式，用 re 模块，不要用废弃的 regexp 模块。</p>
<blockquote>
<h4 id="不靠谱的-Note-1"><a href="#不靠谱的-Note-1" class="headerlink" title="不靠谱的 Note :"></a>不靠谱的 Note :</h4><ol>
<li>实际上确实是「慢」</li>
<li>这个「慢」倒并不一定体现在运行效率上，不如说是增加了编码的麻烦。</li>
<li>由于字符串作为列表处理，但字符串是无法避免大量的拼接、裁剪、反转等操作的，要避免额外的列表拷贝，而且在使用的时候必须很小心。</li>
</ol>
</blockquote>
<h4 id="迷思-6：修复一个-Dets-文件很慢"><a href="#迷思-6：修复一个-Dets-文件很慢" class="headerlink" title="迷思 6：修复一个 Dets 文件很慢"></a>迷思 6：修复一个 Dets 文件很慢</h4><p>修复时间和 Dets 文件中的记录（records）数量依然成正比，但是过去修复 Dets 非常非常慢，而现在已经改进了。</p>
<h4 id="迷思-7：BEAM-是一个基于堆栈的字节码虚拟机（因此很慢）"><a href="#迷思-7：BEAM-是一个基于堆栈的字节码虚拟机（因此很慢）" class="headerlink" title="迷思 7：BEAM 是一个基于堆栈的字节码虚拟机（因此很慢）"></a>迷思 7：BEAM 是一个基于堆栈的字节码虚拟机（因此很慢）</h4><p>实际上 BEAM 是一个 threaded-code 解释器。每条指令直接指向可执行 C 代码，指令调度是非常快的。</p>
<h4 id="迷思-8：用-来表示不使用的变量可以让程序更快"><a href="#迷思-8：用-来表示不使用的变量可以让程序更快" class="headerlink" title="迷思 8：用 _ 来表示不使用的变量可以让程序更快"></a>迷思 8：用 <code>_</code> 来表示不使用的变量可以让程序更快</h4><p>好吧，在古老的某个时候它是对的。<br>但是从 R6B 版本开始，BEAM 编译器已经足够聪明到发现哪些变量是没有使用的了。</p>
<p>[^1]: [1] <a target="_blank" rel="noopener" href="http://www.erlang.org/doc/programming_examples/funs.html">http://www.erlang.org/doc/programming_examples&#x2F;funs.html</a><br>[^2]: [2]《Erlang Programming》</p>
</div><div><ul class="info"><li>2015-03-18</li><li><a href="/tags/erlang/">#erlang</a></li><li><a href="/tags/translate/">#translate</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/about-erlang/">关于 Erlang 的一些想法</a></div><div class="content"><p>断断续续学习和使用 Erlang 几个月了，感觉跟之前看待这门语言有了点变化，还是挺有意思的。<br>作为初学者可能理解不太准确，但有些东西还是可以记录一下。</p>
<h4 id="关于函数式编程"><a href="#关于函数式编程" class="headerlink" title="关于函数式编程"></a>关于函数式编程</h4><ul>
<li><p>刚开始从其他语言转移到函数式语言的时候还害怕所谓的思维转换，实际上担心有点多余</p>
</li>
<li><p>入门并不难，能理解把循环写成尾递归的过程就基本没什么问题了</p>
</li>
<li><p>更少的心智负担，不再需要考虑是传值还是传引用，以及糟糕的副作用</p>
</li>
<li><p>在某些问题上更接近思维过程，不需要关心<strong>怎么做</strong>，只需要关心<strong>做什么</strong></p>
<p>比如 erlang 的 quicksort 可以这么写（注意这并不是高效的写法）：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">qsort</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">    [];</span><br><span class="line"><span class="function"><span class="title">qsort</span><span class="params">([Pivot | T])</span> -&gt;</span></span><br><span class="line">    qsort([X || X &lt;- T, X &lt; Pivot])</span><br><span class="line">    ++ [H] ++</span><br><span class="line">    qsort([X || X &lt;- T, X &gt;= Pivot]).</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="关于-Erlang"><a href="#关于-Erlang" class="headerlink" title="关于 Erlang"></a>关于 Erlang</h4><ul>
<li>语法简单<ul>
<li>没有大量的复杂的概念，不像某些《Thinking in XXXX》，看完巨厚一本书你发现自己还是啥也不懂</li>
<li>没有大量的奇技淫巧</li>
<li>大概看了一个多月，就基本可以把 ejabberd 代码从头到尾过一遍了</li>
<li>多看多用，我自己入门看的 《Erlang Programing》</li>
</ul>
</li>
<li>pattern match<ul>
<li>用过才知道有多好用</li>
<li>据说效率极其惊人</li>
<li>据说 C# 也要加入了</li>
</ul>
</li>
<li>并发<ul>
<li>process<br/><ul>
<li>需要并发执行一个任务的时候，最容易想到的就是新开一个 process 去处理</li>
<li>Erlang 的 process 是轻量的，开启和关闭消耗也小，不需要操心各种并发问题</li>
</ul>
</li>
<li>避免锁<ul>
<li>实际上开始写命令式代码的时候，我倒是不怎么担心死锁，担心的反而是应该在哪里加锁……</li>
<li>Erlang 的并发模型没有试图去解决锁的问题，而是从根源避免了它，那就是根本不允许全局变量共享（当然你需要共享，可以使用 ETS 或者外部数据库）</li>
<li>对我而言，这种做法减轻了不少心智负担</li>
</ul>
</li>
</ul>
</li>
<li>鼓励崩溃和热更新<ul>
<li>写代码的时候 Server 不用不停重启刷新的感觉太好</li>
</ul>
</li>
<li>效率<ul>
<li>入门快<br/><br>比如我这种不合格的程序猿看了一点《Erlang Programing》就开始写 ejabberd 的模块了</li>
<li>很容易用<br/><br>比如我这样不合格的程序猿也可以很顺利的手写稳定的服务器了</li>
</ul>
</li>
<li>部分不怎么好的地方<ul>
<li>字符串的处理<br/><ul>
<li>没有单独的字符串类型，而是用 List，从编码效率到处理效率，都不怎么好看</li>
<li>正则表达式的转义让人蛋疼无比</li>
</ul>
</li>
<li>unicode 字符<br/><br>可能一不小心就容易坑了，当然这点在慢慢改进了</li>
<li>record<br/><br>可能 OTP17 后的 map 会方便点</li>
<li>工具链<br/><br>从 IDE 到 debug profile 到 compile，体验都比较……怎么说呢，原始吧。<br>目前用 Intellij IDEA + Erlang Plugin，还凑合。</li>
<li>出了问题搜索不到<br/><br>嗯，这个时候就会嫌弃 Google 不够智能不能帮你写代码了</li>
</ul>
</li>
</ul>
</div><div><ul class="info"><li>2015-03-16</li><li><a href="/tags/programming/">#programming</a></li><li><a href="/tags/erlang/">#erlang</a></li></ul></div></div><div class="pager"><a class="pre" href="/page/3/">Previous</a>   <a class="next" href="/page/5/">Next</a></div></div><div class="footer"><div></div>©2021<a href="https://blog.caoyue.me"> 且听疯吟</a>. designed by<a href="https://caoyue.me" target="_blank"> caoyue</a>. powered by<a href="https://hexo.io/" target="_blank"> hexo</a></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
</div></body></html>