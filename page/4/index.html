<!doctype html><html lang=zh-hans><head><meta name=generator content="Hugo 0.98.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="如此生活三十年"><meta name=author content="caoyue"><title>且听疯吟</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry><div class=title><a href=https://blog.caoyue.me/post/whatsapp-and-erlang/>WhatsApp 的一点分析</a></div><div class=content><p>最近的项目需要做一个跨平台的 IM 服务，想要参考下其他项目的架构。国内分享不多，微信基本没有参考价值，毕竟 QQ 的积累在那。陌陌从招聘及据网上抓包的内容看是 XMPP 协议，看起来可能是 Java 的 openfire 之类的 XMPP 路线。<br>国外的分享稍微多一些，像 WhatsApp 每年都会做一些相关的分享，看起来有些参考价值。</p><h3 id=whatsapp-目前的数据>WhatsApp 目前的数据</h3><ul><li>月用户约为 4.65 亿</li><li>每天有 190 亿 消息进站/ 400 亿消息出站</li><li>6 亿图片,2 亿音频, 1 亿视频</li><li>峰值并发连接为 1.47 亿</li><li>消息峰值为每秒 34.2 万进站/ 71.2 万出站</li><li>节日期间流量更加惊人</li></ul><h3 id=支撑这些数据的硬件>支撑这些数据的硬件</h3><ul><li>约 550 台服务器</li><li>约 150 台 chat server, 可以支持 1.5 亿连接</li><li>约 250 台 mms 服务器</li><li>数据服务器内存为 512 GB，标准节点是 64 GB</li><li>除了视频，其他数据都存储在 SSD 上</li><li>超过 11000 个核心</li><li>Mnesia 使用了约 2TB 的内存</li></ul><h3 id=服务端架构>服务端架构</h3><ul><li>几乎全部使用 Erlang (经过了自己的改造)</li><li>服务器使用的是 FreeBSD 9.2</li><li>数据库是 Mnesia</li><li>ejabberd (做了大量改造，包括使用自己的协议替代 XMPP)</li><li>Yaws, lighttpd</li><li>非常重视性能监控</li></ul><h3 id=erlang>Erlang</h3><ul><li>大约 10 人的 Erlang 团队，工作包括开发和 ops</li><li>服务端基本全部使用 Erlang 开发</li><li>据说 Facebook Chat 开始也想要使用 Erlang ，但是由于优秀的 Erlang 工程师太难找而放弃了。不知真假，但是使用 Erlang 的好像的确不多。<br></li><li>团队对 Erlang 和 ejabberd 做了大量优化以满足越来越高的要求。但是在初期 Erlang 的表现就已经很好了</li><li>选择 Erlang 的原因是：<br><ul><li>只用很少的服务器就支撑起如此庞大的活跃用户，团队认为这归功于 Erlang</li><li>在 SMP 上的优秀扩展性</li><li>支持热更新</li></ul></li></ul><h3 id=ejabberd>ejabberd</h3><ul><li>最初从 ejabberd 开始</li><li>选择 ejabberd 是因为这是个非常优秀的开源 jabber 服务器</li><li>而且 ejabberd 是用 Erlang 写的</li><li>持续的对 ejabberd 进行重写和修改，包括从 XMPP 转换到内部开发协议、调整代码库以及重设计一些核心组件，并对 Erlang VM 做了大量的修改以获得高性能 Whats</li></ul><p>当年 WhatsApp 创始人去 Facebook 等企业求职被拒，据说原因之一是——年龄太大了。但也许只有老程序员才能坚持使用 Erlang 构建整个服务，并且用丰富的经验支撑起了整个 WhatsApp 庞大的架构——虽然主要是为了 WhatsApp 的庞大用户量而不单单是为了技术，Facebook 依然付出了 190 亿美元的代价。</p></div><div class=tags><ul class=info><li>2014-08-01</li><li><a href=https://blog.caoyue.me/tags/ejabberd>#ejabberd</a></li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/Qzzz/>Qzzz</a></div><div class=content><p>Windows 的计划任务功能不够用，于是试着写了个支持插件和动态加载的定时执行任务工具 <a href=https://github.com/caoyue/Qzzz>Qzzz</a>，暂时是个坑&mldr;</p><h1 id=qzzz>Qzzz</h1><p>A scheduler app for windows.</p><h3 id=how-to-use>How to use</h3><ul><li><strong>Run as a windows service</strong><br><br>Use <code>Install.bat</code> to install the <code>QzzzService</code></li><li><strong>Run as a console</strong><br><br>Run <code>Qzzz.exe</code> and do not close the console.</li></ul><h3 id=create-a-plugin>Create a plugin</h3><ul><li><p>create a config file <code>qzzz.json</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Id&#34;</span><span class=p>:</span> <span class=s2>&#34;323ADBF530C4307B336C670B3F5BD229&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Name&#34;</span><span class=p>:</span> <span class=s2>&#34;ToastPluginDemo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Version&#34;</span><span class=p>:</span> <span class=s2>&#34;1.0&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Description&#34;</span><span class=p>:</span> <span class=s2>&#34;Toast plugin demo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;CronExpression&#34;</span><span class=p>:</span> <span class=s2>&#34;*/15 * * * * ?&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;StartAt&#34;</span><span class=p>:</span> <span class=s2>&#34;2014-06-01 00:00:00&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;EndAt&#34;</span><span class=p>:</span> <span class=s2>&#34;2014-07-01 00:01:00&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;PluginFileName&#34;</span><span class=p>:</span> <span class=s2>&#34;Qzzz.ToastPluginDemo.dll&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Author&#34;</span><span class=p>:</span> <span class=s2>&#34;caoyue&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Url&#34;</span><span class=p>:</span> <span class=s2>&#34;https://github.com/caoyue/Qzzz&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><code>Id</code> should be a guid string</li><li><code>CronExpression</code> is a Quartz Cron Expression, a little different from *nix</li><li><code>StartAt</code> and <code>EndAt</code> is optional</li></ul></li><li><p>Create a CSharp library project</p></li><li><p>Add <code>Qzzz.Plugin.dll</code> to the references</p></li><li><p>Implement <code>IPlugin</code> interface</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-CSharp data-lang=CSharp><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>SimplePlugin</span> <span class=p>:</span> <span class=n>IPlugin</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>Execute</span><span class=p>(</span><span class=n>PluginContext</span> <span class=n>pluginContext</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do your job here...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>bool</span> <span class=n>Pause</span><span class=p>(</span><span class=n>PluginContext</span> <span class=n>pluginContext</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// pause job while the return is true...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>You can find a demo in <code>Plugins\Qzzz.SimplePluginDemo</code></li><li>Add <code>Qzzz.Toast.dll</code> to use toast notification on windows 8/8.1, like <code>Plugins\Qzzz.ToastPluginDemo</code></li></ul></li><li><p>Build your project and copy the plugin folder to <code>Qzzz\Plugins</code></p></li></ul></div><div class=tags><ul class=info><li>2014-06-28</li><li><a href=https://blog.caoyue.me/tags/project>#project</a></li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/use-toast-in-windows-desktop-app/>在 Windows 8 Desktop App 中使用 Toast Notification</a></div><div class=content><p>最近坐久了就感觉腰酸背痛，想要做个定时提醒，提醒自己定时休息走动一下。<br>现在的定时提醒软件要么太复杂要么太难看，本来想要使用系统自带的定时任务，但是 Windows 8 中废弃了计划任务中的弹出消息功能。</p><p>想到 Windows 8 中新增了 Toast Notification，能不能利用这个方式来提醒？但是没见过 Desktop app 使用这个功能，一直以为是 Windows Store App 专用的 API。<br>在翻 MSDN 的时候发现原来 Metro Toast Notification 适用范围也包括 Desktop app。然后折腾了一下，居然成功了:)</p><p><img src=http://ww4.sinaimg.cn/large/3e69b0ccgw1ehmsd3xs5xj20eu06sjs0.jpg alt=demo></p><h3 id=在-desktop-app-中使用-windows-8windows-rt-api>在 Desktop app 中使用 Windows 8/Windows RT API</h3><p>Toast 位于 <code>Windows.UI.Notifications</code> 命名空间中，但是默认情况下没法引用该命名空间，因为其中一些 API 在 Desktop 环境下是有限制的。幸运的是 Toast Notification 不属于其中。可以从 MSDN 上找到这些 API 的详细信息，其中就包括了适用范围 。</p><ul><li>建立一个 Console Application，为了引用 <code>Windows.UI.Notifications</code>，需要编辑项目文件 <code>.csproj</code>。在第一个 <code>PropertyGroup</code> 节点中添加</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Xml data-lang=Xml><span class=line><span class=cl><span class=nt>&lt;TargetPlatformVersion&gt;</span>8.0<span class=nt>&lt;/TargetPlatformVersion&gt;</span>
</span></span></code></pre></div><ul><li>重新 Load 项目，添加引用。可以看到引用管理器左边添加了新的一列 <code>Windows</code>，添加 <code>Windows.Data.Xml.Dom</code> <code>Windows.UI.Notifications</code><br><code>Windows.Foundation</code> 的引用。</li><li>添加对 <code>System.Runtime</code> 和 <code>System.Runtime.InteropService.WindowsRuntime</code> 的引用。</li></ul><h3 id=使用-console-app-创建-toast-notification>使用 Console app 创建 Toast Notification</h3><p>接下来需要创建一个 <code>ToastTemplateType</code> 对应的 <code>XmlDocument</code> 对象。<br>关于不同的 <code>ToastTemplateType</code> ，可以在 <a href=http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.notifications.toasttemplatetype>MSDN</a> 找到详细的信息。<br>以 <code>ToastTemplateType.ToastImageAndText04</code> 为例，这是一个带有 Image 和三行文字的 Toast Template</p><ul><li>创建 Template 如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-CSharp data-lang=CSharp><span class=line><span class=cl><span class=n>XmlDocument</span> <span class=n>toastXml</span> <span class=p>=</span> <span class=n>ToastNotificationManager</span><span class=p>.</span><span class=n>GetTemplateContent</span><span class=p>(</span><span class=n>ToastTemplateType</span><span class=p>.</span><span class=n>ToastImageAndText04</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Windows</span><span class=p>.</span><span class=n>Data</span><span class=p>.</span><span class=n>Xml</span><span class=p>.</span><span class=n>Dom</span><span class=p>.</span><span class=n>XmlNodeList</span> <span class=n>stringElements</span> <span class=p>=</span> <span class=n>toastXml</span><span class=p>.</span><span class=n>GetElementsByTagName</span><span class=p>(</span><span class=s>&#34;text&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>stringElements</span><span class=p>[</span><span class=m>0</span><span class=p>].</span><span class=n>AppendChild</span><span class=p>(</span><span class=n>toastXml</span><span class=p>.</span><span class=n>CreateTextNode</span><span class=p>(</span><span class=s>&#34;Head&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>stringElements</span><span class=p>[</span><span class=m>1</span><span class=p>].</span><span class=n>AppendChild</span><span class=p>(</span><span class=n>toastXml</span><span class=p>.</span><span class=n>CreateTextNode</span><span class=p>(</span><span class=s>&#34;Content1&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>stringElements</span><span class=p>[</span><span class=m>2</span><span class=p>].</span><span class=n>AppendChild</span><span class=p>(</span><span class=n>toastXml</span><span class=p>.</span><span class=n>CreateTextNode</span><span class=p>(</span><span class=s>&#34;Content2&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>imagePath</span> <span class=p>=</span> <span class=s>&#34;file:///&#34;</span> <span class=p>+</span> <span class=n>Path</span><span class=p>.</span><span class=n>GetFullPath</span><span class=p>(</span><span class=s>&#34;toastImageAndText.png&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Windows</span><span class=p>.</span><span class=n>Data</span><span class=p>.</span><span class=n>Xml</span><span class=p>.</span><span class=n>Dom</span><span class=p>.</span><span class=n>XmlNodeList</span> <span class=n>imageElements</span> <span class=p>=</span> <span class=n>toastXml</span><span class=p>.</span><span class=n>GetElementsByTagName</span><span class=p>(</span><span class=s>&#34;image&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>imageElements</span><span class=p>[</span><span class=m>0</span><span class=p>].</span><span class=n>Attributes</span><span class=p>.</span><span class=n>GetNamedItem</span><span class=p>(</span><span class=s>&#34;src&#34;</span><span class=p>).</span><span class=n>NodeValue</span> <span class=p>=</span> <span class=n>imagePath</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>创建 Toast 并添加事件：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-CSharp data-lang=CSharp><span class=line><span class=cl><span class=n>ToastNotification</span> <span class=n>toast</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ToastNotification</span><span class=p>(</span><span class=n>toastXml</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>toast</span><span class=p>.</span><span class=n>Activated</span> <span class=p>+=</span> <span class=n>ToastActivated</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>toast</span><span class=p>.</span><span class=n>Dismissed</span> <span class=p>+=</span> <span class=n>ToastDismissed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>toast</span><span class=p>.</span><span class=n>Failed</span> <span class=p>+=</span> <span class=n>ToastFailed</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>弹出 Toast:<br><br>在 Desktop app 中使用 Toast 时需要一个 App id，否则会出现 <code>找不到元素</code> 的异常。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-CSharp data-lang=CSharp><span class=line><span class=cl><span class=kt>string</span> <span class=n>appId</span> <span class=p>=</span> <span class=s>&#34;Microsoft.Samples.DesktopToastsSample&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ToastNotificationManager</span><span class=p>.</span><span class=n>CreateToastNotifier</span><span class=p>(</span><span class=n>appId</span><span class=p>).</span><span class=n>Show</span><span class=p>(</span><span class=n>toast</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=其他>其他</h3><p>这里是个简单的示例项目源码 <a href=https://github.com/caoyue/Windows8ToastNotification>Windows8ToastNotification</a><br>考虑用这个写个小玩具，可以获取关注的 Twitter、世界杯比分、天气预报之类的通知，支持 API 自定义，想想还挺好玩的，完成后会更新到 Github。</p></div><div class=tags><ul class=info><li>2014-06-22</li><li><a href=https://blog.caoyue.me/tags/windows>#windows</a></li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/tai-shan/>泰山游记</a></div><div class=content><h3 id=准备>准备</h3><p>好吧，其实没啥准备，完全是一场说滚就滚的旅行。</p><h3 id=吃>吃</h3><p>直接从车站打的到了天外村。一家叫做「麓山鲁菜馆」的饭馆，还没等到吃完就后悔了，价格略贵而且难吃。<br>比如有道特色菜叫「泰山三美」，上来才发现就是白菜豆腐汤，不说食材质量不怎么好，还差一美呢，问了老板说是泰山水——这不叫「珍珠翡翠白玉汤」真是可惜了……</p><h3 id=上山>上山</h3><p>徒步上山都是从红门开始的。隔天外村也比较近。到的时候是晚上八点左右。<br>挺热闹的，到处都是专业和不专业的背包客，很多大妈在推销她们的登山装备。有些还是挺有用的。比如拐杖，竹子做的，很便宜，两元一支。开始不想买来着，后来大妈吓唬我说没这个很难登上去，我就没骨气的买了……后来事实证明确实也挺有用的，基本是人手一个。<br>由于我们是晚上登山，所以买了手电，确实也有用，因为山上没路灯，不带连上厕所都得摸黑。另外看天气可能下雨，买了雨衣，挡雨防寒都不错。</p><p>然后由于兴奋，犯了个错误。吃完饭过来就开始爬山了。其实应该先休息消化一会儿。<br>另外一个错误就是一开始就一顿猛冲，还没到中天门就已经累的不行了。结果听人说还不到一半，后面更陡，要不是晚上缆车不开，估计就直接坐缆车了（所以晚上爬山还有这么个好处，想放弃也没办法，上不去也下不来，只能往上爬了）。</p><p>过了中天门，确实更陡。<br>台阶从面前往上铺开，简直一眼望不到头，只看到天边不知道是星光还是灯光。<br>我这个除了每天下楼买宵夜之外没有其他锻炼的新手爬山者心里一股感觉油然而生，「我 X，真他妈高！」<br>爬过这一折，还没来得及回望下面的芸芸众生感叹一下「老子真牛 X 」就发现面前又冒出来一条比之前更长更陡的路，简直要怀疑人生到底是他妈为了为什么人类何苦要自我折磨。</p><p>不过还好和朋友一起的，有人一起支持鼓励的感觉好多了。也学会了不要看其他地方，一心看着脚下的台阶，一步一步走。路上看到不少人感觉都是机械式的在动了……<br>到了极限的时候感觉腿都发软，T 恤也不知道湿了又干几次了。不过真的像以前体育老师说的，超过了极限反而就好了。<br>后来到了十八盘的时候，爬上去之后还小小得瑟了下「十八盘也不过如此」然后收到了一堆鄙视的眼神……</p><p>到了南天门往下看的时候还真的是不敢相信。看远处的万家灯火和下面的人群，简直难以想象是自己一步一步爬上来的。<br>然后去日观峰等日出，到的时候大概是夜里一点左右，花了五个小时从山脚上来。对我来说，平时估计步行五个小时都够呛……</p><p>日观峰上都是租个军大衣就靠着山石或者躺着休息下的人群，挺热闹的，打牌玩杀人游戏的都有。<br>结果天公不作美，下起了小雨，一直下下停停的。到了凌晨虽然雨停了，不过一点日出的迹象都没了。<br>虽然没看到日出云海，但是见识了下人海。夜里没发现，天亮才发现满山都是各种奇葩姿势等日出的人，不知道哪位喊了句「山上的朋友你们好吗」莫名其妙的就戳中笑点了……</p><h3 id=下山>下山</h3><p>没看到日出只能下山了。而且还下起了雨。极其影响心情啊。<br>不过慢慢发现雨中也别有一番趣味来着，顺便好好欣赏了下晚上上山错过的景色。<br>就是下山的时候看着下面腿发抖，真怕一不小心就直接圆润的滚下去了……所幸最后平安下山 :)<br>也有缆车下山，不过只到中天门。之后可以坐旅游大巴或者走下山。</p><p>下山比上山还是快得多，除了小心一点之外也没上山那么累，全程没有怎么休息，用了三个小时左右，下来之后差点出租车上睡着……</p><h3 id=tips>Tips</h3><p>推荐大家准备：</p><ul><li>2L 左右的饮用水。如果怕负担的话山上每隔一段有卖，基本是 5 块左右。有盐水之类的更好</li><li>零食，补充体力，巧克力糖什么的不错</li><li>山下卖的拐杖，上山下山都挺好用</li><li>如果是晚上登山或者下山，请带手电筒</li><li>看天气预报，如果可能下雨请带雨衣</li><li>毛巾。擦汗用，虽然擦不过来……</li><li>防寒衣物，羽绒服什么的。没有洁癖的可以在山上租 10 块一件的军大衣，防寒效果不错</li><li>Money。山上每过一段都会有小商店，需要的东西基本都可以买到，价格当然也会贵点不过也还好，另外木有刷卡的地方</li><li>移动电源。山上下山加起来可能要七八个小时，对微博狂人来说手机电源可能不够用，还是带个移动电源比较保险</li><li>朋友。登上去之后简直难以相信自己能爬上来。都是靠朋友支持鼓励，聊聊天插科打诨之类的也很能放松。如果自己一个人来的就在路上勾搭个基友/妹子吧。山上大部分地段 3G 信号都不错，没事发个微博朋友圈什么的炫耀下也不错</li><li>信心。千万不要想放弃，也不要想还有多远。反正走着走着就发现到南天门了。感觉撑不住的时候休息下缓一缓，宁可走一回站几分钟休息下，千万不要休息太长时间，因为一旦完全放松下来就很难有斗志继续了</li></ul><img src=http://ww2.sinaimg.cn/large/3e69b0ccgw1ehqra6lwgxj21400u0wjd.jpg target=_blank alt=雨中泰山 title=雨中泰山 width=700></div><div class=tags><ul class=info><li>2014-06-01</li><li><a href=https://blog.caoyue.me/tags/life>#life</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/ip-address-as-octal/>原来 IP 地址还可以用混合进制表示</a></div><div class=content><p>今天发现 Google 的时候发现收录了一个奇怪的地址，形如 <code>23.244.200.000000000354</code>，而且这个地址居然还是可以访问的。很显然这不是域名，尝试 ping 一下，返回地址来自于 <code>23.244.200.236</code>，可以看出 <code>000000000354</code> 是 <code>236</code> 的八进制表示形式。</p><p>###混合进制<br>查了下，原来 IP 地址居然可以混合进制来显示……前导的 0 的数字会被当作八进制来处理。而且可以同时使用不同进制：包括十六进制、八进制和十进制。<br>比如 <code>http://0x17.244.0xc8.00000354</code> 这样奇葩的地址也是可以访问的……</p><p>###DWORD 形式的 IP<br>还有更奇葩的，整数型的 IP —— 比如这个：<code>http://401918188</code> ，同样可以访问。<br>转换过程是将 <code>23.244.200.236</code> 转换为二进制形式，不足 8 为的数字用 0 补足： <code>00010111111101001100100011101100</code>，然后将这一串二进制数字转换为整数，即可得到整数型的 IP 地址。<br>当然，如果将这个整数换成其他进制也是可以的，比如：<br><code>http://02775144354</code> 和 <code>http://0x17f4c8ec</code></p><p>###可省略的 0<br>当然，奇葩还没有结束。比如这样的 IP 地址 <code>192.168.1</code> 也是可以访问的……因为某部分为 0 则可以省略。OK，那我们怎么知道省略的是哪一部分呢？别急，「聪明」的标准的制定者们早就想到这一点了，规则如下：</p><table><thead><tr><th>abbr</th><th>IP</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.A</td></tr><tr><td>A.B</td><td>A.0.0.B</td></tr><tr><td>A.B.C</td><td>A.B.0.C</td></tr><tr><td>A.B.C.D</td><td>A.B.C.D</td></tr></tbody></table><p>###其他<br>原 IP <code>127.0.0.1</code> 按上面的方法改变下形式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>http://0x7f.0.000000000001
</span></span><span class=line><span class=cl> http://2130706433
</span></span><span class=line><span class=cl> http://017700000001
</span></span><span class=line><span class=cl> http://0x7f000001
</span></span><span class=line><span class=cl> http://127.1
</span></span><span class=line><span class=cl> ……
</span></span></code></pre></div><p>这个特性在不同的平台上是由 socket 库实现的。在 Linux 上是 <a href=http://linux.die.net/man/3/inet_aton>inet_aton</a> ，在 Windows 上是 <a href=http://msdn.microsoft.com/en-us/library/windows/desktop/ms738563>inet_addr</a> 。<br>但是相关的标准文档我还没有找到。<code>rfc 2396</code> 和 <code>rfc 1738</code> 也都是语焉不详。</p><p>btw，虽然主流浏览器和很多其他软件支持这种表示方法。但在某些地方可能导致问题，一般都不推荐这种做法，比如 <a href=http://support.apple.com/kb/TA22205>Mac OS X: Do Not Use Leading Zeros in IP Address</a></p></div><div class=tags><ul class=info><li>2014-05-18</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/csharp-compute-expression/>C# 中缀表达式计算</a></div><div class=content><p>给出一个字符串的计算表达式如 <code>1+2*(3-4)/5</code> ，不使用其他库如何计算其结果？<br>在脚本语言中这也许不算什么问题，但是在 C# 这样的静态语言中则需要我们自己来解析表达式实现计算。</p><h3 id=中缀表达式>中缀表达式</h3><p>中缀表达式 (Infix Expression)，即形如 <code>a+b-c*d</code> 这样的表达式。运算符位于两个操作数的中间，也是我们习惯的写法。但是这种写法对于计算机运算来说是不够效率的，每次计算表达式，都需要先分析整个表达式，然后根据优先级来逐步计算。</p><h3 id=后缀表达式>后缀表达式</h3><p>后缀表达式 (Suffix Expression)，也叫做逆波兰表达式，即将运算符记在操作数之后，如 <code>a+b</code> 记作 <code>a b +</code>。使用后缀表达式不需要关注运算符的优先级，计算机能够按表达式从左向右来计算，从而利用堆栈并提高计算效率。</p><h3 id=表达式转换>表达式转换</h3><p>既然后缀表达式有这些好处，那么如何将常见的中缀表达式转为后缀表达式？一般使用 <a href=http://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95>调度场算法</a>。实际上语法树的后序遍历也是后缀表示法。</p><p>简单分析下从中缀表达式到后缀表达式的过程：</p><ol><li>定义两个栈 Operand（操作数栈）和 Operator（运算符栈）；</li><li>从左到右遍历字符串，按如下规则：<ul><li>如果该字符为左括号，直接压入 Operator 栈中；</li><li>如果该字符为右括号，则依次弹出 Operator 栈中的元素，并压入 Operand 栈中，直到遇到左括号为止。将左括号弹出，但是不压入栈；</li><li>如果该字符是操作符：<ul><li>首先将临时变量中两操作符之间的字符取出，此处可以判断是否是数字，如果不是，则说明字符串不是标准的表达式；如果是，将其存入 Operand 栈中并清空临时变量；</li><li>查看 Operator 栈中是否存在运算符：<ul><li>如不存在，将该操作符压入 Operator 栈中；</li><li>如存在，判断栈顶元素是否是左括号，如果是，将运算符压入 Operator 栈中；否则，比较该操作符和 Operator 栈顶操作符的优先级：<ul><li>该操作符优先级较高，将该操作符压入 Operand 栈中；</li><li>该操作符优先级较低或相等，则弹出 Operator 栈顶元素，将其压入 Operand 中，然后循环执行比较和弹出操作，直到遇到左括号或 Operator 为空或栈顶操作符优先级低于该操作符，将该运算符压入 Operator 栈中；</li></ul></li></ul></li></ul></li><li>如果该字符不是操作符也不是括号，则将其存入临时变量；</li></ul></li><li>循环完成，将临时变量（即最后一个数字）压入 Operand 栈中；</li><li>将 Operator 栈依次弹出并压入到 Operand 栈中；</li><li>将 Operand 栈按从底部到顶部读取，即可记作后缀表达式。</li></ol><h3 id=后缀表达式计算>后缀表达式计算</h3><ol><li>将后缀表达式转换成堆栈 Suffix；</li><li>定义一个新的栈 Result;</li><li>依次弹出 Suffix 栈顶元素：<ul><li>如果该元素不是运算符，将其压入 Result 栈中；</li><li>如果该元素是运算符，则弹出 Result 顶端两个元素（即 Pop 两次），将其作为左操作数和右操作数，按该运算符进行运算，将结果压入 Result 栈中；</li></ul></li><li>Result 栈顶元素即计算结果</li></ol><p>这是简单的表达式计算方法，但是运用该原理，我们可以实现包含自定义函数的复杂计算。</p><p>Demo:<br><code>gist ea924d24131d7c48dc9c</code></p></div><div class=tags><ul class=info><li>2014-04-28</li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/wox-plugin/>A Wox plugin let you search firefox bookmarks</a></div><div class=content><p>###关于 Wox<br>最初是看到 V2EX 上的一个帖子 <a href=https://v2ex.com/t/93922>v2ex.com/t/93922</a>，然后作者真的去写了并且发布在 Github 上了。<br>Windows 上的快速启动软件已经很多了，但是不管从功能、界面乃至理念来讲和 Alfred 都相去甚远，尤其是 Workflow 的概念。<br>Wox 现在发布了第一个 beta 版本，看上去已经很不错了，希望这个项目能坚持下去吧。</p><p>###Wox.Plugin.FirefoxBookmarks<br>Wox 的插件开发也比较简单，可以参考文档。写了个搜索 Firefox 书签的插件。<br>原理是读取 Firefox 书签，然后根据参数查询返回结果。</p><p>首先我们要获取到 Firefox Profile 的位置。Firefox 支持多个 Profile，我们可以获取到默认的 Profile 。Firefox Profile 路径及配置都保存在 <code>%appdata%\Mozilla\Firefox\profiles.ini</code> 中。打开这个配置文件可以看到每个 Profile 配置包含的参数：&ldquo;IsRelative&rdquo; 值为 &ldquo;0&rdquo; 代表绝对路径，&ldquo;1&rdquo; 代表相对路径；&ldquo;Default=1&rdquo; 代表默认启动的 Profile。<br>虽然可以通过引入 WindowsAPI （即 <code>[DllImport("kernel32")]</code>）来解析 ini 配置文件，不过无需如此小题大做，毕竟只需要找到其中一行即可。下面是一个读取 Firefox 默认 Profile 的方法：</p><p><code>gist 11324134</code></p><p>这种读取方法对某些 Portable 版本无效，所以同时也提供了手动配置路径的方法。</p><p>Firefox 书签以及历史记录都保存在 Profile 里的 places.sqlite 中。其表结构可以参考 <a href=https://developer.mozilla.org/en-US/docs/The_Places_database>developer.mozilla.org/en-US/docs/The_Places_database</a>。<br>其中 moz_bookmarks 表中存储了书签及书签文件夹，且通过外键 fk 和 moz_places 关联。<br>Sqlite 的查询语法基本和标准 SQL 相同，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>moz_places</span><span class=p>.</span><span class=n>url</span><span class=p>,</span><span class=w> </span><span class=n>moz_bookmarks</span><span class=p>.</span><span class=n>title</span><span class=p>,</span><span class=n>parent</span><span class=p>.</span><span class=n>title</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>parent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>moz_bookmarks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>JOIN</span><span class=w> </span><span class=n>moz_places</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>moz_places</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>moz_bookmarks</span><span class=p>.</span><span class=n>fk</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>JOIN</span><span class=w> </span><span class=n>moz_bookmarks</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>parent</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>parent</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>moz_bookmarks</span><span class=p>.</span><span class=n>parent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>moz_bookmarks</span><span class=p>.</span><span class=k>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span></code></pre></div><p>PS. 另一个快速切换电源计划的插件 <a href=https://github.com/caoyue/Wox.Plugin.PowerPlan>Wox.Plugin.PowerPlan</a></p></div><div class=tags><ul class=info><li>2014-04-25</li><li><a href=https://blog.caoyue.me/tags/project>#project</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/firefox-form-cache/>Firefox 的表单缓存「Bug」</a></div><div class=content><p>##问题<br>在使用 Firefox 测试网站的时候遇到一个奇怪的问题。<br>把一份数据写入类型为 hidden 的 input 中时，比如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>input</span> <span class=na>type</span><span class=o>=</span><span class=s>&#34;hidden&#34;</span> <span class=na>value</span><span class=o>=</span><span class=s>&#34;@Model.Count&#34;</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;Count&#34;</span> <span class=p>/&gt;</span>
</span></span></code></pre></div><p>然后在用 Javascript 修改这个值，比如后台数据原为 0，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>count</span> <span class=o>=</span> <span class=nb>parseInt</span><span class=p>(</span><span class=nx>$</span><span class=p>(</span><span class=s2>&#34;#Count&#34;</span><span class=p>).</span><span class=nx>val</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=nx>$</span><span class=p>(</span><span class=s2>&#34;#Count&#34;</span><span class=p>).</span><span class=nx>val</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>不提交表单，刷新页面，发现 <code>$("#Count").val()</code> 的值却不是后台数据的 0，而是我们修改过后的值，这个值被缓存了。</p><p>##原因<br>使用其他浏览器测试可以发现，这个问题仅出现在 Firefox 中。从而可以考虑是否 Firefox 对表单缓存的实现「有问题」。</p><p>##解决<br>设置 form 的 <code>autocomplete="off"</code></p></div><div class=tags><ul class=info><li>2013-09-07</li><li><a href=https://blog.caoyue.me/tags/firefox>#firefox</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/whoosh-search/>Whoosh 全文搜索</a></div><div class=content><p>Whoosh 是一个纯 Python 实现的全文搜索组件。基础架构和 Lucene 比较像。使用试了试，记录一些东西。</p><p><strong>中文分词</strong><br>Whoosh 本身只有英文分词，因此需要添加中文分词组件。<br>最后选择了 <a href=https://github.com/fxsjy/jieba>Jieba</a> 这个 Python 中文分词组件，初步测试分词效果还不错。有时间会把几个中文分词组件对比一下看看。<br>Jieba 已经封装好了 ChineseAnalyzer for Whoosh，只需要引用 <code>from jieba.analyse import ChineseAnalyzer</code> 来替换 Whoosh 的 Analyzer 即可。</p><p><strong>HTML 抽取</strong><br>对于纯文本直接分析建立索引即可。<br>而对于 HTML 文本，我们需要先将其中的文本抽取出来再进行运行分析程序。否则其中的 HTML 标签将会被当作文本来分析，比如搜索 &ldquo;span&rdquo; 将会得到所有包含 <code>&lt;span>&lt;/span></code> 的内容。举个例子，用 HTMLParser 来提取文本，其他类似功能的模块也有不少。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>html_strip</span><span class=p>(</span><span class=n>html</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=kn>from</span> <span class=nn>HTMLParser</span> <span class=kn>import</span> <span class=n>HTMLParser</span>
</span></span><span class=line><span class=cl>    <span class=n>html</span> <span class=o>=</span> <span class=n>html</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>html</span> <span class=o>=</span> <span class=n>html</span><span class=o>.</span><span class=n>strip</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>parse</span> <span class=o>=</span> <span class=n>HTMLParser</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>parse</span><span class=o>.</span><span class=n>handle_data</span> <span class=o>=</span> <span class=n>result</span><span class=o>.</span><span class=n>append</span>
</span></span><span class=line><span class=cl>    <span class=n>parse</span><span class=o>.</span><span class=n>feed</span><span class=p>(</span><span class=n>html</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>parse</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span></code></pre></div><p><strong>关键词 Highlight</strong><br>默认的高亮结果只会包含结果命中的部分碎片，需要不同展示可以使用不同的 Fragmenters 。比如展示全文需要 <code>whoosh.highlight.WholeFragmenter</code> 。<br>然而 HTML 的高亮有一个问题。简单的基于匹配的替换带来的问题就是 HTML 标签的属性内容也被替换了，比如 <code>a</code> 标签的 <code>href</code> 属性，导致结构发生错乱。对此除了自己写 HTMLFragmenter 之外似乎没有现成的解决办法。<br>考虑到服务端解析的效率问题，放弃 Whoosh 和服务端的高亮，使用 js 在客户端高亮(其原理也是通过判断关键词前后的标签匹配，并经过一系列的正则替换最终实现只替换文本关键词而忽略标签)。试过效果比较好的高亮方案，<a href=https://github.com/jbr/jQuery.highlightRegex>https://github.com/jbr/jQuery.highlightRegex</a><br>只需要在 <code>results = searcher.search(q, terms=True)</code> 时设置 <code>terms=True</code> 即可从 results 或 results 的 hit 中取得关键词 <code>terms = results.matched_terms()</code>，然后将关键词传递给前端用 highlightRegex 来高亮。</p><p><strong>结果分页</strong><br>对于结果的分页，whoosh 提供了 <code>search_page</code> 方法。但是这个方法可以说是个半成品。首先，search_page 方法支持的参数设置较少，很多功能没法在 search_page 中完成。其次，search_page 方法返回的结果为 ResultsPage 类型，而 <code>search</code> 方法返回 Results 类型，且这两者之前并无继承关系，Results 中包含的属性比 ResultsPage 丰富得多。<br>最重要的是，到目前为止，使用 search_page 方法从所有结果中获取中间页时，其性能与使用 search 获取所有结果然后手动分页是一样的，从源代码可以看到 search_page 仅仅是对 search 的一次封装。search_page 仅仅是出于方便使用的功能（虽然我也没看出 search_page 存在的意义和方便在哪…… ）<br>因此，还是使用 search 的 limit 参数来满足分页需求。limit 参数限制了返回的结果数目。可以使用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>results</span> <span class=o>=</span> <span class=n>searcher</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>limit</span><span class=o>=</span><span class=n>page</span> <span class=o>*</span> <span class=n>pagesize</span><span class=p>)</span>
</span></span></code></pre></div><p>来控制返回的结果，然后使用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>results</span><span class=p>[(</span><span class=n>page</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>pagesize</span><span class=p>:</span><span class=n>page</span> <span class=o>*</span> <span class=n>pagesize</span><span class=p>]</span>
</span></span></code></pre></div><p>获取指定的分页。</p><p><strong>词典选择</strong><br>中文分词的效果有很大一部分取决于词典，但并不是词典越大越全越好。分析词典 Build Trie 是一个比较消耗 CPU 的过程（虽然只是在第一次需要进行这个过程，之后会读取 Cache 中的 Model），越大的词典分析时消耗的资源也越大。因此根据实际情况选择词典比较好。<br>此外，如果需要分析的文本包含许多专业性词汇，也可以考虑设置自定义词典来增强歧义分析能力。<br>词典的设置很简单，使用 <code>jieba.set_dictionary(dict_path)</code> 即可。</p><p><strong>其他</strong></p><p>虽然 Whoosh 的性能不尽如人意，相关资料和扩展也缺乏。<br>但总体来说，对于小规模的使用，whoosh 开发简单，基本可以满足需求，如果使用过 Lucene 也可以很容易上手。而且纯 Python 实现，看源代码也方便。</p></div><div class=tags><ul class=info><li>2013-08-05</li><li><a href=https://blog.caoyue.me/tags/python>#python</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/project-timeline/>Project Timeline</a></div><div class=content><p>做了一个同步微博、Twitter 和 Rss Feed 到本地的工具，方便保存和查看自己的数据，以及用自己的数据做一些好玩的事。</p><hr><p><strong><a href=https://github.com/caoyue/MyTimeline>MyTimeline</a></strong></p><ul><li><p>聚合分散在各个网站上的 Timeline<br>Support:</p><ul><li>Rss Feed</li><li>Twitter Oauth</li><li>Weibo Oauth</li></ul></li><li><p>同步发送消息到第三方<br><a href=http://i.caoyue.me/update>/update</a><br>Support:</p><ul><li>Twitter</li><li>Weibo</li></ul></li><li><p>按日期查看过往记录<br><a href=http://i.caoyue.me/past>/past</a></p></li><li><p>对所有记录的统计图表<br><a href=http://i.caoyue.me/statistic>/statistic</a><br>Support：</p><ul><li>按时段统计</li><li>按月份统计</li><li>按分类统计</li></ul></li></ul><p><strong>TODO</strong></p><ul><li>其他第三方支持</li><li>搜索</li><li>Other&mldr;</li></ul><p><strong>Tools</strong></p><ul><li>Linux</li><li>Python</li><li>Web.py</li><li>Nginx/Gunicorn</li><li>MySql</li><li>Google Chart</li></ul><p><strong>Demo</strong></p><ul><li><a href=http://i.caoyue.me>Demo</a></li></ul><p><strong>License</strong></p><ul><li>MIT</li></ul><p><em>Feel free to give me some feedback:)</em></p></div><div class=tags><ul class=info><li>2013-07-30</li><li><a href=https://blog.caoyue.me/tags/python>#python</a></li><li><a href=https://blog.caoyue.me/tags/project>#project</a></li></ul></div></div><nav class=pager><a class=pre href=/page/3/>Previous</a>
<a class=next href=/page/5/>Next</a></nav></div><footer class=footer><div>©2022 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch(e){}</script></div></footer></div></body></html>