<!doctype html><html lang=zh-hans><head><meta name=generator content="Hugo 0.110.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#a6d6d6"><meta name=referrer content="no-referrer"><meta name=description content="如此生活三十年"><meta name=author content="caoyue"><title>且听疯吟</title><link rel=alternate type=application/rss+xml href=/index.xml title=且听疯吟><link rel=apple-touch-icon sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=48x48 href=https://blog.caoyue.me/favicon.png><link rel=icon type=image/png sizes=192x192 href=https://blog.caoyue.me/favicon.png><link rel=stylesheet type=text/css href=https://blog.caoyue.me/normalize.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/scss/style.css><link rel=stylesheet type=text/css href=https://blog.caoyue.me/syntax/monokailight.css id=syntax-theme><script type=text/javascript>function syntaxHighlight(){var e=document.querySelector("#syntax-theme");let t="https://blog.caoyue.me/syntax/monokailight.css",n="https://blog.caoyue.me/syntax/dracula.css",s=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?n:t;e.href=s}syntaxHighlight(),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{syntaxHighlight()})</script><script src=https://kit.fontawesome.com/061cfdc036.js crossorigin=anonymous></script></head><body><div class=wrap><header class=header><a href=/ title=且听疯吟>且听疯吟</a>
<span>如此生活三十年</span></header><div class=left><ul class=list><li><a href=/ title=Home>Home</a></li><li><a href=/tweets title=碎碎念>Tweets</a></li><li><a href=/archives title=Archives>Archives</a></li><li><a href=/tags title=Tags>Tags</a></li></ul></div><div class=right><div class=entry><div class=title><a href=https://blog.caoyue.me/post/react-and-react-native/>react and react native</a></div><div class=content><p>最近了解了下 react 和 react native，感觉看到了一条成为「Full-stack Developer」的捷径啊（雾</p><h3 id=react>React</h3><ul><li><p>消息同步<br>不管是 Web 还是 Native 应用，一个很麻烦的问题就是保持某个 Message 在不同 View 之间的状态同步。<br>比如，收到一条消息，需要在未读标签显示状态和数字，然后未读列表中插入一条消息记录。<br>阅读消息后，需要从未读中去掉这条记录，同时在已读中新增一条记录，还不能忘了将未读数字减去。<br>我们是怎么处理这种情况？<br>要在接收消息的 handler 中判断各个 View 当前的状态，然后根据对应的状态写不同的处理代码，阅读消息同理。当然高端点的可能自己搞个 Manager 之类的东西去对这些逻辑进行管理。<br>但是，并没有什么用。一旦业务复杂，处理和 Debug 起来就很麻烦了。看上去未读是 1，点进去发现是空，这种场景想必见得也不少了。</p><pre><code>还记得很久之前我们怎么写页面的吗？（多久？大概到 ASP 吧=-=
</code></pre><p>那时候我们没有这么多烦恼。因为我们是这么干的。不管什么操作，ok，刷新页面，可以保证所有状态都是正确的，so easy!<br>React + Flux 所做的正和我们很久之前的做法有点像。数据更新了？重新渲染一遍 View 不就好了。<br>但是将整个 DOM 重新渲染一遍是开销很大的，当然不可能真的这么做。<br>所以就有了 Virtual DOM。<br>其实我们对 View 所做的操作大部分都是修改内容，比如修改某个块里面的文字啦，对某个 list 增删改啦。这些都不需要完全重绘。<br>React 做到了「智能」去更新 DOM，只改变需要改变的地方。（嗯，就是不相信你能写出高效正确的操作 DOM 的代码，所以我们都帮你写好啦~（雾</p></li><li><p>组件化<br>通常我们的页面上的控件都是带有不同的状态的，比如选框是否选中等等。而不同情况下状态可能会根据一些参数去变化，这让一般情况下的组件复用变得很麻烦。<br>而 React 可以做到类似于函数的给定输入参数，输出固定的状态，可以很方便的实现 Web Components，也不会出现组件状态上的冲突。<br>而组件化的开发带来的效率提升是非常高的。</p></li><li><p>其他<br>另外经常看到人说 HTML 嵌在 JS 里面感觉很奇怪是不是模板耦合在代码里面之类的，我倒是觉得这种写法挺简洁优雅的。如果把 JSX 里面的 XML 看作是一个 XML 表示的 Object，这样理解可能会好点吧。当然你也可以使用纯 JS 的方式去写。</p></li></ul><p>好的东西往往是看上去简单实现复杂。<br>Java 本身虽然不怎么样，但是它可以让不同水平的人写出能够达到标准的代码，依然坚挺不是没有理由的。<br>所以我多少也有些认同 react 可以让不同水平的前端工程师写出符合效用的代码这个说法了。<br>算是一点并没有深入研究过前端的人的一点想法吧。</p><h3 id=react-native>React Native</h3><p>最近公司同时在做某个应用的 iOS 和 Android 版本，虽然没有参与开发，但是从两边的进程来看，大部分时间其实是把同一份逻辑翻译成 Objective-C 和 Java，但是这也是没办法的事情。<br>毕竟现有的 Hybrid App 方案表现都不太理想， Native 的优势暂时无法替代。如果可以借鉴 React 的优势和开发效率，同时带来 Native 的体验，excited！<br>所以 React Native 就顺理成章了。<br>难得的是 React 没有提「Write once, run anywhere」（JAVA：=-=）<br>而是 「<strong>Learn once, write anywhere</strong>」。</p><p>目前感觉除了基于 React 本身的那些优势外，React Native 在开发 App 方面也是很爽的</p><ul><li>效果<br>WebView 总是让我们感觉没有 Native 那么顺畅自然，大概是因为触摸反馈之类的原因吧。React Native 在这方面则没有这个问题，可以非常容易的用到 Native 的触摸和动画效果</li><li>flex 布局<br>熟悉 Web 那一套的话用起来还是很方便的。但是 React Native 的 flex 只是 Web 的 Lite 版，虽然尽力去做 Native 兼容，但是表现能力不如 Web 也不如 Native 是必然的，幸好移动端布局通常没有 Web 那么复杂。</li><li>组件化<br>React Native 提供了基本组件，通过自己组合，可以做出很多意想不到的效果。加上通过 npm 可以引入其他开源的组件，组合出一个 App 更加容易了。</li><li>效率<br>从安装 Xcode 到 写出一个新闻列表功能只花了两个小时，虽然之前完全没有接触过 iOS 开发。大公司项目这种提供详细文档和 starterkit 的作风真是太赞。</li><li>调试方便<br>即时刷新，用调试 Web 的方式调 App 真的很爽</li><li>集成到现有 App<br>可以将某个 React Native 实现的部分集成到现有 App 中，对已有的业务不产生影响</li></ul><p>缺点也有：</p><ul><li>平台<br>除了一些容易抽象的组件比如 ListView，View，Text 之外，目前很多组件是限于平台的。这点也是可以理解的，毕竟不同平台的 API 千差万别，很难做到通用。所以想要一次开发之后小小修改就可以通吃的可以醒醒了 =-=<br>这也导致实际上还是无法绕开去，必须要了解 Native 开发的一些组件和细节。比如在 iOS 中，首先你需要放一个 Tabbar，然后每个 Tabbar Item 里面放一个 Navigator，这和 Native 开发其实是差不多的模式。单纯从做 Web 过来的人，还是需要去学习这些东西才能开始。<br>但是比起完整使用 Native 开发，这个学习时间要短得多。</li><li>表现能力<br>虽然 React Native 的表现能力不如 Native ，但是它并不是为了取代 Native 开发存在的。在需要的领域做得足够好，这就够了。</li><li>第三方库<br>包括 React 和 React-Native 都有这个问题。事实上由于 Virtual DOM 和 React 革命性的架构方式，以往的第三方库很难做到直接可用了。而 React 的可用第三方库还不够多，当然社区还是挺活跃的，相信这个问题会好转。</li><li>成熟度<br>随着项目变大和引入的 package 变多，你会发现越来越多的莫名奇妙的出错和 bug，这个时候你需要耐心，放狗去搜。最容易找到解决方案的地方还是 Github 上的 issue list。有很多人会碰到同样的问题，也很可能会有人在下面给出解决的方法或是方向。当然，你也可以 subscribe 这个 issue，等待官方哪天大发慈悲解决掉它。</li><li>更新速度<br>更新太快有好处也有坏处。当你发现新版本解决了一个问题，迫不及待的想要更新的时候，可能发现：你的 App 挂了；第三方组件挂了；你必须升级一堆 package，并解决可能与之相关的问题。当然啦，大部分情况下还是没有那么蛋疼的。</li></ul><hr><p>虽然接触的时间不长，也有碰到一些小坑，但是目前看来，对我这种不会 Native 开发的人来说，React Native 是个非常不错的选择。<br>也许有时间会写写碰到过的坑和一些学习的建议之类的 :-)</p></div><div class=tags><ul class=info><li>2015-10-27</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li><li><a href=https://blog.caoyue.me/tags/react>#react</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/how-qq-quick-signin/>QQ 是怎么实现快速登录的</a></div><div class=content><p>这个问题之前很好解决，使用浏览器 plugin 即可。<br>但是随着 Chrome 和 Firefox 都先后放弃了 NPAPI plugin，这一方法也行不通了，而且很多人是很讨厌 plugin 的。<br>但是在默认禁止了 NPAPI 的 Chrome 版本，QQ 依然可以实现快速登录（一键登录），是怎么做到的呢？</p><h4 id=原理>原理</h4><p>其实不难猜。既然不存在 plugin，无法以此来实现浏览器内和本地客户端的直接通信，那么排除其他的黑科技，有一种很简单的方法可以实现这个效果。<br>那就是在客户端开一个 Server，在浏览器里面请求这个地址。<br>理论上这样是可以实现的，至于 QQ 是不是用的这种方法，稍微验证下好了。</p><h4 id=验证>验证</h4><ul><li><p>找一个有 QQ 快速登陆的页面，比如 <code>mail.qq.com</code></p></li><li><p>登陆 QQ 客户端</p></li><li><p>打开浏览器的 Developer Tools -> Network</p></li><li><p>刷新页面，观察所有请求的 domain</p></li><li><p>好明显，这就是我们要找的了</p><ul><li><p>完整请求 url 是这样的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>https://localhost.ptlogin2.qq.com:4301/pt_get_uins?callback=ptui_getuins_CB&amp;r=0.22949112393586502&amp;pt_local_tk=-2027291081
</span></span></code></pre></div></li><li><p>看看这个请求的 Response Content</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>var_sso_uin_list</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>account</span><span class=o>:</span> <span class=s2>&#34;xxxxxx&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>client_type</span><span class=o>:</span> <span class=mi>65793</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>face_index</span><span class=o>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>gender</span><span class=o>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>nickname</span><span class=o>:</span> <span class=s2>&#34;xxx&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>uin</span><span class=o>:</span> <span class=s2>&#34;xxx&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>uin_flag</span><span class=o>:</span> <span class=nx>xxxxx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>ptui_getuins_CB</span><span class=p>(</span><span class=nx>var_sso_uin_list</span><span class=p>);</span>
</span></span></code></pre></div><p>很明显是当前登录的用户信息</p></li><li><p>ping 一下这个请求的 domain<br>不出所料结果是 <code>127.0.0.1</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bat data-lang=bat><span class=line><span class=cl>ping localhost.ptlogin2.qq.com
</span></span><span class=line><span class=cl><span class=p>:</span><span class=c1>: Pinging localhost.ptlogin2.qq.com [127.0.0.1] with 32 bytes of data</span>
</span></span></code></pre></div></li></ul></li><li><p>现在我们验证下是否是 QQ 开了这个 Server</p><ul><li><p>查看哪个程序占用了 <code>4301</code> 端口</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bat data-lang=bat><span class=line><span class=cl>netstat -ano <span class=p>|</span> findstr <span class=s2>&#34;4301&#34;</span>
</span></span><span class=line><span class=cl><span class=p>:</span><span class=c1>:  TCP    127.0.0.1:4301   0.0.0.0:0   LISTENING   14516</span>
</span></span></code></pre></div></li><li><p>得到 pid 我们就可以看否是 QQ 在监听这个端口了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bat data-lang=bat><span class=line><span class=cl>tasklist <span class=p>|</span> findstr <span class=s2>&#34;14516&#34;</span>
</span></span><span class=line><span class=cl><span class=p>:</span><span class=c1>: QQ.exe  14516 Console   2     87,892 K</span>
</span></span></code></pre></div></li></ul></li></ul><h4 id=安全>安全</h4><p>可能有人担心会不会有安全问题，会不会其他网站访问这个 url 就拿走用户信息？其实挺容易解决，存一个 token 到服务端，获取的时候校验下就好了。<br>但是归根到底取决于腾讯对这方面安全的重视程度和意愿了，至少之前是确实存在从网页上获取当前登录的 QQ 信息的方法，虽然问题不是出在快速登录这部分。</p></div><div class=tags><ul class=info><li>2015-09-09</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/does-facebook-store-plain-text-passwords/>Does Facebook store plain-text passwords?</a></div><div class=content><p>越来越多的网站开始更加关注安全问题了，比如，Facebook 会在你把密码从 <code>abc123</code> 改为 <code>Abc123</code> 的时候的时候提示你</p><blockquote><p>Your new password is too similar to your current password. Please try another password.</p></blockquote><p>很贴心是不是？但是，他们是怎么做到的？难道 Facebook 保存了用户的明文密码么？</p><h4 id=编辑距离>编辑距离</h4><p>计算两个字符串的相似性，或者说「编辑距离」很容易，我们有很多现成的算法和代码。<br>但是，显然 Facebook 不会傻到存储明文密码，存储的肯定是 <code>hash("abc123")</code>。<br>而字符串中的差别和 hash 结果并不是一一对应的。两个相近的字符串，其 hash 结果可能差别很大。</p><h4 id=simhash>simhash</h4><p>可能你听说过 simhash 算法。Google 就是使用这种算法来做网页查重的。<br>传统的 hash 算法如 md5，一般尽可能要求结果分布均匀，因此，原始字符串的微小变动也会导致 hash 结果出现很大差异。<br>而 simhash 是一种局部敏感的 hash 算法，选定位数，提取特征，然后对每一段特征值计算 hash，然后将每一段值处理到 simhash 结果，得到最后的 simhash 值。比较海明距离就可以大概知道两个文档的相似度了。<br>具体的算法懂得不多就不瞎说了……大概可以推测，对于长文档这种方法是有效的，但是对于短文本，如 password 来说，效果可能不会太好。</p><h4 id=facebook-的做法>Facebook 的做法</h4><p>事实上这个问题好奇的人也很多，Stack Exchange 上有一个回答 <a href=http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords>http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords</a>，下面有一个自称接触过密码验证这部分代码的人肯定了这个猜测。<br>我觉得这种做法看起来还是挺合理的。</p><p>Facebook 用了一种看起来很「土」的方法，操作方法类似这样：</p><ol><li>用户注册，密码 <code>abc123</code>，Facebook 保存了 `hash(&ldquo;abc123&rdquo;)</li><li>用户修改密码，提交新密码 <code>Abc123</code></li><li>Facebook 拿到新密码，根据这个密码，生成一堆类似于 <code>ABC123</code>，<code>abc123</code> 这样相近的密码，使用同样的 hash 方法，去和 1 中的 hash 比对，一旦发现有相同的，那么可以判定新密码与旧密码是相似的。</li></ol><p>很好的反向思维，不是去计算相似性，而是通过生成一堆相似密码来「暴力」尝试。</p><h4 id=其他想法>其他想法</h4><p>事实上最初想到这个问题的时候，我考虑过这样的做法：</p><ol><li>用户修改密码操作时，提示输入原密码</li><li>server 临时记录用户的原密码</li><li>用户输入新密码，server 比对新旧密码</li><li>完成修改或过期后，销毁临时记录</li></ol><p>不过即使是临时记录依然可能存在风险，如果需要较高的安全性的话这种方法是不可取的。</p></div><div class=tags><ul class=info><li>2015-09-02</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/joe-armstrong-and-erlang/>Joe Armstrong and Erlang</a></div><div class=content><p>无意中翻到 Joe Armstrong 发在 erlang-questions 里的文章，<a href=http://erlang.org/pipermail/erlang-questions/2011-July/059965.html>Ways to get started</a> 以及 <a href=http://erlang.org/pipermail/erlang-questions/2013-January/071944.html>history of erlang</a>。<br>如果你不知道 Joe Armstrong 是谁，我们给他的另一个称呼是 the father of Erlang :)<br>大概没有人比他更有资格写这种文章了吧。<br>在高手眼中大道至简，我们不一定学的来，但是听听还是很有启发的</p><p>随便瞎扯几句</p><h4 id=忘掉工具>忘掉工具</h4><blockquote><p>Forget about git/IDEs/rebar etc.<br>Forget about the tools</p></blockquote><p>如果没有 IDE，没有自动打包工具，我们怎么编写和运行代码？<br>记住，shell 和文本编辑器对任何语言都是适用的。<br>当然我并不觉得这意味着需要放弃 IDE 之类的工具，而是在 get started 的时候，对程序怎么工作的有基本的了解是有好处的。<br>某种意义上来说，过于复杂的工具链意味着，一旦它没有按照你想象的运行，就需要花费更多的时间去解决它。</p><ul><li>rebar!<br><br>当然，不能忘了 rebar!<br>事实上 rebar 已经快要成为 erlang project 的标配了。</li></ul><blockquote><p>Tools like rebar etc are under to automate something but if you don&rsquo;t<br>know what it is that you are automating and if the tool doesn&rsquo;t work<br>you will just end up being incredible confused.</p></blockquote><p>「像 rebar 这样的工具会自动生成一些东西，但如果你不知道自动生成了什么，如果这些工具无法使用了，你将会变得困惑不已。」<br>说得好！<br>但是在更好的解决办法出现之前，也只能这么用了，寄希望于 OTP 组的改进吧，这一块也是我最不喜欢 erlang 的地方。</p><h4 id=黑>黑</h4><p>我一直觉得好的语言应该是某种程度上符合直觉的。这种直觉也许来自逻辑也许来自经验。<br>比如 erlang。<br>要举个反例也很容易，比如「世界上最好的语言」。<br>Joe Armstrong 是这么不经意的黑</p><blockquote><p>Notice there is no quick fix here - if you want a quick fix go buy<br>&ldquo;learn PHP in ten minutes&rdquo;<br>and spend the next twenty years googling for<br>&ldquo;how do I compute the length of a string&rdquo;</p></blockquote><p>hmm, well done!</p><h4 id=the-father-of-erlang>the father of Erlang</h4><p>Joe Armstrong 是个有趣的老头，也是真正的大师，推荐他的 <a href=http://joearms.github.io/>blog</a>，内容远远不止 erlang，可以看他讲讲信手拈来言简意赅的道理，喜欢八卦的话可以看他学 js 顺手黑黑其他语言 :)<br>以及他的 twitter <a href=https://twitter.com/joeerl>@joeerl</a></p><p>最后是一段以前放在 erlang.org 上的话，如果学完 erlang 你还不懂这段话，可能你需要从头再来一遍 :)</p><blockquote><p>The world is concurrent.<br>Things in the world don&rsquo;t share data.<br>Things communicate with messages.<br>Things fail.<br>                      - Joe Armstrong</p></blockquote><p>btw，Joe Armstrong 的邮箱地址是 erlang#gmail.com，是不是比 「I Wrote Python」 低调多了 :)</p></div><div class=tags><ul class=info><li>2015-08-22</li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/rename-user-folder-in-windows-10/>重命名 Windows 10 账户文件夹</a></div><div class=content><p>升级到 Windows 10 之后，很糟心的是通过 Microsoft Account 登录的时候，默认创建的账户文件夹居然不是 Microsoft Account 的 name，明明是 <a href=mailto:nick@outlook.com>nick@outlook.com</a>，结果创建出来的却是 nic …… 完全不知道这帮人怎么做到的 =-=<br>不管有没有强迫症，每次看到这个错的名字都实在不能忍，找到个修改的方法<br>参考了来自 superuser 的解决方法，原文针对的是 Windows 8，不过对 Windows 10 依然有效<br>原文地址 <a href=http://superuser.com/questions/495290/how-to-rename-user-folder-in-windows-8>http://superuser.com/questions/495290/how-to-rename-user-folder-in-windows-8</a></p><p>步骤如下：</p><ul><li>用 nic 代表原来的账户名</li><li>用 nick 代表新的账户名</li><li>下面的操作中用你自己的需求替换 nic 和 nick</li></ul><h4 id=1-创建一个本地管理员账户>1. 创建一个本地管理员账户</h4><p>Windows 10 中创建本地账户的选项藏得更深了，可以按如下方法操作</p><ul><li>打开 <code>Setting</code></li><li>找到 <code>Family & other users</code></li><li>点击 <code>Add someone else to this PC</code></li><li>弹出添加对话框，选择下面的 <code>the person I want to add doesn't have an email address</code></li><li>继续选择 <code>Add a user without a Microsoft Account</code></li><li>填写用户名密码，创建本地账户</li><li>点击创建的用户，<code>Change Account Type</code> 为 <code>Administrator</code></li></ul><h4 id=2-重命名账户名称>2. 重命名账户名称</h4><ul><li>退出当前账户，登录刚才创建的本地账户</li><li>打开 <code>Computer Management</code>，快捷键 <code>Win + X, G</code></li><li>打开 <code>System Tools</code></li><li>找到 <code>Local Users and Groups</code></li><li>打开 <code>Users</code>，找到需要修改的用户 <code>nic</code></li><li>右键点击，<code>Rename</code>，修改为你想要的 <code>nick</code></li></ul><h4 id=3-重命名账户文件夹>3. 重命名账户文件夹</h4><ul><li>打开管理员权限的 Cmd，快捷键 <code>Win + X, A</code></li><li>输入 <code>ren C:\Users\nic nick</code></li></ul><h4 id=4-修改注册表关联>4. 修改注册表关联</h4><ul><li>打开注册表编辑器，快捷键 <code>Win + X, R</code> 打开<code>运行</code>，然后输入 <code>regedit</code> 回车</li><li>找到 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\</code></li><li>一个个点开所有以 <code>S-1-5</code> 类似的字符开头的键，查看 <code>ProfileImagePath</code></li><li><code>ProfileImagePath</code> 值为 <code>C:\Users\nic</code> 的就是我们需要修改的账户，点击它，修改为 <code>C:\Users\nick</code></li></ul><h4 id=5-重新登录>5. 重新登录</h4><ul><li>使用原来的 Microsoft Acount 登录原先的账号</li><li>确定一切正常，账户文件夹也已经修改成功</li><li>可以删除创建的本地账户了</li></ul><p>hope it&rsquo;s helpful.</p></div><div class=tags><ul class=info><li>2015-08-01</li><li><a href=https://blog.caoyue.me/tags/life>#life</a></li><li><a href=https://blog.caoyue.me/tags/windows>#windows</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/xmpp-security/>XMPP 安全相关</a></div><div class=content><p>最近又从头看 XMPP 的 RFC<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，有时候也考虑如果是自己来设计，会如何做。<br>之前的印象是 XMPP 的繁琐和低效，现在看来，作为通用的协议，XMPP 确实有做得不错的地方，从头看下来还是有不少收获的。</p><p>现在项目告一段落，回头整理下 XMPP 服务端安全方面的一些简单想法，大概想到哪写到哪吧，安全方面懂得不多，欢迎指正。<br>考虑到安全，我们的初始目标大概包括这些：</p><ul><li>与服务端通信安全（不被窃听/篡改）</li><li>鉴别用户身份</li><li>保护用户数据</li></ul><h4 id=tls>TLS</h4><p>TLS<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 用于在两个通信应用程序之间提供保密性和数据完整性，是必须开启的。</p><h4 id=sasl>SASL</h4><p>SASL<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> 是一种验证用户身份的框架。XMPP 本身没有办法分辨用户身份，必须借助于 SASL 协议。<br>SASL 协议确定了客户端和服务端沟通的应答机制及传输的编码方法，剩下的就需要自己实现了。<br>要识别用户身份，你需要在 SASL 的框架下定义和服务端交换的具体身份信息（比如用户名、密码），以及实现身份信息的存储和验证方式，而不需要考虑其他细节。<br>具体到 XMPP 下 SASL 的验证流程（如果建立了 TLS 连接，此时是在 TLS 连接上的）：<br>一般不必支持所有的 SASL mechanisms ，选择安全性更可靠的，比如 <code>SCRAM-SHA-1</code> (尽量不要使用 plain)：</p><p>详细登录流程可以参考 <a href=http://blog.caoyue.me/post/ejabberd-login>ejabberd: Login</a></p><h4 id=scram-sha-1>SCRAM-SHA-1</h4><p><code>SCRAM</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>（Salted Challenge Response Authentication Mechanism） 是近年才开始使用的更安全的一种加密验证机制，可以很好的在 Server 和 Client 之间做双向的验证，已经有很多的服务开始使用这种方式验证了，比如 MongoDB。XMPP 也在协议中提供了这种方式的说明。<br>不讨论详细的加密算法细节，客户端验证登录时，大概流程如下：</p><ol><li>client 发送想要登录的 username 到 server (即 auth)</li><li>server 为该 username 生成/查找出 salt（s)，和 iteration count（i）、server nonce (r) 一并发回给 client （challenge，base64 编码）</li><li>client 使用给定的 salt 和 iteration count 加密持有的 password，发回给 server （如果服务端对该 client 使用的 salt 和 iteration count 是固定的话，可以存储下生成的 client key，从而避免在 client 明文存储密码，会更安全）</li><li>server 验证结果，如果成功则返回 success，并附上计算值</li><li>client 校验 success 中返回的值，通过则证明 server 拥有 client 的验证</li></ol><h4 id=end_to_end>end_to_end</h4><p>如果有非常严格的安全需求，可以考虑 OpenPGP ，XMPP 协议也提供了有限的支持<br>不过我个人觉得这种方法也不是那么完美：</p><ul><li>需要额外的交换 key 的渠道，而这些渠道不一定可信</li><li>杜绝不了伪造身份，你没法确定 id 对应的绑定的就一定是 key 的拥有者</li><li>信息冗长，加密的信息可能字节数会扩大到 10 倍甚至以上</li></ul><h4 id=文件服务>文件服务</h4><p>文件传输基本是现在 IM 客户端的基础功能了。<br>一般我们不会选择通过文本方式直接在消息中发送文件/图片，而是选择先上传到 HTTP 文件服务器，然后发送链接的形式。但是 HTTP 是无状态的，我们也不能每次在用户对资源操作的时候要求用户输入用户名密码。</p><p>首先考虑上传：</p><ul><li>上传通道泄露可能会带来滥用</li><li>AWS 可以使用 key 和 secret 校验上传请求</li><li>将 secret key 存放在客户端可能被逆向</li><li>XMPP 服务端可以看作可信的已鉴权服务</li></ul><p>所以可以考虑这样操作：</p><ul><li>已鉴权的客户端从 XMPP 服务端申请上传</li><li>文件服务器生成一个上传用的 token，生成方式可能是<br><code>token = hash(user + id + nonce + expire_stamp + secret)</code></li><li>XMPP 服务端从文件服务器获取生成的 token 并返回给客户端（假设 XMPP 服务端与文件服务器之间的通信是可信的，比如处于同一个内网。当然也可以 XMPP 服务端使用同样的 secret 和算法来计算 token 而不请求文件服务器）</li><li>客户端向文件服务器提交上传请求，并带上 <code>token, user, id, expire_stamp, nonce</code></li><li>文件服务器校验是否过期以及<br><code>hash(user + id + nonce + expire_stamp + secret) == token</code></li><li>校验通过，上传文件到 AWS S3 或其他存储服务，返回文件 id 给客户端</li></ul><p>然后是下载：<br>出于安全考虑，我们通常不会允许固定的 url 访问，而是通过增加验证和过期的方式来做一些限制。<br>一方面防止文件抓取，同时降低私密文件意外公开的风险，甚至可以通过更换 secret key，让公开的链接失效，强制客户端重新向服务端请求鉴权。<br>和上传文件类似：</p><ul><li>客户端提交请求的文件 id 给 XMPP 服务端-</li><li>XMPP 服务端用类似的方式生成一个 token 返回给客户端</li><li>客户端使用链接 + token 的形式访问文件资源</li><li>文件服务器校验 token, 以及是否过期等等，通过则返回资源</li></ul><p>当然现实情况可能用不到复杂的机制，也可以根据情况适当放松要求。<br>btw, 至少我抓包验证不止一个重量级的 App 使用的就是类似于 <code>http://xxxxx/uuid</code> 的永久文件地址= =。</p><h4 id=业务逻辑>业务逻辑</h4><p>即使在完善的安全机制下，也<strong>不要完全信任用户的输入</strong>！<br>不像网页上按按 F12 就可以拿到很多信息，可能移动设备给人一种难以 hack 的错觉，但是决定有没有人来搞的是值不值得，还有运气 :)</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>[1] <a href=http://xmpp.org/xmpp-protocols/internet-drafts/>http://xmpp.org/xmpp-protocols/internet-drafts/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>[2] <a href=https://en.wikipedia.org/wiki/Transport_Layer_Security>https://en.wikipedia.org/wiki/Transport_Layer_Security</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>[3] <a href=https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer>https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>[4] <a href=https://en.wikipedia.org/wiki/Salted_Challenge_Response_Authentication_Mechanism>https://en.wikipedia.org/wiki/Salted_Challenge_Response_Authentication_Mechanism</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=tags><ul class=info><li>2015-07-07</li><li><a href=https://blog.caoyue.me/tags/xmpp>#xmpp</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/if-csharp-support-void-generic-parameter/>如果 C# 支持 void 作为泛型参数</a></div><div class=content><h4 id=有些问题可能看起来无所谓但是开开脑洞还是挺有意思的>有些问题可能看起来无所谓，但是开开脑洞还是挺有意思的</h4><p>比如，最近碰到一个问题，简化形式是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>Range</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=p>&lt;=</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// DoSomething1...</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Range</span><span class=p>(</span><span class=n>n</span><span class=p>).</span><span class=n>ForEach</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>void</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=看出问题了么>看出问题了么？</h4><ul><li><p><code>IEnumerable</code> 接口是没有 <code>ForEach</code> 方法的，<code>ForEach</code> 是 <code>List&lt;T></code> 的方法，所以只能写成</p><pre><code>```csharp
Enumerable.Range(0, n).ToList().ForEach(x =&gt; DoSomething(x));
```
</code></pre><p>但是显然这样就失去了延迟执行的意义了</p></li><li><p>我们也可以尝试使用 <code>IEnumerable</code> 的 <code>Select</code> 方法，变成这样：</p><pre><code>```csharp
Enumerable.Range(0, n).Select(x =&gt; DoSomething2(x));
```
</code></pre><p>当然这样也行不通，因为我们的 <code>DoSomething2</code> 方法是 <code>void</code> 类型的</p></li><li><p>最后只能粗暴的给 <code>DoSomething2</code> 包装一个返回值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Enumerable</span><span class=p>.</span><span class=n>Range</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>n</span><span class=p>).</span><span class=n>Select</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=k>return</span> <span class=k>true</span><span class=p>;</span> <span class=p>});</span>
</span></span></code></pre></div></li></ul><h4 id=如果-ienumerable-支持-foreach-方法就好了>如果 <code>IEnumerable</code> 支持 <code>ForEach</code> 方法就好了？</h4><ul><li>事实上 C# 设计者对此作了解释：<a href=http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx>“foreach” vs “ForEach”</a></li><li>总之来说，<code>List&lt;T>.ForEach</code> 是 <code>List&lt;T></code> 本身的方法， Linq 不会提供有副作用的方法，它违反了 Linq <code>side-effect-free</code> 的设计理念</li><li>Mmm，听起来好像很有道理 :(</li></ul><p>当然，这个例子本身不具有太大的意义，但是——</p><h4 id=不妨开个脑洞>不妨开个脑洞</h4><p>如果可以用 <code>void</code> 作为泛型参数呢？</p><ul><li><p>这样的代码不再有问题了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Enumerable</span><span class=p>.</span><span class=n>Range</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>n</span><span class=p>).</span><span class=n>Select</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=k>void</span><span class=p>&gt;(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>DoSomething2</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
</span></span></code></pre></div></li><li><p>也并没有违反 Linq 的设计理念（当然，取决于你怎么看了 :(</p></li><li><p>更大的好处在于：<br>如果把 <code>void</code> 看作泛型的一种，可以在不增加复杂度的前提下简化一些问题<br>比如<strong>不需要为 <code>MyClass</code> 和 <code>MyClass&lt;T></code> 写两次相同的代码了</strong><br>因为 <code>MyClass</code> 就相当于 <code>MyClass&lt;void></code>，我们可以统一所有处理逻辑，不再需要大堆的重载了。</p></li></ul><hr><p>搜索的时候发现有很多大牛讨论过这个问题了，受益匪浅<br>比如 <a href=http://blog.zhaojie.me/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html>C#的设计缺陷（2）：不能以 void 作为泛型参数</a></p></div><div class=tags><ul class=info><li>2015-06-26</li><li><a href=https://blog.caoyue.me/tags/csharp>#csharp</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/about-erlang-records/>About Erlang: Records</a></div><div class=content><h4 id=1-tuple-and-record>1. tuple and record</h4><p>现在有一些键值对，它们和给定 record 的项一一对应，如何转换成 record?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>-</span><span class=ni>record</span><span class=p>(</span><span class=nl>test</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nn>a</span><span class=p>::</span><span class=nf>binary</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=nn>b</span><span class=p>::</span><span class=nf>binary</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>KeyValuePairs</span> <span class=o>=</span> <span class=p>[{</span><span class=n>a</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;a&#34;</span><span class=o>&gt;&gt;</span><span class=p>},{</span><span class=n>b</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;b&#34;</span><span class=o>&gt;&gt;</span><span class=p>}].</span>
</span></span></code></pre></div><p>很基础的问题，我们这样做：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>Result</span> <span class=o>=</span> <span class=nl>#test</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}.</span>
</span></span></code></pre></div><p>如果 record 有一百个项呢？<br>重复的写 <code>a = get_value(a, KeyValuePairs)</code> 这样的代码一百次大概会让人怀疑「猿」生吧 :(</p><p>虽然 Erlang 并没有提供动态生成 record 的方法，但是我们知道</p><ul><li><strong>Erlang 的 record 实际上是用 tuple 来表示的</strong>，即 <code>#test{a = &lt;&lt;"a">>, b = &lt;&lt;"b">>}</code> 实际上是 <code>{test, &lt;&lt;"a">>, &lt;&lt;"b">>}</code></li><li><strong>所有在运行时对 record 的操作实际上都是对 tuple 的操作</strong></li><li><code>Result#test.a</code> 实际上是 tuple 的 index</li><li>可以使用 <code>record_info(fields, record)</code> 获取 Record 的 fields 信息</li></ul><p>所以我们可以这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nv>Result</span> <span class=o>=</span> <span class=nb>list_to_tuple</span><span class=p>([</span><span class=n>test</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>get_value</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=n>test</span><span class=p>)]]).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>Result</span><span class=nl>#test.a</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=c>%% &lt;&lt;&#34;a&#34;&gt;&gt;
</span></span></span></code></pre></div><h4 id=2-record_info>2. record_info</h4><p>很容易想到，我们要是把处理函数抽象出来，不是多了一个 <code>kvpairs_to_record</code> 的接口了么？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>-</span><span class=ni>spec</span> <span class=n>kvpairs_to_record</span><span class=p>(</span><span class=n>kvpairs</span><span class=p>(),</span> <span class=n>atom</span><span class=p>())</span> <span class=o>-&gt;</span> <span class=n>rec</span><span class=p>().</span>
</span></span><span class=line><span class=cl><span class=nf>kvpairs_to_record</span><span class=p>(</span><span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=nv>Record</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>	<span class=nb>list_to_tuple</span><span class=p>([</span><span class=nv>Record</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=n>get_value</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=nv>Record</span><span class=p>)]]).</span>
</span></span></code></pre></div><p>很遗憾，行不通。编译的时候会报出 <code>illegal record info</code> 错误。</p><p>WTF?</p><ul><li><code>record_info</code> 并不是一个通常意义上的 BIF，它不能接受变量</li><li>其原因在于 record structure 只存在于编译期，<strong>在运行时是不可见的</strong>，编译完成后，record 就已经被表示成为 tuple 了，自然没有办法在运行时再获取 record info 了</li></ul><p>所以你只能这么「曲线救国」了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=nf>kvpairs_to_record</span><span class=p>(</span><span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=nv>Record</span><span class=p>,</span> <span class=nv>RecordInfo</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>	<span class=nb>list_to_tuple</span><span class=p>([</span><span class=nv>Record</span> <span class=p>|</span> <span class=p>[</span><span class=n>get_value</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=nv>RecordInfo</span><span class=p>]]).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>Result</span> <span class=o>=</span> <span class=n>kvpairs_to_record</span><span class=p>(</span><span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=n>test</span><span class=p>,</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=n>test</span><span class=p>)).</span>
</span></span></code></pre></div><h4 id=3-macro-and-record>3. macro and record</h4><p>所以就这样放弃了？<br>当然不，为了「代码洁癖」我们可以「不择手段」。<br>考虑到 define macro 也是编译期的，我们可以这样 trick</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-erlang data-lang=erlang><span class=line><span class=cl><span class=p>-</span><span class=ni>module</span><span class=p>(</span><span class=n>test</span><span class=p>).</span>
</span></span><span class=line><span class=cl><span class=p>-</span><span class=ni>export</span><span class=p>([</span><span class=n>do</span><span class=o>/</span><span class=mi>0</span><span class=p>]).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span><span class=ni>define</span><span class=p>(</span><span class=no>fuxk</span><span class=p>(</span><span class=nv>Record</span><span class=p>,</span> <span class=nv>Val</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nb>list_to_tuple</span><span class=p>([</span><span class=nv>Record</span> <span class=p>|</span> <span class=p>[</span><span class=nb>get</span><span class=p>(</span><span class=nv>X</span><span class=p>,</span> <span class=nv>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>||</span> <span class=nv>X</span> <span class=o>&lt;-</span> <span class=n>record_info</span><span class=p>(</span><span class=n>fields</span><span class=p>,</span> <span class=nv>Record</span><span class=p>)]])</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=p>).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span><span class=ni>record</span><span class=p>(</span><span class=nl>test</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=p>::</span> <span class=n>binary</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=p>::</span> <span class=n>binary</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>do</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>KV</span> <span class=o>=</span> <span class=p>[{</span><span class=n>a</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;a&#34;</span><span class=o>&gt;&gt;</span><span class=p>},{</span><span class=n>b</span><span class=p>,</span> <span class=o>&lt;&lt;</span><span class=s>&#34;b&#34;</span><span class=o>&gt;&gt;</span><span class=p>}],</span>
</span></span><span class=line><span class=cl>    <span class=nv>Result</span> <span class=o>=</span> <span class=o>?</span><span class=n>fuxk</span><span class=p>(</span><span class=n>test</span><span class=p>,</span> <span class=nv>KV</span><span class=p>)(),</span>
</span></span><span class=line><span class=cl>    <span class=nv>Result</span><span class=nl>#test.a</span><span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=c>% &lt;&lt;&#34;a&#34;&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nb>get</span><span class=p>(</span><span class=nv>Key</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nn>proplists</span><span class=p>:</span><span class=nf>get_value</span><span class=p>(</span><span class=nv>Key</span><span class=p>,</span> <span class=nv>KeyValuePairs</span><span class=p>,</span> <span class=n>undefined</span><span class=p>).</span>
</span></span></code></pre></div><p>Goodness gracious - it works!</p><h4 id=4-beam-and-record>4. beam and record</h4><p>当然像上面那样写实际上也没有好多少，依然还是不完美。<br>如果一定需要在运行时得到 record info 呢？<br>比如我们热升级代码，需要更新 record 定义怎么办？</p><p>幸好，record structure 会被写入到 beam 中，我们只需要 load beam 然后解析它，还是可以达到运行时获取 record info 的效果的。<br>具体实现可以参考 <a href=https://github.com/esl/parse_trans>https://github.com/esl/parse_trans</a></p><p>当然，除非知道自己在做什么，否则<strong>不推荐</strong>这么做。</p><h4 id=5-最后>5. 最后</h4><p>实际上我很好奇为什么 Erlang 不提供运行时访问 record structure 呢？信息已经存在于 beam 中了，实现一下不难吧。<br>最后，如果不需要考虑兼容，<strong>推荐使用 <code>map</code> 来替代 <code>record</code></strong>，<code>map</code> 在运行时数据结构可见并且可以增删成员。</p></div><div class=tags><ul class=info><li>2015-05-27</li><li><a href=https://blog.caoyue.me/tags/erlang>#erlang</a></li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/mptt-tree/>预排序遍历算法树</a></div><div class=content><p><img src=http://ww2.sinaimg.cn/large/3e69b0ccgw1et1gl2lw6wj20o20d30ti.jpg alt=mptt></p><h4 id=1-预排序遍历树算法>1. 预排序遍历树算法</h4><ul><li>mptt (Modified Preorder Tree Traversal)<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>优点<br>查询效率高，只需要一次查询即可获得层级结构中某个节点的所有子节点，无需递归查询</li><li>缺点<br>插入、删除、移动节点效率较低</li><li>适用<br>在传统关系数据库中实现层级树结构<ul><li>读压力 > 写压力， mptt 算法可以提高效率</li><li>写压力 > 读压力，使用传统的邻接表 (adjacency list model)</li></ul></li></ul><h4 id=2-增删查改>2. 增删查改</h4><ul><li><p>Create</p><ul><li>假设增加的节点为 <code>c</code>, 该节点前一节点为 <code>p</code></li><li>节点 <code>c</code> 左值为 <code>p</code> 的右值 <code>+1</code>，右值为 <code>p</code> 右值 <code>+2</code></li><li>所有左值大于节点 <code>c</code> 的左值的节点，其左值均 <code>+2</code></li><li>所有右值大于节点 <code>c</code> 的右值的节点，其右值均 <code>+2</code></li><li>写入节点 <code>c</code> 到数据库</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>mptt</span><span class=w>	</span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;p&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>mptt</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>mptt</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>mptt</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>lft</span><span class=p>,</span><span class=w> </span><span class=n>rgt</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div></li><li><p>Read</p><ul><li><p>查询节点 <code>c</code> 的子节点：</p><ul><li><p>查询所有左值大于 <code>c</code> 的左值且右值小于 <code>c</code> 的右值的节点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>mptt</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=o>@</span><span class=n>cLeft</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><p>查询节点 <code>c</code> 的父节点：</p><ul><li><p>查询所有左值小于 <code>c</code> 的左值且右值大于 <code>c</code> 的右值(或左值)的节点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>mptt</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=o>@</span><span class=n>cLeft</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>@</span><span class=n>cLeft</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><p>节点 <code>c</code> 的子节点个数：</p><ul><li><code>(c.right - c.left - 1) / 2</code></li></ul></li></ul></li><li><p>Update<br>移动节点即：</p><ul><li>删除节点</li><li>在指定位置新增节点</li></ul></li><li><p>Delete</p><ul><li>删除节点 <code>c</code></li><li>所有右值大于 <code>c</code> 右值的节点，右值 <code>-2</code></li><li>所有左值大于 <code>c</code> 左值的节点，左值 <code>-2</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>DELETE</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>mptty</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=o>@</span><span class=n>cLeft</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>mptt</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>rgt</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>@</span><span class=n>cRight</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>mptt</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>lft</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>@</span><span class=n>cLeft</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div></li></ul><h4 id=3-重建树结构>3. 重建树结构</h4><p>很容易推断，对排序好的 mptt tree，仅需要一次遍历，即可根据所有节点的左右值记录重建树结构<br>以 python 为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Node class</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>(</span><span class=n>Node</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>depth</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=c1># arg: Node List</span>
</span></span><span class=line><span class=cl> <span class=k>def</span> <span class=nf>rebuild</span><span class=p>(</span><span class=n>l</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># 节点按左值排序，即遍历顺序</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># 使用列表暂存每层子树的父节点</span>
</span></span><span class=line><span class=cl>        <span class=c1># 如 pi[0] 表示第 2 层的节点的父节点在 l 中的 index</span>
</span></span><span class=line><span class=cl>        <span class=n>pi</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>l</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>c</span><span class=o>.</span><span class=n>left</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span> <span class=o>=</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 使用 c 表示此节点，p 表示 c 的前一节点</span>
</span></span><span class=line><span class=cl>                <span class=c1># 如果连续的两个节点 c 和 p 的左值增加幅度为 1，则说明其深度增加了 1</span>
</span></span><span class=line><span class=cl>                <span class=c1># 且 p 为 c 及 c 的兄弟节点的父节点</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>c</span><span class=o>.</span><span class=n>left</span> <span class=o>==</span> <span class=n>p</span><span class=o>.</span><span class=n>left</span> <span class=o>+</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>c</span><span class=o>.</span><span class=n>depth</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>c</span><span class=o>.</span><span class=n>depth</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>pi</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                        <span class=n>pi</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>pi</span><span class=p>[</span><span class=n>c</span><span class=o>.</span><span class=n>depth</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 如果 c 的左值大于 p 的父节点的右值，则说明 p 与 c 并非兄弟节点</span>
</span></span><span class=line><span class=cl>                <span class=c1># 并可以计算出两节点的深度差为 c 的左值与 p 的右值之差减 1</span>
</span></span><span class=line><span class=cl>                <span class=k>elif</span> <span class=n>c</span><span class=o>.</span><span class=n>left</span> <span class=o>&gt;</span> <span class=n>l</span><span class=p>[</span><span class=n>pi</span><span class=p>[</span><span class=n>p</span><span class=o>.</span><span class=n>depth</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]]</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>c</span><span class=o>.</span><span class=n>depth</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>depth</span> <span class=o>-</span> <span class=p>(</span><span class=n>c</span><span class=o>.</span><span class=n>left</span> <span class=o>-</span> <span class=n>p</span><span class=o>.</span><span class=n>right</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 不满足以上两个条件，说明 c 是 p 的兄弟节点</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>c</span><span class=o>.</span><span class=n>depth</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>depth</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			    <span class=c1># 将 c 作为 pi 中记录的父节点的子节点</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=p>[</span><span class=n>pi</span><span class=p>[</span><span class=n>c</span><span class=o>.</span><span class=n>depth</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]]</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span>
</span></span></code></pre></div><hr><h4 id=update>Update</h4><p>完整代码及生成 Json 和基于 D3.js<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 的树状图：<br><a href=https://gist.github.com/caoyue/704e472215af29b08a27>https://gist.github.com/caoyue/704e472215af29b08a27</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>[1] <a href=http://www.sitepoint.com/hierarchical-data-database-2>http://www.sitepoint.com/hierarchical-data-database-2</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>[2] <a href=http://d3js.org>http://d3js.org</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=tags><ul class=info><li>2015-05-11</li><li><a href=https://blog.caoyue.me/tags/programming>#programming</a></li></ul></div></div><div class=entry><div class=title><a href=https://blog.caoyue.me/post/about-unicode/>关于 unicode</a></div><div class=content><p>对这些概念头疼了很久，尝试简单的整理下，不确切的地方欢迎指正~</p><h4 id=1-unicode>1. Unicode</h4><ul><li>Unicode 是一个<strong>字符集</strong>，而不是一种编码方案</li><li>简单来说 Unicode 是希望给地球上每一个字符一个数字编号，从而解决不同编码之间不统一的问题</li><li>Unicode 是没法直接拿来用的，我们使用的是它的编码方案</li></ul><h4 id=2-编码方案>2. 编码方案</h4><ul><li>通常使用的 <code>UTF-8</code>，<code>UTF-16</code> 等等都是 Unicode 的编码方案</li><li>所谓编码方案就是按一定的规则对 Unicode 的字符编号进行编码</li><li>当然不同的编码的<strong>同一个字符</strong>，最后解析成 Unicode 字符编号都是一样的</li></ul><h4 id=3-字体与-unicode>3. 字体与 Unicode</h4><ul><li>计算机使用字符的 Unicode 编号去寻找字体内的字符</li><li>字体内部的特殊数据结构存储了 Unicode 编号和字符的对应关系</li></ul><h4 id=4-例子>4. 例子</h4><ul><li>汉字 <code>月</code> 的 Unicode 编号 10 进制为 <code>26376</code></li><li>Unicode 编号表示为 16 进制 是 <code>U+6708</code></li><li>在 python 中用 <code>u"\u6708"</code> 表示</li><li>在 UTF-8 中的编码是 <code>0xE6 0x9C 0x88</code> ，使用了 3 个 Byte 来表示</li></ul><h4 id=5-utf-8-和-unicode-转换>5. UTF-8 和 Unicode 转换</h4><ul><li><p>Unicode 转 UTF-8</p><ul><li>汉字 <code>月</code> 的 Unicode 是 <code>26376</code>，转换为二进制是 <code>1100111 00001000</code></li><li>根据值大于 <code>0x800</code> 小于 <code>0x10000</code> 可以判断为三字节存储</li><li>将 Unicode 二进制从低位往高位取出二进制数字，每次取 6 位，并按一定的规则进行填补</li></ul><blockquote><h4 id=转换>转换</h4><p>110 011100 001000<br><strong>1110</strong>0110 <strong>10</strong>011100 <strong>10</strong>001000<br>0xE6 0x9C 0x88</p></blockquote></li><li><p>UTF-8 转 Unicode<br>同理进行逆运算即可</p></li></ul><h4 id=6-遗留编码>6. 遗留编码</h4><ul><li><code>ASCII</code>、<code>GB 2312</code>、<code>Big5</code>、<code>GBK</code>、<code>GB 18030</code> 这些都属于遗留编码方案</li><li>GB 2312 通常认为是<strong>字符集</strong>和<strong>编码方案</strong>一体的</li><li>将 GB 2313 编码转换为 Unicode 编号，需要通过转换表查询，无法像 UTF-8 一样直接根据编码规则转换</li></ul></div><div class=tags><ul class=info><li>2015-04-28</li></ul></div></div><nav class=pager><a class=pre href=/>Previous</a>
<a class=next href=/page/3/>Next</a></nav></div><footer class=footer><div>©2023 <a href=/>且听疯吟</a>. designed
by <a href=https://caoyue.me target=_blank>caoyue</a>.
powered by <a href=https://gohugo.io/ target=_blank>hugo</a>.
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
<script defer src=https://use.typekit.net/jdb5cpn.js></script>
<script type=text/javascript>try{Typekit.load({async:!0})}catch{}</script></div></footer></div></body></html>