<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#a6d6d6"/><meta name="msapplication-TileColor" content="#a6d6d6"/><meta name="msapplication-TileImage" content="/icon/favicon.ico"/><meta name="referrer" content="no-referrer"/><title>且听疯吟</title><link rel="alternate" type="application/rss+xml" title="atom 1.0" href="/atom.xml"/><link rel="apple-touch-icon" sizes="192x192" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="48x48" href="/icon/favicon.ico"/><link rel="icon" type="image/png" sizes="192x192" href="/icon/favicon.ico"/><link rel="stylesheet" href="/css/normalize.css"/><link rel="stylesheet" href="/css/style.css"/><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><div class="header"><a href="/" title="this is a link">且听疯吟</a><span>如此生活三十年</span></div><div class="left"><ul class="list"><li><a href="/" title="Home">Home</a></li><li><a href="/archives" title="archive">Archive</a></li><li><a href="/tags" title="Tags">Tags</a></li></ul></div><div class="right"><div class="entry"><div class="title"><a href="/post/hearthstone/">炉石卡牌实现机制的一点猜想</a></div><div class="content"><p>假设我们要实现一个炉石的对战机制，要怎么做呢？<br>并没有游戏开发经验，所以以下都是乱猜加瞎扯~</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>首先，我们把炉石里的主要元素分成几类：</p>
<ul>
<li><p>法术<br>法术很好理解，一般来说法术包括几个要素</p>
<ul>
<li>目标<ul>
<li>可能是一个目标也可能是多个目标</li>
<li>可能包含一个筛选，比如「对非恶魔随从造成伤害」</li>
</ul>
</li>
<li>效果<ul>
<li>可能是给目标一个 buff 或者 debuff，也可能是造成伤害等等</li>
<li>大部分法术都是立即效果</li>
<li>也有一部分法术是触发效果，比如 <code>奥秘</code>，比如 <code>本回合随从生命值不会降低到 1 点以下</code></li>
</ul>
</li>
</ul>
</li>
<li><p>武器</p>
</li>
<li><p>英雄</p>
<ul>
<li>英雄技能可以看作一个法术</li>
</ul>
</li>
<li><p>随从</p>
<ul>
<li><p>随从本身具有的属性</p>
<ul>
<li>花费&#x2F;攻击&#x2F;血量</li>
<li>类别： 恶魔&#x2F;鱼人&#x2F;野兽</li>
<li>其他<br>我们以 <a target="_blank" rel="noopener" href="https://hearthstonejson.com/">https://hearthstonejson.com/</a> 上的卡牌火车王的 Json 数据为例：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;EX1_116&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leeroy Jenkins&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;&lt;b&gt;Charge&lt;/b&gt;. &lt;b&gt;Battlecry:&lt;/b&gt; Summon two 1/1 Whelps for your opponent.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rarity&quot;</span>: <span class="string">&quot;LEGENDARY&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;MINION&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cost&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;attack&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;health&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;collectible&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;set&quot;</span>: <span class="string">&quot;EXPERT1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;faction&quot;</span>: <span class="string">&quot;ALLIANCE&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;artist&quot;</span>: <span class="string">&quot;Gabe from Penny Arcade&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;flavor&quot;</span>: <span class="string">&quot;At least he has Angry Chicken.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mechanics&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;BATTLECRY&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CHARGE&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;dust&quot;</span>: [</span><br><span class="line">        <span class="number">1600</span>,</span><br><span class="line">        <span class="number">3200</span>,</span><br><span class="line">        <span class="number">400</span>,</span><br><span class="line">        <span class="number">1600</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>随从效果</p>
<ul>
<li>即上面的 <code>mechanics</code> 数据</li>
<li>目前炉石包括了 <code>冲锋、亡语、发现、战吼、法术伤害、连击</code> 等等大概二十多种效果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>法术效果<ul>
<li>法术效果相对来说容易归纳</li>
</ul>
</li>
<li>随从效果<ul>
<li>实际上随从效果可以认为是法术效果，比如自带亡语的随从，可以认为是通过法术给予了亡语效果——毕竟，炉石里面确实存在着这样的法术</li>
<li>具有亡语效果 <code>随机召唤一个法力消耗为 3 的随从</code> 的随从死亡时，可以认为是使用了一个 <code>随机召唤一个法力消耗为 3 的随从</code> 的法术</li>
<li>光环是一种特殊的法术效果，拥有更加复杂的触发条件，比如 <code>将你的治疗法术或技能改为造成等量的伤害</code></li>
</ul>
</li>
</ul>
<h3 id="对局"><a href="#对局" class="headerlink" title="对局"></a>对局</h3><ul>
<li>从对局中我们可以总结出一些规则，比如大家经常会讨论的 <code>结算顺序</code><ul>
<li>虽然打出一张牌表面上看起来很简单，但是背后其实包括了多个阶段，比如：<ul>
<li>选择战吼目标并出牌，此时扣费</li>
<li>登场效果触发，这个时候一部分其他卡牌的效果已经会被触发，比如 <code>任务达人</code></li>
<li>召唤效果触发，比如会触发 <code>送葬者</code></li>
<li>战吼效果触发，此时开始结算战吼效果</li>
<li>奥秘效果触发，这也是为什么 <code>谢娜</code> 这张牌可以先偷到复制但是自己本身并不会被复制</li>
<li>召唤结束，这时会触发 <code>飞刀杂耍者</code> 之类的效果<br>（结算比较复杂，而且涉及到各种死亡结算和效果，而且暴雪也没有出官方的结算规则，所以，以上只是举个栗子~</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>从上面的例子可以看到，不同的牌在不同的阶段触发效果<br>假设我们需要实现一张 <code>飞刀杂耍者</code>，每召唤一个随从就发射一把飞刀<ul>
<li>我们可以很容易分开两个角色<ul>
<li>系统，它担任裁判的角色</li>
<li>卡牌<br>这样由系统去执行整个流程，在召唤了一个随从后，通知 <code>飞刀杂耍者</code> 去执行发射飞刀的任务</li>
</ul>
</li>
</ul>
</li>
<li>显然我们没办法把所有卡牌逻辑都塞在 <code>系统</code> 这个角色中，假设我们有 500 张卡牌，那么 <code>系统</code> 这部分的调用代码可能会突破天际</li>
<li>我们也不能让 <code>飞刀杂耍者</code> 自己去监控整场对局，从而决定什么时候发射飞刀，显然这样 <code>系统</code> 这个角色就失去了其意义，代码也会无比混乱</li>
<li>实际上对于这样的问题，我们有一个经典的例子（或许你在面试中已经被问了无数次的 「猫叫老鼠跑人醒」）<ul>
<li>这就是观察者模式（事件-通知）</li>
<li>我们只需要让 <code>飞刀杂耍者</code> 在 <code>系统</code> 那里注册一个事件，告诉它，有随从被召唤的时候，通知我，然后由我来执行对应的逻辑</li>
<li><code>系统</code> 则需要维护一个注册的事件列表，比如随从被召唤的事件、随从死亡的事件等等</li>
<li><code>系统</code> 按结算规则来执行，并在对应的事件触发的时候，按一定的顺序去通知即可</li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>炉石包含很多不同的效果，事实上这也正是它好玩的地方，但一来暴雪没有出明确的结算规则和效果解释，有些卡牌的效果也找不到同类和规律（比如改变战吼效果的 <code>铜须</code> 光环，和改变法术执行目标的 <code>扰咒术</code> 等等），所以有些时候想总结一套规则来套用所有卡牌不太容易</li>
<li>对于单个的特殊的效果，hardcode 也是一个解决办法</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>额外插一点关于炉石插件的内容，之前看到有童鞋在好奇</p>
<ul>
<li>炉石传说有一个隐藏的 debug-logging 模式，打开之后会产生非常详细的记录，通过解析这个 log 可以做到记录和获取对局信息</li>
<li>网易的盒子貌似额外使用了抓包解析的方法，所以功能会强大一些，比如导入导出卡组的功能</li>
<li>但是考虑到可能触犯 ToS ，其他插件没有这么做</li>
<li>log 大概是这样的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Zone] ZoneChangeList.ProcessChanges() - id=1 local=False [name=Garrosh Hellscream id=4 zone=PLAY zonePos=0 cardId=HERO_01 player=1] zone from -&gt; FRIENDLY PLAY (Hero)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出 log 是非常详细的，包含各种事件的触发</li>
<li>解析完整的 log 可以帮助理解整个炉石的事件机制</li>
</ul>
</li>
<li>当初想要自己实现盒子的时候参考过这篇文章 <a target="_blank" rel="noopener" href="https://www.reddit.com/r/hearthstone/comments/268fkk/simple_hearthstone_logging_see_your_complete_play">https://www.reddit.com/r/hearthstone/comments/268fkk/simple_hearthstone_logging_see_your_complete_play</a></li>
<li>当然现在很多开源的插件了，比如 <a target="_blank" rel="noopener" href="https://github.com/HearthSim/Hearthstone-Deck-Tracker">https://github.com/HearthSim/Hearthstone-Deck-Tracker</a></li>
</ul>
<h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><p>想到哪写到哪，有什么想法再补充吧 &#x3D;-&#x3D;</p>
</div><div><ul class="info"><li>2016-05-31</li><li><a href="/tags/programming/">#programming</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/wow-chronicle/">晒书：《魔兽世界编年史》</a></div><div class="content"><p>从《凯恩之书》开始就期待了，终于出了编年史<br>不负责任的猜想是暴雪觉得魔兽世界这个剧情坑太大太多懒得圆吧<br>还好终于出了</p>
<p>中亚还是挺快的，原来预计发货时间排到 6 月，都想去美亚订了<br>幸好还是提前发货了</p>
<p>大部分是为信仰充值吧<br>不过这次编年史的内容还是挺有趣的<br>有很多剧情上的填坑和重新解读<br>当然也少不了暴雪粑粑的吃书</p>
<p>比预计的要薄一点，但还是挺有分量的<br>这只是 Volume Ⅰ，估计后续还会有几本（SHUT UP AND TAKE MY MONEY!</p>
<p>印刷质量还行，但也没有到惊艳的程度。<br>意外的发现 Printed in China &#x3D;-&#x3D;</p>
<p>英文看得还是有点费力……<br>慢慢啃吧，有什么好玩的内容会更新在这里（大概吧~</p>
<p><img src="https://ww2.sinaimg.cn/mw690/3e69b0ccgw1f2n9piedyzj20qo0tftfw.jpg"><br><img src="https://ww4.sinaimg.cn/mw690/3e69b0ccgw1f2n9pbgaqij20qo0qodmy.jpg"></p>
<hr>
<p>###For the Horde!</p>
</div><div><ul class="info"><li>2016-04-06</li><li><a href="/tags/life/">#life</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/react-native-travis-ci-ios/">使用 Travis CI 自动部署 React Native 项目 （iOS 篇）</a></div><div class="content"><p>编译、测试、打包、部署这一系列的操作实在是太麻烦而且容易出错漏，能自动化的东西我们就没必要手动去点。端着咖啡悠哉地等着叮的一声，安装包出现在面前，这才是我们想要的<br>花了点时间，把正在进行的 React Native 项目的自动部署完善了一下，实现了通过 Travis CI 自动编译测试，并打包成 ipa 发布到 FTP 的整个流程<br>现在只要 Push 到 Github 上，等到 Travis CI 运行完成，就直接可以拿到 ipa 包安装测试了</p>
<p>准备工作：<br>首先你需要一个 Github 账户<br>Travis CI 连接 Gtihub 后，会自动检查根目录下带有 <code>.travis.yml</code> 的项目<br>关于 Travis CI 的功能和文档，请参考 <a target="_blank" rel="noopener" href="https://docs.travis-ci.com/">https://docs.travis-ci.com/</a></p>
<p>这里给出一个 React Native 项目的 yml 文件示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">objective-c</span></span><br><span class="line"><span class="attr">osx_image:</span> <span class="string">xcode7.1</span></span><br><span class="line"><span class="attr">xcode_project:</span> <span class="string">ios/MyApp.xcodeproj</span></span><br><span class="line"><span class="attr">xcode_scheme:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">    <span class="attr">matrix:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SPEC=spec1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./scripts/decrypt_key.sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./scripts/add_key.sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">brew</span> <span class="string">update</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">brew</span> <span class="string">reinstall</span> <span class="string">node</span> <span class="string">flow</span> <span class="string">watchman</span> <span class="string">xctool</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">react-native-cli</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./scripts/release.sh</span></span><br></pre></td></tr></table></figure>

<h4 id="首先设置项目编译环境："><a href="#首先设置项目编译环境：" class="headerlink" title="首先设置项目编译环境："></a>首先设置项目编译环境：</h4><p>包括 <code>language</code> 和 要使用的编译镜像 <code>osx_image</code>，并指定项目文件和编译的 scheme</p>
<h4 id="证书加密："><a href="#证书加密：" class="headerlink" title="证书加密："></a>证书加密：</h4><p>由于 iOS 打包过程需要一些证书密钥，这些是无法公开 Push 到 Github 的<br>虽然 Travis CI 没有提供 security file 的功能，但是提供了一个 security 的环境变量的功能<br>因此，我们可以通过在本地加密证书然后上传，线上编译时再解开来实现这一目的</p>
<p>比如：</p>
<ul>
<li>Encrypt</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encrypt_key.sh</span></span><br><span class="line">openssl aes-256-cbc -k <span class="variable">$&#123;ENCRYPT_PASS&#125;</span> -<span class="keyword">in</span> scripts/MyAppdev.mobileprovision -out scripts/MyAppdev.mobileprovision.enc -a</span><br><span class="line">openssl aes-256-cbc -k <span class="variable">$&#123;ENCRYPT_PASS&#125;</span> -<span class="keyword">in</span> scripts/dist.cer -out scripts/dist.cer.enc -a</span><br><span class="line">openssl aes-256-cbc -k <span class="variable">$&#123;ENCRYPT_PASS&#125;</span> -<span class="keyword">in</span> scripts/dist.p12 -out scripts/dist.p12.enc -a</span><br></pre></td></tr></table></figure>

<ul>
<li>Decrypt</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decrypt_key.sh</span></span><br><span class="line">openssl aes-256-cbc -k <span class="variable">$&#123;ENCRYPT_PASS&#125;</span> -<span class="keyword">in</span> scripts/MyAppdev.mobileprovision.enc -out scripts/MyAppdev.mobileprovision -d -a</span><br><span class="line">openssl aes-256-cbc -k <span class="variable">$&#123;ENCRYPT_PASS&#125;</span> -<span class="keyword">in</span> scripts/dist.cer.enc -out scripts/dist.cer -d -a</span><br><span class="line">openssl aes-256-cbc -k <span class="variable">$&#123;ENCRYPT_PASS&#125;</span> -<span class="keyword">in</span> scripts/dist.p12.enc -out scripts/dist.p12 -d -a</span><br></pre></td></tr></table></figure>

<p><strong>注意： 请不要直接上传你的证书和密钥！也不要把密码上传到公开的地方！</strong></p>
<h4 id="导入证书到-Travis-编译环境："><a href="#导入证书到-Travis-编译环境：" class="headerlink" title="导入证书到 Travis 编译环境："></a>导入证书到 Travis 编译环境：</h4><p>参考下面的步骤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add_key.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a custom keychain</span></span><br><span class="line">security create-keychain -p travis ios-build.keychain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the custom keychain default, so xcodebuild will use it for signing</span></span><br><span class="line">security default-keychain -s ios-build.keychain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unlock the keychain</span></span><br><span class="line">security unlock-keychain -p travis ios-build.keychain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set keychain timeout to 1 hour for long builds</span></span><br><span class="line"><span class="comment"># see http://www.egeek.me/2013/02/23/jenkins-and-xcode-user-interaction-is-not-allowed/</span></span><br><span class="line">security set-keychain-settings -t 3600 -l ~/Library/Keychains/ios-build.keychain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add certificates to keychain and allow codesign to access them</span></span><br><span class="line">security import ./scripts/apple.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign</span><br><span class="line">security import ./scripts/dist.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign</span><br><span class="line">security import ./scripts/dist.p12 -k ~/Library/Keychains/ios-build.keychain -P <span class="variable">$KEY_PASS</span> -T /usr/bin/codesign</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the provisioning profile in place</span></span><br><span class="line">mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles</span><br><span class="line">cp <span class="string">&quot;./scripts/MyAppdev.mobileprovision&quot;</span> ~/Library/MobileDevice/Provisioning\ Profiles/</span><br></pre></td></tr></table></figure>

<h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><p>安装编译所需要的环境，比如 xctool、node、npm、react-native 等等</p>
<h4 id="编译和打包"><a href="#编译和打包" class="headerlink" title="编译和打包"></a>编译和打包</h4><p>举个栗子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># release.sh</span></span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">react-native bundle --dev <span class="literal">false</span> --platform ios \</span><br><span class="line">    --bundle-output <span class="string">&quot;/tmp/main.jsbundle&quot;</span> --entry-file index.ios.js</span><br><span class="line"></span><br><span class="line">xctool -project ios/MyApp.xcodeproj -scheme MyApp build -sdk iphoneos \</span><br><span class="line">    configuration Release OBJROOT=<span class="variable">$PWD</span>/build SYMROOT=<span class="variable">$PWD</span>/build</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $? != 0 ]];<span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; build failed&quot;</span></span><br><span class="line">     <span class="built_in">exit</span> 1;</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PROVISIONING_PROFILE=<span class="string">&quot;<span class="variable">$HOME</span>/Library/MobileDevice/Provisioning Profiles/MyAppdev.mobileprovision&quot;</span></span><br><span class="line">OUTPUTDIR=<span class="string">&quot;<span class="variable">$PWD</span>/build/Release-iphoneos&quot;</span></span><br><span class="line">NAME=Esports_<span class="variable">$&#123;TRAVIS_COMMIT:0:6&#125;</span>.ipa</span><br><span class="line"></span><br><span class="line">xcrun -<span class="built_in">log</span> -sdk iphoneos PackageApplication <span class="string">&quot;<span class="variable">$OUTPUTDIR</span>/MyApp.app&quot;</span> \</span><br><span class="line">    -o <span class="string">&quot;<span class="variable">$OUTPUTDIR</span>/<span class="variable">$NAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $? != 0 ]];<span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; package application failed&quot;</span></span><br><span class="line">     <span class="built_in">exit</span> 1;</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OUTPUTDIR</span></span><br><span class="line">curl --ftp-create-dirs -T <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span> -u <span class="variable">$FTP_USER</span>:<span class="variable">$FTP_PASSWORD</span> \</span><br><span class="line">    ftp://<span class="variable">$FTP_SERVER</span>/esports/<span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; &#123;<span class="variable">$NAME</span>&#125; uploaded!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; all done!&quot;</span></span><br></pre></td></tr></table></figure>

<p>基本上和本地编译运行 React Native 项目类似，不同之处在于使用了 xctool 命令行来编译</p>
<ul>
<li>首先安装依赖 package</li>
<li>然后 react-native bundle （如果使用 online 的模式，可以忽略这一步）</li>
<li>使用 xctool 编译和测试项目</li>
<li>打包 App 为 ipa 文件</li>
<li>FTP 发布（Travis CI 支持多种发布方式，可以参考文档实现）</li>
<li>完成，邮件或 IM 通知（如果你需要）</li>
</ul>
<hr>
<p>ref: <a target="_blank" rel="noopener" href="https://www.objc.io/issues/6-build-tools/travis-ci/">https://www.objc.io/issues/6-build-tools/travis-ci/</a></p>
</div><div><ul class="info"><li>2016-03-09</li><li><a href="/tags/programming/">#programming</a></li><li><a href="/tags/react/">#react</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/react-and-react-native/">react and react native</a></div><div class="content"><p>最近了解了下 react 和 react native，感觉看到了一条成为「Full-stack Developer」的捷径啊（雾</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul>
<li><p>消息同步<br>不管是 Web 还是 Native 应用，一个很麻烦的问题就是保持某个 Message 在不同 View 之间的状态同步。<br>比如，收到一条消息，需要在未读标签显示状态和数字，然后未读列表中插入一条消息记录。<br>阅读消息后，需要从未读中去掉这条记录，同时在已读中新增一条记录，还不能忘了将未读数字减去。<br>我们是怎么处理这种情况？<br>要在接收消息的 handler 中判断各个 View 当前的状态，然后根据对应的状态写不同的处理代码，阅读消息同理。当然高端点的可能自己搞个 Manager 之类的东西去对这些逻辑进行管理。<br>但是，并没有什么用。一旦业务复杂，处理和 Debug 起来就很麻烦了。看上去未读是 1，点进去发现是空，这种场景想必见得也不少了。</p>
<pre><code>还记得很久之前我们怎么写页面的吗？（多久？大概到 ASP 吧=-=
</code></pre>
<p>那时候我们没有这么多烦恼。因为我们是这么干的。不管什么操作，ok，刷新页面，可以保证所有状态都是正确的，so easy!<br> React + Flux 所做的正和我们很久之前的做法有点像。数据更新了？重新渲染一遍 View 不就好了。<br>但是将整个 DOM 重新渲染一遍是开销很大的，当然不可能真的这么做。<br>所以就有了 Virtual DOM。<br>其实我们对 View 所做的操作大部分都是修改内容，比如修改某个块里面的文字啦，对某个 list 增删改啦。这些都不需要完全重绘。<br>React 做到了「智能」去更新 DOM，只改变需要改变的地方。（嗯，就是不相信你能写出高效正确的操作 DOM 的代码，所以我们都帮你写好啦~（雾</p>
</li>
<li><p>组件化<br>通常我们的页面上的控件都是带有不同的状态的，比如选框是否选中等等。而不同情况下状态可能会根据一些参数去变化，这让一般情况下的组件复用变得很麻烦。<br>而 React 可以做到类似于函数的给定输入参数，输出固定的状态，可以很方便的实现 Web Components，也不会出现组件状态上的冲突。<br>而组件化的开发带来的效率提升是非常高的。</p>
</li>
<li><p>其他<br>另外经常看到人说 HTML 嵌在 JS 里面感觉很奇怪是不是模板耦合在代码里面之类的，我倒是觉得这种写法挺简洁优雅的。如果把 JSX 里面的 XML 看作是一个 XML 表示的 Object，这样理解可能会好点吧。当然你也可以使用纯 JS 的方式去写。</p>
</li>
</ul>
<p>好的东西往往是看上去简单实现复杂。<br>Java 本身虽然不怎么样，但是它可以让不同水平的人写出能够达到标准的代码，依然坚挺不是没有理由的。<br>所以我多少也有些认同 react 可以让不同水平的前端工程师写出符合效用的代码这个说法了。<br>算是一点并没有深入研究过前端的人的一点想法吧。</p>
<h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><p>最近公司同时在做某个应用的 iOS 和 Android 版本，虽然没有参与开发，但是从两边的进程来看，大部分时间其实是把同一份逻辑翻译成 Objective-C 和 Java，但是这也是没办法的事情。<br>毕竟现有的 Hybrid App 方案表现都不太理想， Native 的优势暂时无法替代。如果可以借鉴 React 的优势和开发效率，同时带来 Native 的体验，excited！<br>所以 React Native 就顺理成章了。<br>难得的是 React 没有提「Write once, run anywhere」（JAVA：&#x3D;-&#x3D;）<br>而是 「<strong>Learn once, write anywhere</strong>」。</p>
<p>目前感觉除了基于 React 本身的那些优势外，React Native 在开发 App 方面也是很爽的</p>
<ul>
<li>效果<br>WebView 总是让我们感觉没有 Native 那么顺畅自然，大概是因为触摸反馈之类的原因吧。React Native 在这方面则没有这个问题，可以非常容易的用到 Native 的触摸和动画效果</li>
<li>flex 布局<br>熟悉 Web 那一套的话用起来还是很方便的。但是 React Native 的 flex 只是 Web 的 Lite 版，虽然尽力去做 Native 兼容，但是表现能力不如 Web 也不如 Native 是必然的，幸好移动端布局通常没有 Web 那么复杂。</li>
<li>组件化<br>React Native 提供了基本组件，通过自己组合，可以做出很多意想不到的效果。加上通过 npm 可以引入其他开源的组件，组合出一个 App 更加容易了。</li>
<li>效率<br>从安装 Xcode 到 写出一个新闻列表功能只花了两个小时，虽然之前完全没有接触过 iOS 开发。大公司项目这种提供详细文档和 starterkit 的作风真是太赞。</li>
<li>调试方便<br>即时刷新，用调试 Web 的方式调 App 真的很爽</li>
<li>集成到现有 App<br>可以将某个 React Native 实现的部分集成到现有 App 中，对已有的业务不产生影响</li>
</ul>
<p>缺点也有：</p>
<ul>
<li>平台<br>除了一些容易抽象的组件比如 ListView，View，Text 之外，目前很多组件是限于平台的。这点也是可以理解的，毕竟不同平台的 API 千差万别，很难做到通用。所以想要一次开发之后小小修改就可以通吃的可以醒醒了 &#x3D;-&#x3D;<br>这也导致实际上还是无法绕开去，必须要了解 Native 开发的一些组件和细节。比如在 iOS 中，首先你需要放一个 Tabbar，然后每个 Tabbar Item 里面放一个 Navigator，这和 Native 开发其实是差不多的模式。单纯从做 Web 过来的人，还是需要去学习这些东西才能开始。<br>但是比起完整使用 Native 开发，这个学习时间要短得多。</li>
<li>表现能力<br>虽然 React Native 的表现能力不如 Native ，但是它并不是为了取代 Native 开发存在的。在需要的领域做得足够好，这就够了。</li>
<li>第三方库<br>包括 React 和 React-Native 都有这个问题。事实上由于 Virtual DOM 和 React 革命性的架构方式，以往的第三方库很难做到直接可用了。而 React 的可用第三方库还不够多，当然社区还是挺活跃的，相信这个问题会好转。</li>
<li>成熟度<br>随着项目变大和引入的 package 变多，你会发现越来越多的莫名奇妙的出错和 bug，这个时候你需要耐心，放狗去搜。最容易找到解决方案的地方还是 Github 上的 issue list。有很多人会碰到同样的问题，也很可能会有人在下面给出解决的方法或是方向。当然，你也可以 subscribe 这个 issue，等待官方哪天大发慈悲解决掉它。</li>
<li>更新速度<br>更新太快有好处也有坏处。当你发现新版本解决了一个问题，迫不及待的想要更新的时候，可能发现：你的 App 挂了；第三方组件挂了；你必须升级一堆 package，并解决可能与之相关的问题。当然啦，大部分情况下还是没有那么蛋疼的。</li>
</ul>
<hr>
<p>虽然接触的时间不长，也有碰到一些小坑，但是目前看来，对我这种不会 Native 开发的人来说，React Native 是个非常不错的选择。<br>也许有时间会写写碰到过的坑和一些学习的建议之类的 :-)</p>
</div><div><ul class="info"><li>2015-10-27</li><li><a href="/tags/programming/">#programming</a></li><li><a href="/tags/react/">#react</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/how-qq-quick-signin/">QQ 是怎么实现快速登录的</a></div><div class="content"><p>这个问题之前很好解决，使用浏览器 plugin 即可。<br>但是随着 Chrome 和 Firefox 都先后放弃了 NPAPI plugin，这一方法也行不通了，而且很多人是很讨厌 plugin 的。<br>但是在默认禁止了 NPAPI 的 Chrome 版本，QQ 依然可以实现快速登录（一键登录），是怎么做到的呢？</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>其实不难猜。既然不存在 plugin，无法以此来实现浏览器内和本地客户端的直接通信，那么排除其他的黑科技，有一种很简单的方法可以实现这个效果。<br>那就是在客户端开一个 Server，在浏览器里面请求这个地址。<br>理论上这样是可以实现的，至于 QQ 是不是用的这种方法，稍微验证下好了。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li><p>找一个有 QQ 快速登陆的页面，比如 <code>mail.qq.com</code></p>
</li>
<li><p>登陆 QQ 客户端</p>
</li>
<li><p>打开浏览器的 Developer Tools -&gt; Network</p>
</li>
<li><p>刷新页面，观察所有请求的 domain</p>
</li>
<li><p>好明显，这就是我们要找的了</p>
<ul>
<li><p>完整请求 url 是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://localhost.ptlogin2.qq.com:4301/pt_get_uins?callback=ptui_getuins_CB&amp;r=0.22949112393586502&amp;pt_local_tk=-2027291081</span><br></pre></td></tr></table></figure>
</li>
<li><p>看看这个请求的 Response Content</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_sso_uin_list = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">account</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">        <span class="attr">client_type</span>: <span class="number">65793</span>,</span><br><span class="line">        <span class="attr">face_index</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">gender</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">nickname</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">        <span class="attr">uin</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">        <span class="attr">uin_flag</span>: xxxxx,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line">ptui_getuins_CB(var_sso_uin_list);</span><br></pre></td></tr></table></figure>

<p>很明显是当前登录的用户信息</p>
</li>
<li><p>ping 一下这个请求的 domain<br>不出所料结果是 <code>127.0.0.1</code></p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ping</span> localhost.ptlogin2.qq.com</span><br><span class="line">:: Pinging localhost.ptlogin2.qq.com [<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>] with <span class="number">32</span> bytes of data</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>现在我们验证下是否是 QQ 开了这个 Server</p>
<ul>
<li><p>查看哪个程序占用了 <code>4301</code> 端口</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> &quot;<span class="number">4301</span>&quot;</span><br><span class="line">::  TCP    <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">4301</span>   <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">0</span>   LISTENING   <span class="number">14516</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>得到 pid 我们就可以看否是 QQ 在监听这个端口了</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasklist | <span class="built_in">findstr</span> &quot;<span class="number">14516</span>&quot;</span><br><span class="line">:: QQ.exe  <span class="number">14516</span> Console   <span class="number">2</span>     <span class="number">87</span>,<span class="number">892</span> K</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>可能有人担心会不会有安全问题，会不会其他网站访问这个 url 就拿走用户信息？其实挺容易解决，存一个 token 到服务端，获取的时候校验下就好了。<br>但是归根到底取决于腾讯对这方面安全的重视程度和意愿了，至少之前是确实存在从网页上获取当前登录的 QQ 信息的方法，虽然问题不是出在快速登录这部分。</p>
</div><div><ul class="info"><li>2015-09-09</li><li><a href="/tags/programming/">#programming</a></li></ul></div></div><div class="entry"><div class="title"><a href="/post/does-facebook-store-plain-text-passwords/">Does Facebook store plain-text passwords?</a></div><div class="content"><p>越来越多的网站开始更加关注安全问题了，比如，Facebook 会在你把密码从 <code>abc123</code> 改为 <code>Abc123</code> 的时候的时候提示你</p>
<blockquote>
<p>Your new password is too similar to your current password. Please try another password.</p>
</blockquote>
<p>很贴心是不是？但是，他们是怎么做到的？难道 Facebook 保存了用户的明文密码么？</p>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p>计算两个字符串的相似性，或者说「编辑距离」很容易，我们有很多现成的算法和代码。<br>但是，显然 Facebook 不会傻到存储明文密码，存储的肯定是 <code>hash(&quot;abc123&quot;)</code>。<br>而字符串中的差别和 hash 结果并不是一一对应的。两个相近的字符串，其 hash 结果可能差别很大。</p>
<h4 id="simhash"><a href="#simhash" class="headerlink" title="simhash"></a>simhash</h4><p>可能你听说过 simhash 算法。Google 就是使用这种算法来做网页查重的。<br>传统的 hash 算法如 md5，一般尽可能要求结果分布均匀，因此，原始字符串的微小变动也会导致 hash 结果出现很大差异。<br>而 simhash 是一种局部敏感的 hash 算法，选定位数，提取特征，然后对每一段特征值计算 hash，然后将每一段值处理到 simhash 结果，得到最后的 simhash 值。比较海明距离就可以大概知道两个文档的相似度了。<br>具体的算法懂得不多就不瞎说了……大概可以推测，对于长文档这种方法是有效的，但是对于短文本，如 password 来说，效果可能不会太好。</p>
<h4 id="Facebook-的做法"><a href="#Facebook-的做法" class="headerlink" title="Facebook 的做法"></a>Facebook 的做法</h4><p>事实上这个问题好奇的人也很多，Stack Exchange 上有一个回答 <a target="_blank" rel="noopener" href="http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords">http://security.stackexchange.com/questions/53481/does-facebook-store-plain-text-passwords</a>，下面有一个自称接触过密码验证这部分代码的人肯定了这个猜测。<br>我觉得这种做法看起来还是挺合理的。</p>
<p>Facebook 用了一种看起来很「土」的方法，操作方法类似这样：</p>
<ol>
<li>用户注册，密码 <code>abc123</code>，Facebook 保存了 &#96;hash(“abc123”)</li>
<li>用户修改密码，提交新密码 <code>Abc123</code></li>
<li>Facebook 拿到新密码，根据这个密码，生成一堆类似于 <code>ABC123</code>，<code>abc123</code> 这样相近的密码，使用同样的 hash 方法，去和 1 中的 hash 比对，一旦发现有相同的，那么可以判定新密码与旧密码是相似的。</li>
</ol>
<p>很好的反向思维，不是去计算相似性，而是通过生成一堆相似密码来「暴力」尝试。</p>
<h4 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h4><p>事实上最初想到这个问题的时候，我考虑过这样的做法：</p>
<ol>
<li>用户修改密码操作时，提示输入原密码</li>
<li>server 临时记录用户的原密码</li>
<li>用户输入新密码，server 比对新旧密码</li>
<li>完成修改或过期后，销毁临时记录</li>
</ol>
<p>不过即使是临时记录依然可能存在风险，如果需要较高的安全性的话这种方法是不可取的。</p>
</div><div><ul class="info"><li>2015-09-02</li><li><a href="/tags/programming/">#programming</a></li></ul></div></div><div class="pager"><a class="pre" href="/">Previous</a>   <a class="next" href="/page/3/">Next</a></div></div><div class="footer"><div></div>©2021<a href="https://blog.caoyue.me"> 且听疯吟</a>. designed by<a href="https://caoyue.me" target="_blank"> caoyue</a>. powered by<a href="https://hexo.io/" target="_blank"> hexo</a></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "1a24e73fd4284bfa8b43ecf5a5c2c100"}'></script>
</div></body></html>